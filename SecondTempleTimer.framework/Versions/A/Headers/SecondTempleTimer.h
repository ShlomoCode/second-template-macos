#import <Foundation/NSArray.h>
#import <Foundation/NSDictionary.h>
#import <Foundation/NSError.h>
#import <Foundation/NSObject.h>
#import <Foundation/NSSet.h>
#import <Foundation/NSString.h>
#import <Foundation/NSValue.h>

@class STTTimeIntervalCompanion, STTTimeInterval, STTJewishDate, STTGeoLocation, STTAstronomicalCalendarCompanion, STTAstronomicalCalendar, STTKotlinx_datetimeInstant, STTAstronomicalCalculator, STTKotlinx_datetimeLocalDateTime, STTZmanimCalendarCompanion, STTZmanValueBased, STTZmanDateBased, STTZmanimCalendar, STTKotlinx_datetimeLocalDate, STTComplexZmanimCalendarCompanion, STTZman<T>, STTZmanType, STTJewishCalendar, STTKotlinx_datetimeLocalTime, STTKotlinx_datetimeTimeZone, STTZmanDefinition, STTZmanDescriptionFormatterCompanion, STTDafCompanion, STTDaf, STTKotlinArray<T>, STTHebrewDateFormatterCompanion, STTJewishCalendarParsha, STTHebrewMonth, STTHebrewLocalDateCompanion, STTHebrewLocalDate, STTKotlinx_datetimeMonth, STTKotlinEnumCompanion, STTKotlinEnum<E>, STTHebrewMonthCompanion, STTHebrewMonthHebrewMonthRange, STTJewishDateCompanion, STTKotlinx_datetimeDateTimeUnit, STTJewishCalendarCompanion, STTKotlinx_datetimeDayOfWeek, STTYerushalmiYomiCalculator, STTYomiCalculator, STTZmanRelationship, STTOccurrence, STTUsesElevation, STTZmanAuthorityAccordingTo, STTZmanAuthority, STTZmanAuthorityAHAVAT_SHALOM, STTZmanAuthorityARUCH_HASHULCHAN, STTZmanAuthorityAteretTorah, STTZmanAuthorityBAAL_HATANYA, STTZmanAuthorityBICK, STTZmanAuthorityCHASSAN_SOFER, STTZmanAuthorityCHAVAS_YAIR, STTZmanAuthorityDIVREI_MALKIEL, STTZmanAuthorityDIVREI_YOSEF, STTZmanAuthorityEDELSTEIN, STTZmanAuthorityEIDOT_HAMIZRACH, STTZmanAuthorityFEINSTEIN, STTZmanAuthorityGEONIM, STTZmanAuthorityGRA, STTZmanAuthorityGREENWALD, STTZmanAuthorityHISACHDUS_HARABONIM, STTZmanAuthorityKAMENETSKY, STTZmanAuthorityKOMARNO, STTZmanAuthorityKRONGLASS, STTZmanAuthorityLECHEM_MISHNAH, STTZmanAuthorityMAAGALEI_TZEDEK, STTZmanAuthorityMACHATZIS_HASHEKEL, STTZmanAuthorityMAHARIK, STTZmanAuthorityMAHARIL, STTZmanAuthorityMGA, STTZmanAuthorityMINCHAS_COHEN, STTZmanAuthorityNEIMAN, STTZmanAuthorityPOSEN, STTZmanAuthorityPRI_MEGADIM, STTZmanAuthorityRAAVAN, STTZmanAuthorityRABEINU_TAM, STTZmanAuthorityRABEINU_YONAH, STTZmanAuthorityRAMBAM, STTZmanAuthorityRAZEH, STTZmanAuthoritySATMER, STTZmanAuthoritySHACH, STTZmanAuthoritySHAKOW, STTZmanAuthoritySHOR, STTZmanAuthoritySHULCHAN_ARUCH, STTZmanAuthoritySHVUS_YAAKOV, STTZmanAuthorityStrings, STTZmanAuthorityUnanimous, STTZmanAuthorityWEISS, STTZmanAuthorityYAAVETZ, STTZmanAuthorityYEREIM, STTZmanAuthorityZILBER, STTZmanCalculationMethodCompanion, STTZmanCalculationMethodDegrees, STTZmanCalculationMethodFixedDuration, STTZmanCalculationMethodZmaniyosDuration, STTZmanCalculationMethodDayDefinitionCompanion, STTZmanCalculationMethodDayDefinition, STTZmanCalculationMethodDegreesCompanion, STTZmanCalculationMethodFixedDurationCompanion, STTZmanCalculationMethodFixedDurationAteretTorah, STTZmanCalculationMethodFixedLocalChatzos, STTZmanCalculationMethodLaterOf, STTZmanCalculationMethodRelationship, STTZmanCalculationMethodUnspecified, STTZmanCalculationMethodZmaniyosDurationCompanion, STTZmanTypeCompanion, STTAstronomicalCalculatorCompanion, STTDateUtils, STTKotlinx_datetimeLocalDateCompanion, STTLocation, STTGeoLocationCompanion, STTNOAACalculatorCompanion, STTKotlinTriple<__covariant A, __covariant B, __covariant C>, STTSunTimesCalculatorCompanion, STTTimeCompanion, STTTime, STTWeekFormat, STTKotlinx_datetimeInstantCompanion, STTKotlinx_datetimeLocalDateTimeCompanion, STTKotlinx_datetimeLocalTimeCompanion, STTKotlinx_datetimeTimeZoneCompanion, STTKotlinx_datetimeDateTimeUnitCompanion, STTKotlinx_serialization_coreSerializersModule, STTKotlinx_serialization_coreSerialKind, STTKotlinNothing, STTKotlinx_datetimeFixedOffsetTimeZone, STTKotlinx_datetimeDateTimeUnitMonthBased, STTKotlinx_datetimeDateTimeUnitDayBased, STTKotlinx_datetimeDateTimeUnitTimeBased, STTKotlinx_datetimePadding, STTKotlinx_datetimeDayOfWeekNames, STTKotlinx_datetimeMonthNames, STTKotlinx_datetimeUtcOffset, STTKotlinx_datetimeFixedOffsetTimeZoneCompanion, STTKotlinx_datetimeDateTimeUnitDateBasedCompanion, STTKotlinx_datetimeDateTimeUnitDateBased, STTKotlinx_datetimeDateTimeUnitMonthBasedCompanion, STTKotlinx_datetimeDateTimeUnitDayBasedCompanion, STTKotlinx_datetimeDateTimeUnitTimeBasedCompanion, STTKotlinx_datetimeDayOfWeekNamesCompanion, STTKotlinx_datetimeMonthNamesCompanion, STTKotlinx_datetimeUtcOffsetCompanion;

@protocol STTKotlinx_serialization_coreKSerializer, STTTimeIntervalProvider, STTZmanCalculationMethod, STTKotlinComparable, STTKotlinClosedRange, STTKotlinIterator, STTKotlinIterable, STTWeekFormatFormatter, STTKotlinx_serialization_coreEncoder, STTKotlinx_serialization_coreSerialDescriptor, STTKotlinx_serialization_coreSerializationStrategy, STTKotlinx_serialization_coreDecoder, STTKotlinx_serialization_coreDeserializationStrategy, STTKotlinx_datetimeDateTimeFormat, STTKotlinx_datetimeDateTimeFormatBuilderWithDate, STTKotlinx_serialization_coreCompositeEncoder, STTKotlinAnnotation, STTKotlinx_serialization_coreCompositeDecoder, STTKotlinx_datetimeDateTimeFormatBuilderWithDateTime, STTKotlinx_datetimeDateTimeFormatBuilderWithTime, STTKotlinAppendable, STTKotlinx_datetimeDateTimeFormatBuilder, STTKotlinx_serialization_coreSerializersModuleCollector, STTKotlinKClass, STTKotlinKDeclarationContainer, STTKotlinKAnnotatedElement, STTKotlinKClassifier, STTKotlinx_datetimeDateTimeFormatBuilderWithUtcOffset;

NS_ASSUME_NONNULL_BEGIN
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunknown-warning-option"
#pragma clang diagnostic ignored "-Wincompatible-property-type"
#pragma clang diagnostic ignored "-Wnullability"

#pragma push_macro("_Nullable_result")
#if !__has_feature(nullability_nullable_result)
#undef _Nullable_result
#define _Nullable_result _Nullable
#endif

__attribute__((swift_name("KotlinBase")))
@interface STTBase : NSObject
- (instancetype)init __attribute__((unavailable));
+ (instancetype)new __attribute__((unavailable));
+ (void)initialize __attribute__((objc_requires_super));
@end

@interface STTBase (STTBaseCopying) <NSCopying>
@end

__attribute__((swift_name("KotlinMutableSet")))
@interface STTMutableSet<ObjectType> : NSMutableSet<ObjectType>
@end

__attribute__((swift_name("KotlinMutableDictionary")))
@interface STTMutableDictionary<KeyType, ObjectType> : NSMutableDictionary<KeyType, ObjectType>
@end

@interface NSError (NSErrorSTTKotlinException)
@property (readonly) id _Nullable kotlinException;
@end

__attribute__((swift_name("KotlinNumber")))
@interface STTNumber : NSNumber
- (instancetype)initWithChar:(char)value __attribute__((unavailable));
- (instancetype)initWithUnsignedChar:(unsigned char)value __attribute__((unavailable));
- (instancetype)initWithShort:(short)value __attribute__((unavailable));
- (instancetype)initWithUnsignedShort:(unsigned short)value __attribute__((unavailable));
- (instancetype)initWithInt:(int)value __attribute__((unavailable));
- (instancetype)initWithUnsignedInt:(unsigned int)value __attribute__((unavailable));
- (instancetype)initWithLong:(long)value __attribute__((unavailable));
- (instancetype)initWithUnsignedLong:(unsigned long)value __attribute__((unavailable));
- (instancetype)initWithLongLong:(long long)value __attribute__((unavailable));
- (instancetype)initWithUnsignedLongLong:(unsigned long long)value __attribute__((unavailable));
- (instancetype)initWithFloat:(float)value __attribute__((unavailable));
- (instancetype)initWithDouble:(double)value __attribute__((unavailable));
- (instancetype)initWithBool:(BOOL)value __attribute__((unavailable));
- (instancetype)initWithInteger:(NSInteger)value __attribute__((unavailable));
- (instancetype)initWithUnsignedInteger:(NSUInteger)value __attribute__((unavailable));
+ (instancetype)numberWithChar:(char)value __attribute__((unavailable));
+ (instancetype)numberWithUnsignedChar:(unsigned char)value __attribute__((unavailable));
+ (instancetype)numberWithShort:(short)value __attribute__((unavailable));
+ (instancetype)numberWithUnsignedShort:(unsigned short)value __attribute__((unavailable));
+ (instancetype)numberWithInt:(int)value __attribute__((unavailable));
+ (instancetype)numberWithUnsignedInt:(unsigned int)value __attribute__((unavailable));
+ (instancetype)numberWithLong:(long)value __attribute__((unavailable));
+ (instancetype)numberWithUnsignedLong:(unsigned long)value __attribute__((unavailable));
+ (instancetype)numberWithLongLong:(long long)value __attribute__((unavailable));
+ (instancetype)numberWithUnsignedLongLong:(unsigned long long)value __attribute__((unavailable));
+ (instancetype)numberWithFloat:(float)value __attribute__((unavailable));
+ (instancetype)numberWithDouble:(double)value __attribute__((unavailable));
+ (instancetype)numberWithBool:(BOOL)value __attribute__((unavailable));
+ (instancetype)numberWithInteger:(NSInteger)value __attribute__((unavailable));
+ (instancetype)numberWithUnsignedInteger:(NSUInteger)value __attribute__((unavailable));
@end

__attribute__((swift_name("KotlinByte")))
@interface STTByte : STTNumber
- (instancetype)initWithChar:(char)value;
+ (instancetype)numberWithChar:(char)value;
@end

__attribute__((swift_name("KotlinUByte")))
@interface STTUByte : STTNumber
- (instancetype)initWithUnsignedChar:(unsigned char)value;
+ (instancetype)numberWithUnsignedChar:(unsigned char)value;
@end

__attribute__((swift_name("KotlinShort")))
@interface STTShort : STTNumber
- (instancetype)initWithShort:(short)value;
+ (instancetype)numberWithShort:(short)value;
@end

__attribute__((swift_name("KotlinUShort")))
@interface STTUShort : STTNumber
- (instancetype)initWithUnsignedShort:(unsigned short)value;
+ (instancetype)numberWithUnsignedShort:(unsigned short)value;
@end

__attribute__((swift_name("KotlinInt")))
@interface STTInt : STTNumber
- (instancetype)initWithInt:(int)value;
+ (instancetype)numberWithInt:(int)value;
@end

__attribute__((swift_name("KotlinUInt")))
@interface STTUInt : STTNumber
- (instancetype)initWithUnsignedInt:(unsigned int)value;
+ (instancetype)numberWithUnsignedInt:(unsigned int)value;
@end

__attribute__((swift_name("KotlinLong")))
@interface STTLong : STTNumber
- (instancetype)initWithLongLong:(long long)value;
+ (instancetype)numberWithLongLong:(long long)value;
@end

__attribute__((swift_name("KotlinULong")))
@interface STTULong : STTNumber
- (instancetype)initWithUnsignedLongLong:(unsigned long long)value;
+ (instancetype)numberWithUnsignedLongLong:(unsigned long long)value;
@end

__attribute__((swift_name("KotlinFloat")))
@interface STTFloat : STTNumber
- (instancetype)initWithFloat:(float)value;
+ (instancetype)numberWithFloat:(float)value;
@end

__attribute__((swift_name("KotlinDouble")))
@interface STTDouble : STTNumber
- (instancetype)initWithDouble:(double)value;
+ (instancetype)numberWithDouble:(double)value;
@end

__attribute__((swift_name("KotlinBoolean")))
@interface STTBoolean : STTNumber
- (instancetype)initWithBool:(BOOL)value;
+ (instancetype)numberWithBool:(BOOL)value;
@end


/**
 * @note annotations
 *   kotlinx.serialization.Serializable
*/
__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("TimeInterval")))
@interface STTTimeInterval : STTBase
- (instancetype)initWithTotalNumberOfDays:(int32_t)totalNumberOfDays years:(int32_t)years months:(int32_t)months days:(int32_t)days hours:(int32_t)hours minutes:(int32_t)minutes secondes:(int32_t)secondes __attribute__((swift_name("init(totalNumberOfDays:years:months:days:hours:minutes:secondes:)"))) __attribute__((objc_designated_initializer));
@property (class, readonly, getter=companion) STTTimeIntervalCompanion *companion __attribute__((swift_name("companion")));
- (STTTimeInterval *)doCopyTotalNumberOfDays:(int32_t)totalNumberOfDays years:(int32_t)years months:(int32_t)months days:(int32_t)days hours:(int32_t)hours minutes:(int32_t)minutes secondes:(int32_t)secondes __attribute__((swift_name("doCopy(totalNumberOfDays:years:months:days:hours:minutes:secondes:)")));
- (BOOL)isEqual:(id _Nullable)other __attribute__((swift_name("isEqual(_:)")));
- (NSUInteger)hash __attribute__((swift_name("hash()")));
- (NSString *)description __attribute__((swift_name("description()")));
@property (readonly) int32_t days __attribute__((swift_name("days")));
@property (readonly) int32_t hours __attribute__((swift_name("hours")));
@property (readonly) int32_t minutes __attribute__((swift_name("minutes")));
@property (readonly) int32_t months __attribute__((swift_name("months")));
@property (readonly) int32_t secondes __attribute__((swift_name("secondes")));
@property (readonly) int32_t totalNumberOfDays __attribute__((swift_name("totalNumberOfDays")));
@property (readonly) int32_t years __attribute__((swift_name("years")));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("TimeInterval.Companion")))
@interface STTTimeIntervalCompanion : STTBase
+ (instancetype)alloc __attribute__((unavailable));
+ (instancetype)allocWithZone:(struct _NSZone *)zone __attribute__((unavailable));
+ (instancetype)companion __attribute__((swift_name("init()")));
@property (class, readonly, getter=shared) STTTimeIntervalCompanion *shared __attribute__((swift_name("shared")));
- (id<STTKotlinx_serialization_coreKSerializer>)serializer __attribute__((swift_name("serializer()")));
@end

__attribute__((swift_name("TimeIntervalProvider")))
@protocol STTTimeIntervalProvider
@required
- (int64_t)calculateDaysSinceTempleDestruction __attribute__((swift_name("calculateDaysSinceTempleDestruction()")));

/**
 * Converts the number of days since the destruction of the Second Temple into Hebrew years, months, and days.
 *
 * @return A [TimeInterval] representing the difference in years, months, and days.
 */
- (STTTimeInterval *)calculateTimeIntervalSinceTempleDestruction __attribute__((swift_name("calculateTimeIntervalSinceTempleDestruction()")));
- (STTJewishDate *)getCurrentJewishDate __attribute__((swift_name("getCurrentJewishDate()")));
- (int64_t)getCurrentTimeMillis __attribute__((swift_name("getCurrentTimeMillis()")));
- (STTJewishDate *)getSecondTempleDestructionDate __attribute__((swift_name("getSecondTempleDestructionDate()")));
- (int64_t)getTodayJerusalemSunset __attribute__((swift_name("getTodayJerusalemSunset()")));
- (int64_t)getYesterdayJerusalemSunset __attribute__((swift_name("getYesterdayJerusalemSunset()")));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("TimeIntervalProviderImpl")))
@interface STTTimeIntervalProviderImpl : STTBase <STTTimeIntervalProvider>
- (instancetype)init __attribute__((swift_name("init()"))) __attribute__((objc_designated_initializer));
+ (instancetype)new __attribute__((availability(swift, unavailable, message="use object initializers instead")));
- (STTJewishDate *)getCurrentJewishDate __attribute__((swift_name("getCurrentJewishDate()")));
- (int64_t)getCurrentTimeMillis __attribute__((swift_name("getCurrentTimeMillis()")));
- (STTJewishDate *)getSecondTempleDestructionDate __attribute__((swift_name("getSecondTempleDestructionDate()")));
- (int64_t)getTodayJerusalemSunset __attribute__((swift_name("getTodayJerusalemSunset()")));
- (int64_t)getYesterdayJerusalemSunset __attribute__((swift_name("getYesterdayJerusalemSunset()")));
@end


/**
 * A Java calendar that calculates astronomical times such as [sunrise], [sunset] and twilight times. This class contains a [Calendar][calendar] and can therefore use the standard
 * Calendar functionality to change dates etc. The calculation engine used to calculate the astronomical times can be
 * changed to a different implementation by implementing the abstract [AstronomicalCalculator] and setting it with
 * the [astronomicalCalculator]. A number of different calculation engine
 * implementations are included in the util package.
 * **Note:** There are times when the algorithms can't calculate proper values for sunrise, sunset and twilight. This
 * is usually caused by trying to calculate times for areas either very far North or South, where sunrise / sunset never
 * happen on that date. This is common when calculating twilight with a deep dip below the horizon for locations as far
 * south of the North Pole as London, in the northern hemisphere. The sun never reaches this dip at certain times of the
 * year. When the calculations encounter this condition a null will be returned when a
 * `[Date]` is expected and [Long.MIN_VALUE] when a `long` is expected. The
 * reason that `Exception`s are not thrown in these cases is because the lack of a rise/set or twilight is
 * not an exception, but an expected condition in many parts of the world.
 *
 * Here is a simple example of how to use the API to calculate sunrise.
 * First create the Calendar for the location you would like to calculate sunrise or sunset times for:
 *
 * <pre>
 * String locationName = &quot;Lakewood, NJ&quot;;
 * double latitude = 40.0828; // Lakewood, NJ
 * double longitude = -74.2094; // Lakewood, NJ
 * double elevation = 20; // optional elevation correction in Meters
 * // the String parameter in timeZone has to be a valid timezone listed in
 * // [TimeZone.getAvailableIDs]
 * TimeZone timeZone = TimeZone.getTimeZone(&quot;America/New_York&quot;);
 * GeoLocation location = new GeoLocation(locationName, latitude, longitude, elevation, timeZone);
 * AstronomicalCalendar ac = new AstronomicalCalendar(location);
</pre> *
 *
 * To get the time of sunrise, first set the date you want (if not set, the date will default to today):
 *
 * <pre>
 * ac.calendar.set(Calendar.MONTH, Calendar.FEBRUARY);
 * ac.calendar.set(Calendar.DAY_OF_MONTH, 8);
 * Date sunrise = ac.getSunrise();
</pre> *
 *
 *
 * @author  Eliyahu Hershfeld 2004 - 2023
 */
__attribute__((swift_name("AstronomicalCalendar")))
@interface STTAstronomicalCalendar : STTBase
- (instancetype)initWithGeoLocation:(STTGeoLocation *)geoLocation __attribute__((swift_name("init(geoLocation:)"))) __attribute__((objc_designated_initializer));
@property (class, readonly, getter=companion) STTAstronomicalCalendarCompanion *companion __attribute__((swift_name("companion")));

/**
 * A method that creates a [deep copy](https://en.wikipedia.org/wiki/Object_copy#Deep_copy) of the object.
 *
 * @see Object.clone
 */
- (STTAstronomicalCalendar *)doCopy __attribute__((swift_name("doCopy()")));

/**
 * @see Object.equals
 */
- (BOOL)isEqual:(id _Nullable)other __attribute__((swift_name("isEqual(_:)")));

/**
 * A method that returns a [Date] from the time passed in as a parameter.
 *
 * @param time
 * The time to be set as the time for the `Date`. The time expected is in the format: 18.75
 * for 6:45:00 PM.
 * @param isSunrise true if the time is sunrise and false if it is sunset
 * @return The Date. null if [time] is [Double.NaN]
 *
 * @note This method has protected visibility in Kotlin source and is intended only for use by subclasses.
*/
- (STTKotlinx_datetimeInstant * _Nullable)getDateFromTimeTime:(double)time isSunrise:(BOOL)isSunrise __attribute__((swift_name("getDateFromTime(time:isSunrise:)")));

/**
 * A method that returns sundial or solar noon. It occurs when the Sun is [transiting](https://en.wikipedia.org/wiki/Transit_%28astronomy%29) the [celestial meridian](https://en.wikipedia.org/wiki/Meridian_%28astronomy%29). In this class it is
 * calculated as halfway between the sunrise and sunset passed to this method. This time can be slightly off the
 * real transit time due to changes in declination (the lengthening or shortening day).
 *
 * @param startOfDay
 * the start of day for calculating the sun's transit. This can be sea level sunrise, visual sunrise (or
 * any arbitrary start of day) passed to this method.
 * @param endOfDay
 * the end of day for calculating the sun's transit. This can be sea level sunset, visual sunset (or any
 * arbitrary end of day) passed to this method.
 *
 * @return the `Date` representing Sun's transit. If the calculation can't be computed such as in the
 * Arctic Circle where there is at least one day a year where the sun does not rise, and one where it does
 * not set, null will be returned. See detailed explanation on top of the page.
 */
- (STTKotlinx_datetimeInstant * _Nullable)getSunTransitStartOfDay:(STTKotlinx_datetimeInstant * _Nullable)startOfDay endOfDay:(STTKotlinx_datetimeInstant * _Nullable)endOfDay __attribute__((swift_name("getSunTransit(startOfDay:endOfDay:)")));

/**
 * A utility method that returns the time of an offset by degrees below or above the horizon of
 * [sunrise]. Note that the degree offset is from the vertical, so for a calculation of 14
 * before sunrise, an offset of 14 + [AstronomicalCalendar.GEOMETRIC_ZENITH] = 104 would have to be passed as a parameter.
 *
 * @param offsetZenith
 * the degrees before [sunrise] to use in the calculation. For time after sunrise use
 * negative numbers. Note that the degree offset is from the vertical, so for a calculation of 14
 * before sunrise, an offset of 14 + [AstronomicalCalendar.GEOMETRIC_ZENITH] = 104 would have to be passed as a
 * parameter.
 * @return The [Date] of the offset after (or before) [sunrise]. If the calculation
 * can't be computed such as in the Arctic Circle where there is at least one day a year where the sun does
 * not rise, and one where it does not set, a null will be returned. See detailed explanation on top of the
 * page.
 */
- (STTKotlinx_datetimeInstant * _Nullable)getSunriseOffsetByDegreesOffsetZenith:(double)offsetZenith __attribute__((swift_name("getSunriseOffsetByDegrees(offsetZenith:)")));

/**
 * Returns the dip below the horizon before sunrise that matches the offset minutes on passed in as a parameter. For
 * example passing in 72 minutes for a calendar set to the equinox in Jerusalem returns a value close to 16.1
 * Please note that this method is very slow and inefficient and should NEVER be used in a loop. TODO: Improve
 * efficiency.
 *
 * @param minutes
 * offset
 * @return the degrees below the horizon before sunrise that match the offset in minutes passed it as a parameter.
 * @see getSunsetSolarDipFromOffset
 */
- (double)getSunriseSolarDipFromOffsetMinutes:(double)minutes __attribute__((swift_name("getSunriseSolarDipFromOffset(minutes:)")));

/**
 * A utility method that returns the time of an offset by degrees below or above the horizon of [sunset][sunset]. Note that the degree offset is from the vertical, so for a calculation of 14 after sunset, an
 * offset of 14 + [AstronomicalCalendar.GEOMETRIC_ZENITH] = 104 would have to be passed as a parameter.
 *
 * @param offsetZenith
 * the degrees after [sunset] to use in the calculation. For time before sunset use negative
 * numbers. Note that the degree offset is from the vertical, so for a calculation of 14 after
 * sunset, an offset of 14 + [AstronomicalCalendar.GEOMETRIC_ZENITH] = 104 would have to be passed as a parameter.
 * @return The [Date]of the offset after (or before) [sunset]. If the calculation can't
 * be computed such as in the Arctic Circle where there is at least one day a year where the sun does not
 * rise, and one where it does not set, a null will be returned. See detailed explanation on top of the
 * page.
 */
- (STTKotlinx_datetimeInstant * _Nullable)getSunsetOffsetByDegreesOffsetZenith:(double)offsetZenith __attribute__((swift_name("getSunsetOffsetByDegrees(offsetZenith:)")));

/**
 * Returns the dip below the horizon after sunset that matches the offset minutes on passed in as a parameter. For
 * example passing in 72 minutes for a calendar set to the equinox in Jerusalem returns a value close to 16.1
 * Please note that this method is very slow and inefficient and should NEVER be used in a loop. TODO: Improve
 * efficiency.
 *
 * @param minutes
 * offset
 * @return the degrees below the horizon after sunset that match the offset in minutes passed it as a parameter.
 * @see getSunriseSolarDipFromOffset
 */
- (double)getSunsetSolarDipFromOffsetMinutes:(double)minutes __attribute__((swift_name("getSunsetSolarDipFromOffset(minutes:)")));

/**
 * A utility method that will allow the calculation of a temporal (solar) hour based on the sunrise and sunset
 * passed as parameters to this method. An example of the use of this method would be the calculation of a
 * non-elevation adjusted temporal hour by passing in [sea level sunrise][seaLevelSunrise] and
 * [sea level sunset][seaLevelSunset] as parameters.
 *
 * @param startOfday
 * The start of the day.
 * @param endOfDay
 * The end of the day.
 *
 * @return the `long` millisecond length of the temporal hour. If the calculation can't be computed a
 * [Long.MIN_VALUE] will be returned. See detailed explanation on top of the page.
 *
 * @see temporalHour
 */
- (int64_t)getTemporalHourStartOfday:(STTKotlinx_datetimeInstant * _Nullable)startOfday endOfDay:(STTKotlinx_datetimeInstant * _Nullable)endOfDay __attribute__((swift_name("getTemporalHour(startOfday:endOfDay:)")));

/**
 * A method that returns the sunrise in UTC time without correction for time zone offset from GMT and without using
 * daylight savings time. Non-sunrise and sunset calculations such as dawn and dusk, depend on the amount of visible
 * light, something that is not affected by elevation. This method returns UTC sunrise calculated at sea level. This
 * forms the base for dawn calculations that are calculated as a dip below the horizon before sunrise.
 *
 * @param zenith
 * the degrees below the horizon. For time after sunrise use negative numbers.
 * @return The time in the format: 18.75 for 18:45:00 UTC/GMT. If the calculation can't be computed such as in the
 * Arctic Circle where there is at least one day a year where the sun does not rise, and one where it does
 * not set, [Double.NaN] will be returned. See detailed explanation on top of the page.
 * @see AstronomicalCalendar.getUTCSunrise
 *
 * @see AstronomicalCalendar.getUTCSeaLevelSunset
 */
- (double)getUTCSeaLevelSunriseZenith:(double)zenith __attribute__((swift_name("getUTCSeaLevelSunrise(zenith:)")));

/**
 * A method that returns the sunset in UTC time without correction for elevation, time zone offset from GMT and
 * without using daylight savings time. Non-sunrise and sunset calculations such as dawn and dusk, depend on the
 * amount of visible light, something that is not affected by elevation. This method returns UTC sunset calculated
 * at sea level. This forms the base for dusk calculations that are calculated as a dip below the horizon after
 * sunset.
 *
 * @param zenith
 * the degrees below the horizon. For time before sunset use negative numbers.
 * @return The time in the format: 18.75 for 18:45:00 UTC/GMT. If the calculation can't be computed such as in the
 * Arctic Circle where there is at least one day a year where the sun does not rise, and one where it does
 * not set, [Double.NaN] will be returned. See detailed explanation on top of the page.
 * @see AstronomicalCalendar.getUTCSunset
 *
 * @see AstronomicalCalendar.getUTCSeaLevelSunrise
 */
- (double)getUTCSeaLevelSunsetZenith:(double)zenith __attribute__((swift_name("getUTCSeaLevelSunset(zenith:)")));

/**
 * A method that returns the sunrise in UTC time without correction for time zone offset from GMT and without using
 * daylight savings time.
 *
 * @param zenith
 * the degrees below the horizon. For time after sunrise use negative numbers.
 * @return The time in the format: 18.75 for 18:45:00 UTC/GMT. If the calculation can't be computed such as in the
 * Arctic Circle where there is at least one day a year where the sun does not rise, and one where it does
 * not set, [Double.NaN] will be returned. See detailed explanation on top of the page.
 */
- (double)getUTCSunriseZenith:(double)zenith __attribute__((swift_name("getUTCSunrise(zenith:)")));

/**
 * A method that returns the sunset in UTC time without correction for time zone offset from GMT and without using
 * daylight savings time.
 *
 * @param zenith
 * the degrees below the horizon. For time after sunset use negative numbers.
 * @return The time in the format: 18.75 for 18:45:00 UTC/GMT. If the calculation can't be computed such as in the
 * Arctic Circle where there is at least one day a year where the sun does not rise, and one where it does
 * not set, [Double.NaN] will be returned. See detailed explanation on top of the page.
 * @see AstronomicalCalendar.getUTCSeaLevelSunset
 */
- (double)getUTCSunsetZenith:(double)zenith __attribute__((swift_name("getUTCSunset(zenith:)")));

/**
 * @see Object.hashCode
 */
- (NSUInteger)hash __attribute__((swift_name("hash()")));

/**
 * The internal [AstronomicalCalculator] used for calculating solar based times.
 * A method to set the [AstronomicalCalculator] used for astronomical calculations. The Zmanim package ships
 * with a number of different implementations of the `abstract` [AstronomicalCalculator] based on
 * different algorithms, including the default [com.kosherjava.zmanim.util.NOAACalculator] based on [NOAA's](https://noaa.gov) implementation of Jean Meeus's algorithms as well as [] based on the [US
 * Naval Observatory's](https://www.cnmoc.usff.navy.mil/usno/) algorithm,. This allows easy runtime switching and comparison of different algorithms.
 *
 */
@property STTAstronomicalCalculator *astronomicalCalculator __attribute__((swift_name("astronomicalCalculator")));

/**
 * A method that returns the beginning of [astronomical twilight](https://en.wikipedia.org/wiki/Twilight#Astronomical_twilight) using a zenith of
 * [108˚][.ASTRONOMICAL_ZENITH].
 *
 * @return The `Date` of the beginning of astronomical twilight using a zenith of 108. If the
 * calculation can't be computed, null will be returned. See detailed explanation on top of the page.
 * @see .ASTRONOMICAL_ZENITH
 */
@property (readonly) STTKotlinx_datetimeInstant * _Nullable beginAstronomicalTwilight __attribute__((swift_name("beginAstronomicalTwilight")));

/**
 * A method that returns the beginning of [civil twilight](https://en.wikipedia.org/wiki/Twilight#Civil_twilight)
 * (dawn) using a zenith of [96˚][.CIVIL_ZENITH].
 *
 * @return The `Date` of the beginning of civil twilight using a zenith of 96. If the calculation
 * can't be computed, null will be returned. See detailed explanation on top of the page.
 * @see .CIVIL_ZENITH
 */
@property (readonly) STTKotlinx_datetimeInstant * _Nullable beginCivilTwilight __attribute__((swift_name("beginCivilTwilight")));

/**
 * A method that returns the beginning of [nautical twilight](https://en.wikipedia.org/wiki/Twilight#Nautical_twilight) using a zenith of [NAUTICAL_ZENITH].
 *
 * @return The `Date` of the beginning of nautical twilight using a zenith of 102. If the
 * calculation can't be computed null will be returned. See detailed explanation on top of the page.
 * @see .NAUTICAL_ZENITH
 */
@property (readonly) STTKotlinx_datetimeInstant * _Nullable beginNauticalTwilight __attribute__((swift_name("beginNauticalTwilight")));

/**
 * A method that returns the end of astronomical twilight using a zenith of [108˚][.ASTRONOMICAL_ZENITH].
 *
 * @return the `Date` of the end of astronomical twilight using a zenith of [108˚][ASTRONOMICAL_ZENITH]. If the calculation can't be computed, null will be returned. See detailed explanation on top
 * of the page.
 * @see .ASTRONOMICAL_ZENITH
 */
@property (readonly) STTKotlinx_datetimeInstant * _Nullable endAstronomicalTwilight __attribute__((swift_name("endAstronomicalTwilight")));

/**
 * A method that returns the end of [civil twilight](https://en.wikipedia.org/wiki/Twilight#Civil_twilight)
 * using a zenith of [96˚][.CIVIL_ZENITH].
 *
 * @return The `Date` of the end of civil twilight using a zenith of [96˚][.CIVIL_ZENITH]. If
 * the calculation can't be computed, null will be returned. See detailed explanation on top of the page.
 * @see CIVIL_ZENITH
 */
@property (readonly) STTKotlinx_datetimeInstant * _Nullable endCivilTwilight __attribute__((swift_name("endCivilTwilight")));

/**
 * A method that returns the end of nautical twilight using a zenith of [102˚][.NAUTICAL_ZENITH].
 *
 * @return The `Date` of the end of nautical twilight using a zenith of [102˚][.NAUTICAL_ZENITH]
 * . If the calculation can't be computed, null will be returned. See detailed explanation on top of the
 * page.
 * @see NAUTICAL_ZENITH
 */
@property (readonly) STTKotlinx_datetimeInstant * _Nullable endNauticalTwilight __attribute__((swift_name("endNauticalTwilight")));

/**
 * the [GeoLocation] used for calculations.
 */
@property STTGeoLocation *geoLocation __attribute__((swift_name("geoLocation")));

/**
 * The Java Calendar encapsulated by this class to track the current date used by the class
 */
@property STTKotlinx_datetimeLocalDateTime *localDateTime __attribute__((swift_name("localDateTime")));

/**
 * A method that returns the sunrise without [elevation][AstronomicalCalculator.getElevationAdjustment]. Non-sunrise and sunset calculations such as dawn and dusk, depend on the amount of visible light,
 * something that is not affected by elevation. This method returns sunrise calculated at sea level. This forms the
 * base for dawn calculations that are calculated as a dip below the horizon before sunrise.
 *
 * @return null if [geoLocation] is null or sunrise can't be computer (see [getUTCSunrise]). (TODO null check: is this a good contract?)
 * Otherwise, the `Date` representing the exact sea-level sunrise time. If the calculation can't be computed
 * such as in the Arctic Circle where there is at least one day a year where the sun does not rise, and one
 * where it does not set, a null will be returned. See detailed explanation on top of the page.
 * @see [sunrise]
 *
 * @see [getUTCSeaLevelSunrise]
 *
 * @see .seaLevelSunset
 */
@property (readonly) STTKotlinx_datetimeInstant * _Nullable seaLevelSunrise __attribute__((swift_name("seaLevelSunrise")));

/**
 * A method that returns the sunset without [elevation][AstronomicalCalculator.getElevationAdjustment]. Non-sunrise and sunset calculations such as dawn and dusk, depend on the amount of visible light,
 * something that is not affected by elevation. This method returns sunset calculated at sea level. This forms the
 * base for dusk calculations that are calculated as a dip below the horizon after sunset.
 *
 * @return the `Date` representing the exact sea-level sunset time. If the calculation can't be computed
 * such as in the Arctic Circle where there is at least one day a year where the sun does not rise, and one
 * where it does not set, a null will be returned. See detailed explanation on top of the page.
 * @see AstronomicalCalendar.sunset
 *
 * @see AstronomicalCalendar.getUTCSeaLevelSunset
 * @see sunset
 */
@property (readonly) STTKotlinx_datetimeInstant * _Nullable seaLevelSunset __attribute__((swift_name("seaLevelSunset")));

/**
 * A method that returns sundial or solar noon. It occurs when the Sun is [transiting](https://en.wikipedia.org/wiki/Transit_%28astronomy%29) the [celestial meridian](https://en.wikipedia.org/wiki/Meridian_%28astronomy%29). The calculations used by
 * this class depend on the [AstronomicalCalculator] used. If this calendar instance is [astronomicalCalculator] to use the [com.kosherjava.zmanim.util.NOAACalculator]
 * (the default) it will calculate astronomical noon. If the calendar instance is  to use the
 * [com.kosherjava.zmanim.util.SunTimesCalculator], that does not have code to calculate astronomical noon, the
 * sun transit is calculated as halfway between sea level sunrise and sea level sunset, which can be slightly off the
 * real transit time due to changes in declination (the lengthening or shortening day). See [The Definition of Chatzos](https://kosherjava.com/2020/07/02/definition-of-chatzos/) for details on the proper
 * definition of solar noon / midday.
 *
 * @return The `Date` representing Sun's transit. If the calculation can't be computed such as in the
 * Arctic Circle where there is at least one day a year where the sun does not rise, and one where it does
 * not set, null will be returned. See detailed explanation on top of the page.
 * @see sunTransit
 * @see temporalHour
 */
@property (readonly) STTKotlinx_datetimeInstant * _Nullable sunTransit __attribute__((swift_name("sunTransit")));

/**
 * The [sunrise] method returns an [Instant] representing the
 * [elevation adjusted][AstronomicalCalculator.getElevationAdjustment] sunrise time. The zenith used
 * for the calculation uses [geometric zenith][AstronomicalCalendar.GEOMETRIC_ZENITH] of 90 plus
 * [AstronomicalCalculator.getElevationAdjustment]. This is adjusted by the
 * [AstronomicalCalculator] to add approximately 50/60 of a degree to account for 34 archminutes of refraction
 * and 16 archminutes for the sun's radius for a total of [90.83333˚][AstronomicalCalculator.adjustZenith].
 * See documentation for the specific implementation of the [AstronomicalCalculator] that you are using.
 *
 * @return null if sunrise can't be computed (see [getUTCSunrise]).
 * Otherwise, the [Instant] representing the exact sunrise time. If the calculation can't be computed such as
 * in the Arctic Circle where there is at least one day a year where the sun does not rise, and one where it
 * does not set, a null will be returned. See detailed explanation on top of the page.
 * @see AstronomicalCalculator.adjustZenith
 *
 * @see [seaLevelSunrise]
 * @see AstronomicalCalendar.getUTCSunrise
 */
@property (readonly) STTKotlinx_datetimeInstant * _Nullable sunrise __attribute__((swift_name("sunrise")));

/**
 * The getSunset method Returns a `Date` representing the
 * [elevation adjusted][AstronomicalCalculator.getElevationAdjustment] sunset time. The zenith used for
 * the calculation uses [geometric zenith][AstronomicalCalendar.GEOMETRIC_ZENITH] of 90 plus
 * [AstronomicalCalculator.getElevationAdjustment]. This is adjusted by the
 * [AstronomicalCalculator] to add approximately 50/60 of a degree to account for 34 archminutes of refraction
 * and 16 archminutes for the sun's radius for a total of [90.83333˚][AstronomicalCalculator.adjustZenith].
 * See documentation for the specific implementation of the [AstronomicalCalculator] that you are using. Note:
 * In certain cases the calculates sunset will occur before sunrise. This will typically happen when a timezone
 * other than the local timezone is used (calculating Los Angeles sunset using a GMT timezone for example). In this
 * case the sunset date will be incremented to the following date.
 *
 * @return the `Date` representing the exact sunset time. If the calculation can't be computed such as in
 * the Arctic Circle where there is at least one day a year where the sun does not rise, and one where it
 * does not set, a null will be returned. See detailed explanation on top of the page.
 * @see AstronomicalCalculator.adjustZenith
 *
 * @see [seaLevelSunset]
 * @see AstronomicalCalendar.getUTCSunset
 */
@property (readonly) STTKotlinx_datetimeInstant * _Nullable sunset __attribute__((swift_name("sunset")));

/**
 * A method that returns an [elevation adjusted][AstronomicalCalculator.getElevationAdjustment]
 * temporal (solar) hour. The day from [sunrise] to [sunset] is split into 12
 * equal parts with each one being a temporal hour.
 *
 * @see sunrise
 * @see sunset
 * @see getTemporalHour
 * @return the `long` millisecond length of a temporal hour. If the calculation can't be computed,
 * [Long.MIN_VALUE] will be returned. See detailed explanation on top of the page.
 *
 * @see getTemporalHour
 */
@property (readonly) int64_t temporalHour __attribute__((swift_name("temporalHour")));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("AstronomicalCalendar.Companion")))
@interface STTAstronomicalCalendarCompanion : STTBase
+ (instancetype)alloc __attribute__((unavailable));
+ (instancetype)allocWithZone:(struct _NSZone *)zone __attribute__((unavailable));
+ (instancetype)companion __attribute__((swift_name("init()")));
@property (class, readonly, getter=shared) STTAstronomicalCalendarCompanion *shared __attribute__((swift_name("shared")));

/**
 * A utility method that returns a date offset by the offset time passed in as a parameter. This method casts the
 * offset as a `long` and calls [getTimeOffset].
 *
 * @param time
 * the start time
 * @param offset
 * the offset in milliseconds to add to the time
 * @return the [Date]with the offset added to it
 */
- (STTKotlinx_datetimeInstant * _Nullable)getTimeOffsetTime:(STTKotlinx_datetimeInstant * _Nullable)time offset:(double)offset __attribute__((swift_name("getTimeOffset(time:offset:)")));

/**
 * A utility method that returns a date offset by the offset time passed in. Please note that the level of light
 * during twilight is not affected by elevation, so if this is being used to calculate an offset before sunrise or
 * after sunset with the intent of getting a rough "level of light" calculation, the sunrise or sunset time passed
 * to this method should be sea level sunrise and sunset.
 *
 * @param time
 * the start time
 * @param offset
 * the offset in milliseconds to add to the time.
 * @return the [Date] with the offset in milliseconds added to it, or null if [time] is null or [offset] is [Long.MIN_VALUE]
 */
- (STTKotlinx_datetimeInstant * _Nullable)getTimeOffsetTime:(STTKotlinx_datetimeInstant * _Nullable)time offset_:(int64_t)offset __attribute__((swift_name("getTimeOffset(time:offset_:)")));

/** Sun's zenith at astronomical twilight (108).  */
@property (readonly) double ASTRONOMICAL_ZENITH __attribute__((swift_name("ASTRONOMICAL_ZENITH")));

/** Sun's zenith at civil twilight (96).  */
@property (readonly) double CIVIL_ZENITH __attribute__((swift_name("CIVIL_ZENITH")));

/**
 * 90 below the vertical. Used as a basis for most calculations since the location of the sun is 90 below
 * the horizon at sunrise and sunset.
 * **Note **: it is important to note that for sunrise and sunset the [adjusted zenith][AstronomicalCalculator.adjustZenith] is required to account for the radius of the sun and refraction. The adjusted zenith should not
 * be used for calculations above or below 90 since they are usually calculated as an offset to 90.
 */
@property (readonly) double GEOMETRIC_ZENITH __attribute__((swift_name("GEOMETRIC_ZENITH")));

/** constant for milliseconds in an hour (3,600,000)  */
@property (readonly) int64_t HOUR_MILLIS __attribute__((swift_name("HOUR_MILLIS")));

/** constant for milliseconds in a minute (60,000)  */
@property (readonly) int64_t MINUTE_MILLIS __attribute__((swift_name("MINUTE_MILLIS")));

/** Sun's zenith at nautical twilight (102).  */
@property (readonly) double NAUTICAL_ZENITH __attribute__((swift_name("NAUTICAL_ZENITH")));
@end


/**
 * The ZmanimCalendar is a specialized calendar that can calculate sunrise, sunset and Jewish *zmanim*
 * (religious times) for prayers and other Jewish religious duties. This class contains the main functionality of the
 * *Zmanim* library. For a much more extensive list of *zmanim*, use the [ComplexZmanimCalendar] that
 * extends this class. See documentation for the [ComplexZmanimCalendar] and [AstronomicalCalendar] for
 * simple examples on using the API.
 * **Elevation based *zmanim* (even sunrise and sunset) should not be used *lekula* without the guidance
 * of a *posek***. According to Rabbi Dovid Yehudah Bursztyn in his
 * [Zmanim Kehilchasam, 7th edition](https://www.worldcat.org/oclc/1158574217) chapter 2, section 7 (pages 181-182)
 * and section 9 (pages 186-187), no *zmanim* besides sunrise and sunset should use elevation. However, Rabbi Yechiel
 * Avrahom Zilber in the [Birur Halacha Vol. 6](https://hebrewbooks.org/51654) Ch. 58 Pages
 * [&amp;34](https://hebrewbooks.org/pdfpager.aspx?req=51654&amp;pgnum=42) and
 * [&amp;42](https://hebrewbooks.org/pdfpager.aspx?req=51654&amp;pgnum=50) is of the opinion that elevation should be
 * accounted for in *zmanim* calculations. Related to this, Rabbi Yaakov Karp in [Shimush Zekeinim](https://www.worldcat.org/oclc/919472094), Ch. 1, page 17 states that obstructing horizons should
 * be factored into *zmanim* calculations. The setting defaults to false (elevation will not be used for
 * *zmanim* calculations besides sunrise and sunset), unless the setting is changed to true in [isUseElevation]. This will impact sunrise and sunset-based *zmanim* such as [sunrise],
 * [sunset], [sofZmanShmaGRA], *alos*-based *zmanim* such as [sofZmanShmaMGA]
 * that are based on a fixed offset of sunrise or sunset and *zmanim* based on a percentage of the day such as
 * [ComplexZmanimCalendar.sofZmanShmaMGA90MinutesZmanis] that are based on sunrise and sunset. Even when set to
 * true it will not impact *zmanim* that are a degree-based offset of sunrise and sunset, such as [][ComplexZmanimCalendar.sofZmanShmaMGA16Point1Degrees] or [ComplexZmanimCalendar.getSofZmanShmaBaalHatanya] since
 * these *zmanim* are not linked to sunrise or sunset times (the calculations are based on the astronomical definition of
 * sunrise and sunset calculated in a vacuum with the solar radius above the horizon), and are therefore not impacted by the use
 * of elevation.
 * For additional information on the *halachic* impact of elevation on *zmanim* see:
 *
 *  * [Zmanei Halacha Lema'aseh](https://www.nli.org.il/en/books/NNL_ALEPH002542826/NLI) 4th edition by [Rabbi Yedidya Manat](http://beinenu.com/rabbis/%D7%94%D7%A8%D7%91-%D7%99%D7%93%D7%99%D7%93%D7%99%D7%94-%D7%9E%D7%A0%D7%AA).
 * See section 1, pages 11-12 for a very concise write-up, with details in section 2, pages 37 - 63 and 133 - 151.
 *  * [Zmanim Kehilchasam](https://www.worldcat.org/oclc/1158574217) 7th edition, by Rabbi Dovid Yehuda Burstein,  vol 1,
 * chapter 2, pages 95 - 188.
 *  * [Hazmanim Bahalacha](https://www.worldcat.org/oclc/36089452) by Rabbi Chaim Banish , perek 7, pages 53 - 63.
 *
 *
 *
 * **Note:** It is important to read the technical notes on top of the [AstronomicalCalendar] documentation
 * before using this code.
 *
 * I would like to thank [Rabbi Yaakov Shakow](https://www.worldcat.org/search?q=au%3AShakow%2C+Yaakov), the
 * author of Luach Ikvei Hayom who spent a considerable amount of time reviewing, correcting and making suggestions on the
 * documentation in this library.
 * <h2>Disclaimer:</h2> I did my best to get accurate results, but please double-check before relying on these
 * *zmanim* for *halacha lema'aseh*.
 *
 * **Glossary**
 * *Alos* - Dawn. The time when the sun is 16.1&deg; below the eastern geometric horizon before sunrise.
 * Sunrise - Netz/Haneitz
 * Sunset - Shkiah
 * Dusk/Nightfall:  This is the same as *Tzais*.
 * Candle lighting - The time when Shabbos candles are lit. This is usually 18 minutes before sunset.
 * *Chatzos* - Midday/Midnight. The time when the sun is at its highest point in the sky. This is usually 6 hours after *Alos*.
 *
 *
 * @author  Eliyahu Hershfeld 2004 - 2022
 */
__attribute__((swift_name("ZmanimCalendar")))
@interface STTZmanimCalendar : STTAstronomicalCalendar
- (instancetype)initWithGeoLocation:(STTGeoLocation *)geoLocation isUseElevation:(BOOL)isUseElevation candleLightingOffset:(double)candleLightingOffset __attribute__((swift_name("init(geoLocation:isUseElevation:candleLightingOffset:)"))) __attribute__((objc_designated_initializer));
- (instancetype)initWithGeoLocation:(STTGeoLocation *)geoLocation __attribute__((swift_name("init(geoLocation:)"))) __attribute__((objc_designated_initializer)) __attribute__((unavailable));
@property (class, readonly, getter=companion) STTZmanimCalendarCompanion *companion __attribute__((swift_name("companion")));

/**
 * A generic method for calculating the latest *mincha gedola* (the earliest time to recite the mincha  prayers)
 * that is 6.5 * *shaos zmaniyos* (temporal hours) after the start of the day, calculated using the start and end
 * of the day passed to this method.
 * The time from the start of day to the end of day are divided into 12 *shaos zmaniyos* (temporal hours), and
 * *mincha gedola* is calculated as 6.5 of those *shaos zmaniyos* after the beginning of the day. As an
 * example, passing [sunrise] and [sunset][sunset] or [sea level][seaLevelSunrise] and [sea level sunset][seaLevelSunset] (depending on the [isUseElevation] elevation
 * setting) to this method will return *mincha gedola* according to the opinion of the
 * *[GRA](https://en.wikipedia.org/wiki/Vilna_Gaon)*.
 *
 * @param startOfDay
 * the start of day for calculating *Mincha gedola*. This can be sunrise or any *alos* passed
 * to this method.
 * @param endOfDay
 * the end of day for calculating *Mincha gedola*. This can be sunset or any *tzais* passed
 * to this method.
 * @return the `Date` of the time of *Mincha gedola* based on the start and end of day times
 * passed to this method. If the calculation can't be computed such as in the Arctic Circle where there is
 * at least one day a year where the sun does not rise, and one where it does not set, a null will be
 * returned. See detailed explanation on top of the [AstronomicalCalendar] documentation.
 */
- (STTKotlinx_datetimeInstant * _Nullable)getMinchaGedolaStartOfDay:(STTKotlinx_datetimeInstant * _Nullable)startOfDay endOfDay:(STTKotlinx_datetimeInstant * _Nullable)endOfDay __attribute__((swift_name("getMinchaGedola(startOfDay:endOfDay:)")));

/**
 * A generic method for calculating *mincha ketana*, (the preferred time to recite the mincha prayers in
 * the opinion of the *[Rambam](https://en.wikipedia.org/wiki/Maimonides)* and others) that is
 * 9.5 * *shaos zmaniyos* (temporal hours) after the start of the day, calculated using the start and end
 * of the day passed to this method.
 * The time from the start of day to the end of day are divided into 12 *shaos zmaniyos* (temporal hours), and
 * *mincha ketana* is calculated as 9.5 of those *shaos zmaniyos* after the beginning of the day. As an
 * example, passing [sunrise] and [sunset][sunset] or [sea][seaLevelSunrise] and [sea level sunset][seaLevelSunset] (depending on the [isUseElevation]
 * elevation setting) to this method will return *mincha ketana* according to the opinion of the
 * [GRA](https://en.wikipedia.org/wiki/Vilna_Gaon).
 *
 * @param startOfDay
 * the start of day for calculating *Mincha ketana*. This can be sunrise or any *alos* passed
 * to this method.
 * @param endOfDay
 * the end of day for calculating *Mincha ketana*. This can be sunset or any *tzais* passed to
 * this method.
 * @return the `Date` of the time of *Mincha ketana* based on the start and end of day times
 * passed to this method. If the calculation can't be computed such as in the Arctic Circle where there is
 * at least one day a year where the sun does not rise, and one where it does not set, a null will be
 * returned. See detailed explanation on top of the [AstronomicalCalendar] documentation.
 */
- (STTKotlinx_datetimeInstant * _Nullable)getMinchaKetanaStartOfDay:(STTKotlinx_datetimeInstant * _Nullable)startOfDay endOfDay:(STTKotlinx_datetimeInstant * _Nullable)endOfDay __attribute__((swift_name("getMinchaKetana(startOfDay:endOfDay:)")));

/**
 * A generic method for calculating *plag hamincha* (the earliest time that Shabbos can be started) that is
 * 10.75 hours after the start of the day, (or 1.25 hours before the end of the day) based on the start and end of
 * the day passed to the method.
 * The time from the start of day to the end of day are divided into 12 *shaos zmaniyos* (temporal hours), and
 * *plag hamincha* is calculated as 10.75 of those *shaos zmaniyos* after the beginning of the day. As an
 * example, passing [sunrise] and [sunset][sunset] or [sea level][seaLevelSunrise] and [sea level sunset][seaLevelSunset] (depending on the [isUseElevation] elevation
 * setting) to this method will return *plag mincha* according to the opinion of the
 * *[GRA](https://en.wikipedia.org/wiki/Vilna_Gaon)*.
 *
 * @param startOfDay
 * the start of day for calculating plag. This can be sunrise or any *alos* passed to this method.
 * @param endOfDay
 * the end of day for calculating plag. This can be sunset or any *tzais* passed to this method.
 * @return the `Date` of the time of *plag hamincha* based on the start and end of day times
 * passed to this method. If the calculation can't be computed such as in the Arctic Circle where there is
 * at least one day a year where the sun does not rise, and one where it does not set, a null will be
 * returned. See detailed explanation on top of the [AstronomicalCalendar] documentation.
 */
- (STTKotlinx_datetimeInstant * _Nullable)getPlagHaminchaStartOfDay:(STTKotlinx_datetimeInstant * _Nullable)startOfDay endOfDay:(STTKotlinx_datetimeInstant * _Nullable)endOfDay __attribute__((swift_name("getPlagHamincha(startOfDay:endOfDay:)")));

/**
 * A generic method for calculating *samuch lemincha ketana*, / near *mincha ketana* time that is half
 * an hour before [.getMinchaKetana]  or 9 * *shaos zmaniyos* (temporal hours) after the
 * start of the day, calculated using the start and end of the day passed to this method.
 * The time from the start of day to the end of day are divided into 12 *shaos zmaniyos* (temporal hours), and
 * *samuch lemincha ketana* is calculated as 9 of those *shaos zmaniyos* after the beginning of the day.
 * For example, passing [sunrise] and [sunset][sunset] or [sea][seaLevelSunrise] and [sea level sunset][seaLevelSunset] (depending on the [isUseElevation] elevation
 * setting) to this method will return *samuch lemincha ketana* according to the opinion of the
 * [GRA](https://en.wikipedia.org/wiki/Vilna_Gaon).
 *
 * @param startOfDay
 * the start of day for calculating *samuch lemincha ketana*. This can be sunrise or any *alos*
 * passed to to this method.
 * @param endOfDay
 * the end of day for calculating *samuch lemincha ketana*. This can be sunset or any *tzais*
 * passed to this method.
 * @return the `Date` of the time of *Mincha ketana* based on the start and end of day times
 * passed to this method. If the calculation can't be computed such as in the Arctic Circle where there is
 * at least one day a year where the sun does not rise, and one where it does not set, a null will be
 * returned. See detailed explanation on top of the [AstronomicalCalendar] documentation.
 *
 * @see ComplexZmanimCalendar.getSamuchLeMinchaKetanaGRA
 * @see ComplexZmanimCalendar.getSamuchLeMinchaKetana16Point1Degrees
 * @see ComplexZmanimCalendar.getSamuchLeMinchaKetana72Minutes
 */
- (STTKotlinx_datetimeInstant * _Nullable)getSamuchLeMinchaKetanaStartOfDay:(STTKotlinx_datetimeInstant * _Nullable)startOfDay endOfDay:(STTKotlinx_datetimeInstant * _Nullable)endOfDay __attribute__((swift_name("getSamuchLeMinchaKetana(startOfDay:endOfDay:)")));

/**
 * A generic utility method for calculating any *shaah zmanis* (temporal hour) based *zman* with the
 * day defined as the start and end of day (or night) and the number of *shaahos zmaniyos* passed to the
 * method. This simplifies the code in other methods such as [.getPlagHamincha] and cuts down on
 * code replication. As an example, passing [sunrise] and [sunset][sunset] or [][seaLevelSunrise] and [sea level sunset][seaLevelSunset] (depending on the
 * [isUseElevation] elevation setting) and 10.75 hours to this method will return *plag mincha*
 * according to the opinion of the *[GRA](https://en.wikipedia.org/wiki/Vilna_Gaon)*.
 *
 * @param startOfDay
 * the start of day for calculating the *zman*. This can be sunrise or any *alos* passed
 * to this method.
 * @param endOfDay
 * the end of day for calculating the *zman*. This can be sunset or any *tzais* passed to
 * this method.
 * @param hours
 * the number of *shaahos zmaniyos* (temporal hours) to offset from the start of day
 * @return the `Date` of the time of *zman* with the *shaahos zmaniyos* (temporal hours)
 * in the day offset from the start of day passed to this method. If the calculation can't be computed such
 * as in the Arctic Circle where there is at least one day a year where the sun does not rise, and one
 * where it does not set, a null will be  returned. See detailed explanation on top of the [] documentation.
 */
- (STTKotlinx_datetimeInstant * _Nullable)getShaahZmanisBasedZmanStartOfDay:(STTKotlinx_datetimeInstant * _Nullable)startOfDay endOfDay:(STTKotlinx_datetimeInstant * _Nullable)endOfDay hours:(double)hours __attribute__((swift_name("getShaahZmanisBasedZman(startOfDay:endOfDay:hours:)")));

/**
 * A generic method for calculating the latest *zman krias shema* (time to recite shema in the morning)
 * that is 3 * *shaos zmaniyos* (temporal hours) after the start of the day, calculated using the start and
 * end of the day passed to this method.
 * The time from the start of day to the end of day are divided into 12 *shaos zmaniyos* (temporal hours),
 * and the latest *zman krias shema* is calculated as 3 of those *shaos zmaniyos* after the beginning of
 * the day. As an example, passing [sunrise] and [sunset][sunset] or [sea level sunrise][seaLevelSunrise] and [sea level sunset][seaLevelSunset] (depending on the [isUseElevation]
 * elevation setting) to this method will return *sof zman krias shema* according to the opinion of the
 * *[GRA](https://en.wikipedia.org/wiki/Vilna_Gaon)*.
 *
 * @param startOfDay
 * the start of day for calculating *zman krias shema*. This can be sunrise or any *alos* passed
 * to this method.
 * @param endOfDay
 * the end of day for calculating *zman krias shema*. This can be sunset or any *tzais* passed to
 * this method.
 * @return the `Date` of the latest *zman shema* based on the start and end of day times passed to this
 * method. If the calculation can't be computed such as in the Arctic Circle where there is at least one day
 * a year where the sun does not rise, and one where it does not set, a null will be returned. See detailed
 * explanation on top of the [AstronomicalCalendar] documentation.
 */
- (STTKotlinx_datetimeInstant * _Nullable)getSofZmanShmaStartOfDay:(STTKotlinx_datetimeInstant * _Nullable)startOfDay endOfDay:(STTKotlinx_datetimeInstant * _Nullable)endOfDay __attribute__((swift_name("getSofZmanShma(startOfDay:endOfDay:)")));

/**
 * A generic method for calculating the latest *zman tfilah* (time to recite the morning prayers)
 * that is 4 * *shaos zmaniyos* (temporal hours) after the start of the day, calculated using the start and
 * end of the day passed to this method.
 * The time from the start of day to the end of day are divided into 12 *shaos zmaniyos* (temporal hours),
 * and *sof zman tfila* is calculated as 4 of those *shaos zmaniyos* after the beginning of the day.
 * As an example, passing [sunrise] and [sunset][sunset] or [sea level sunrise][seaLevelSunrise] and [sea level sunset][seaLevelSunset] (depending on the [isUseElevation]
 * elevation setting) to this method will return *zman tfilah* according to the opinion of the *[GRA](https://en.wikipedia.org/wiki/Vilna_Gaon)*.
 *
 * @param startOfDay
 * the start of day for calculating *zman tfilah*. This can be sunrise or any *alos* passed
 * to this method.
 * @param endOfDay
 * the end of day for calculating *zman tfilah*. This can be sunset or any *tzais* passed
 * to this method.
 * @return the `Date` of the latest *zman tfilah* based on the start and end of day times passed
 * to this method. If the calculation can't be computed such as in the Arctic Circle where there is at least
 * one day a year where the sun does not rise, and one where it does not set, a null will be returned. See
 * detailed explanation on top of the [AstronomicalCalendar] documentation.
 */
- (STTKotlinx_datetimeInstant * _Nullable)getSofZmanTfilaStartOfDay:(STTKotlinx_datetimeInstant * _Nullable)startOfDay endOfDay:(STTKotlinx_datetimeInstant * _Nullable)endOfDay __attribute__((swift_name("getSofZmanTfila(startOfDay:endOfDay:)")));

/**
 * This is a utility method to determine if the current Date (date-time) passed in has a *melacha* (work) prohibition.
 * Since there are many opinions on the time of *tzais*, the *tzais* for the current day has to be passed to this
 * class. Sunset is the classes current day's [elevation adjusted sunset][.getElevationAdjustedSunset] that observes the
 * [isUseElevation] settings. The [JewishCalendar.getInIsrael] will be set by the inIsrael parameter.
 *
 * @param currentTime the current time
 * @param tzais the time of tzais
 * @param inIsrael whether to use Israel holiday scheme or not
 *
 * @return true if *melacha* is prohibited or false if it is not.
 *
 * @see JewishCalendar.isAssurBemelacha
 * @see JewishCalendar.hasCandleLighting
 * @see JewishCalendar.setInIsrael
 */
- (BOOL)isAssurBemlachaCurrentTime:(STTKotlinx_datetimeInstant *)currentTime tzais:(STTKotlinx_datetimeInstant *)tzais inIsrael:(BOOL)inIsrael __attribute__((swift_name("isAssurBemlacha(currentTime:tzais:inIsrael:)")));
@property (readonly) NSArray<STTZmanValueBased *> *allShaosZmaniyos __attribute__((swift_name("allShaosZmaniyos")));
@property (readonly) NSArray<STTZmanDateBased *> *allZmanim __attribute__((swift_name("allZmanim")));

/**
 * Method to return *alos* (dawn) calculated using 72 minutes before [sunrise] or
 * [sea level sunrise][seaLevelSunrise] (depending on the [isUseElevation] setting). This time
 * is based on the time to walk the distance of 4 *Mil* at 18 minutes a *Mil*. The 72 minute time (but
 * not the concept of fixed minutes) is based on the opinion that the time of the *Neshef* (twilight between
 * dawn and sunrise) does not vary by the time of year or location but depends on the time it takes to walk the
 * distance of 4 *Mil*.
 *
 * @return the `Date` representing the time. If the calculation can't be computed such as in the Arctic
 * Circle where there is at least one day a year where the sun does not rise, and one where it does not set,
 * a null will be returned. See detailed explanation on top of the [AstronomicalCalendar]
 * documentation.
 */
@property (readonly) STTZmanDateBased *alos72 __attribute__((swift_name("alos72")));

/**
 * Returns *alos* (dawn) based on the time when the sun is [16.1˚][ZENITH_16_POINT_1] below the
 * eastern [geometric horizon][AstronomicalCalendar.GEOMETRIC_ZENITH] before [sunrise]. This is based on the
 * calculation that the time between dawn and sunrise (and sunset to nightfall) is 72 minutes, the time that is
 * takes to walk 4 *mil* at 18 minutes a mil (*[Rambam](https://en.wikipedia.org/wiki/Maimonides)* and others). The sun's position at 72 minutes before [sunrise] in Jerusalem
 * on the [around the equinox /
 * equilux](https://kosherjava.com/2022/01/12/equinox-vs-equilux-zmanim-calculations/) is 16.1 below [AstronomicalCalendar.GEOMETRIC_ZENITH].
 *
 * @see ZENITH_16_POINT_1
 *
 * @see ComplexZmanimCalendar.getAlos16Point1Degrees
 * @return The `Date` of dawn. If the calculation can't be computed such as northern and southern
 * locations even south of the Arctic Circle and north of the Antarctic Circle where the sun may not reach
 * low enough below the horizon for this calculation, a null will be returned. See detailed explanation on
 * top of the [AstronomicalCalendar] documentation.
 */
@property (readonly) STTZmanDateBased *alosHashachar __attribute__((swift_name("alosHashachar")));

/**
 * A method to return candle lighting time, calculated as [.getCandleLightingOffset] minutes before
 * [sea level sunset][seaLevelSunset]. This will return the time for any day of the week, since it can be
 * used to calculate candle lighting time for *Yom Tov* (mid-week holidays) as well. Elevation adjustments
 * are intentionally not performed by this method, but you can calculate it by passing the elevation adjusted sunset
 * to [.getTimeOffset].
 *
 * @return candle lighting time. If the calculation can't be computed such as in the Arctic Circle where there is at
 * least one day a year where the sun does not rise, and one where it does not set, a null will be returned.
 * See detailed explanation on top of the [AstronomicalCalendar] documentation.
 *
 * @see .seaLevelSunset
 * @see .getCandleLightingOffset
 * @see .setCandleLightingOffset
 */
@property (readonly) STTZmanDateBased *candleLighting __attribute__((swift_name("candleLighting")));

/**
 * The default *Shabbos* candle lighting offset is 18 minutes. This can be changed via the
 * [candleLightingOffset] and retrieved by the [candleLightingOffset].
 */
@property double candleLightingOffset __attribute__((swift_name("candleLightingOffset")));

/**
 * This method returns *chatzos* (midday) following most opinions that *chatzos* is the midpoint
 * between [sea level sunrise][seaLevelSunrise] and [sea level sunset][seaLevelSunset]. A day
 * starting at *alos* and ending at *tzais* using the same time or degree offset will also return
 * the same time. The returned value is identical to [sunTransit]. In reality due to lengthening or
 * shortening of day, this is not necessarily the exact midpoint of the day, but it is very close.
 *
 * @see AstronomicalCalendar.getSunTransit
 * @return the `Date` of chatzos. If the calculation can't be computed such as in the Arctic Circle
 * where there is at least one day where the sun does not rise, and one where it does not set, a null will
 * be returned. See detailed explanation on top of the [AstronomicalCalendar] documentation.
 */
@property (readonly) STTZmanDateBased *chatzos __attribute__((swift_name("chatzos")));

/**
 * This method will return [sea level sunrise][seaLevelSunrise] if [isUseElevation] is false (the
 * default), or elevation adjusted [AstronomicalCalendar.getSunrise] if it is true. This allows relevant *zmanim*
 * in this and extending classes (such as the [ComplexZmanimCalendar]) to automatically adjust to the elevation setting.
 *
 * @return [seaLevelSunrise] if [isUseElevation] is false (the default), or elevation adjusted
 * [AstronomicalCalendar.getSunrise] if it is true.
 * @see com.kosherjava.zmanim.AstronomicalCalendar.getSunrise
 *
 * @note This property has protected visibility in Kotlin source and is intended only for use by subclasses.
*/
@property (readonly) STTKotlinx_datetimeInstant * _Nullable elevationAdjustedSunrise __attribute__((swift_name("elevationAdjustedSunrise")));

/**
 * This method will return [sea level sunrise][seaLevelSunrise] if [isUseElevation] is false (the default),
 * or elevation adjusted [AstronomicalCalendar.getSunrise] if it is true. This allows relevant *zmanim*
 * in this and extending classes (such as the [ComplexZmanimCalendar]) to automatically adjust to the elevation setting.
 *
 * @return [seaLevelSunset] if [isUseElevation] is false (the default), or elevation adjusted
 * [AstronomicalCalendar.getSunset] if it is true.
 * @see com.kosherjava.zmanim.AstronomicalCalendar.getSunset
 *
 * @note This property has protected visibility in Kotlin source and is intended only for use by subclasses.
*/
@property (readonly) STTKotlinx_datetimeInstant * _Nullable elevationAdjustedSunset __attribute__((swift_name("elevationAdjustedSunset")));

/**
 * Is elevation factored in for some zmanim (see [isUseElevation] for additional information).
 * @see isUseElevation
 */
@property BOOL isUseElevation __attribute__((swift_name("isUseElevation")));

/**
 * This method returns the latest *mincha gedola*,the earliest time one can pray *mincha* that is 6.5 *
 * [*shaos zmaniyos*][shaahZmanisGra] (solar hours) after [sunrise] or
 * [sea level sunrise][seaLevelSunrise] (depending on the [isUseElevation] setting), according
 * to the *[GRA](https://en.wikipedia.org/wiki/Vilna_Gaon)*. *Mincha gedola* is the earliest
 * time one can pray *mincha*. The Ramba"m is of the opinion that it is better to delay *mincha* until
 * [*mincha ketana*][.getMinchaKetana] while the *Ra"sh, Tur, GRA* and others are of the
 * opinion that *mincha* can be prayed *lechatchila* starting at *mincha gedola*.
 * The day is calculated from [sea level sunrise][seaLevelSunrise] to [sea level][seaLevelSunrise] or [sunrise] to [sunset][sunset] (depending on the [isUseElevation]
 * setting).
 *
 * @see .getMinchaGedola
 * @see shaahZmanisGra
 * @see .getMinchaKetana
 * @see ComplexZmanimCalendar.getMinchaGedolaBaalHatanya
 * @return the `Date` of the time of mincha gedola. If the calculation can't be computed such as in the
 * Arctic Circle where there is at least one day a year where the sun does not rise, and one where it does
 * not set, a null will be returned. See detailed explanation on top of the [AstronomicalCalendar]
 * documentation.
 */
@property (readonly) STTZmanDateBased *minchaGedola __attribute__((swift_name("minchaGedola")));

/**
 * This method returns *mincha ketana*,the preferred earliest time to pray *mincha* in the
 * opinion of the *[Rambam](https://en.wikipedia.org/wiki/Maimonides)* and others, that is 9.5
 * * [*shaos zmaniyos*][shaahZmanisGra] (solar hours) after [sunrise] or
 * [sea level sunrise][seaLevelSunrise] (depending on the [isUseElevation] setting), according
 * to the [GRA](https://en.wikipedia.org/wiki/Vilna_Gaon). For more information on this see the
 * documentation on [*mincha gedola*][.getMinchaGedola].
 * The day is calculated from [sea level sunrise][seaLevelSunrise] to [sea level][seaLevelSunrise] or [sunrise] to [sunset][sunset] (depending on the [isUseElevation]
 * setting.
 *
 * @see .getMinchaKetana
 * @see shaahZmanisGra
 * @see .getMinchaGedola
 * @see ComplexZmanimCalendar.getMinchaKetanaBaalHatanya
 * @return the `Date` of the time of mincha ketana. If the calculation can't be computed such as in the
 * Arctic Circle where there is at least one day a year where the sun does not rise, and one where it does
 * not set, a null will be returned. See detailed explanation on top of the [AstronomicalCalendar]
 * documentation.
 */
@property (readonly) STTZmanDateBased *minchaKetana __attribute__((swift_name("minchaKetana")));

/**
 * This method returns *plag hamincha*, that is 10.75 * [*shaos zmaniyos*][shaahZmanisGra]
 * (solar hours) after [sunrise] or [sea level sunrise][seaLevelSunrise] (depending on
 * the [isUseElevation] setting), according to the *[GRA](https://en.wikipedia.org/wiki/Vilna_Gaon)*. Plag hamincha is the earliest time that *Shabbos* can be started.
 * The day is calculated from [sea level sunrise][seaLevelSunrise] to [sea level][seaLevelSunrise] or [sunrise] to [sunset][sunset] (depending on the [isUseElevation]
 *
 * @see .getPlagHamincha
 * @see ComplexZmanimCalendar.getPlagHaminchaBaalHatanya
 * @return the `Date` of the time of *plag hamincha*. If the calculation can't be computed such as
 * in the Arctic Circle where there is at least one day a year where the sun does not rise, and one where it
 * does not set, a null will be returned. See detailed explanation on top of the
 * [AstronomicalCalendar] documentation.
 */
@property (readonly) STTZmanDateBased *plagHamincha __attribute__((swift_name("plagHamincha")));

/**
 * A method that returns a *shaah zmanis* ([temporal hour][temporalHour]) according to
 * the opinion of the *[GRA](https://en.wikipedia.org/wiki/Vilna_Gaon)*. This calculation divides
 * the day based on the opinion of the *GRA* that the day runs from [sea level sunrise][seaLevelSunrise] to [sea level sunset][seaLevelSunset] or [sunrise] to
 * [sunset] (depending on the [isUseElevation] setting). The day is split into 12 equal
 * parts with each one being a *shaah zmanis*. This method is similar to [temporalHour], but can
 * account for elevation.
 *
 * @return the `long` millisecond length of a *shaah zmanis* calculated from sunrise to sunset.
 * If the calculation can't be computed such as in the Arctic Circle where there is at least one day a year
 * where the sun does not rise, and one where it does not set, [Long.MIN_VALUE] will be returned. See
 * detailed explanation on top of the [AstronomicalCalendar] documentation.
 * @see .temporalHour
 * @see seaLevelSunrise
 * @see .seaLevelSunset
 * @see ComplexZmanimCalendar.shaahZmanisBaalHatanya
 */
@property (readonly) STTZmanValueBased *shaahZmanisGra __attribute__((swift_name("shaahZmanisGra")));

/**
 * A method that returns a *shaah zmanis* (temporal hour) according to the opinion of the *[Magen Avraham (MGA)](https://en.wikipedia.org/wiki/Avraham_Gombinern)* based on a 72 minutes *alos*
 * and *tzais*. This calculation divides the day that runs from dawn to dusk (for *sof zman krias shema* and
 * *tfila*). Dawn for this calculation is 72 minutes before [sunrise] or [sea level sunrise][seaLevelSunrise] (depending on the [isUseElevation] elevation setting) and dusk is 72 minutes after [sunset] or [sea level sunset][seaLevelSunset] (depending on the [isUseElevation] elevation
 * setting). This day is split into 12 equal parts with each part being a *shaah zmanis*. Alternate methods of calculating
 * a *shaah zmanis* according to the Magen Avraham (MGA) are available in the subclass [ComplexZmanimCalendar].
 *
 * @return the `long` millisecond length of a *shaah zmanis*. If the calculation can't be computed
 * such as in the Arctic Circle where there is at least one day a year where the sun does not rise, and one
 * where it does not set, [Long.MIN_VALUE] will be returned. See detailed explanation on top of the
 * [AstronomicalCalendar] documentation.
 */
@property (readonly) STTZmanValueBased *shaahZmanisMGA __attribute__((swift_name("shaahZmanisMGA")));

/**
 * This method returns the latest *zman krias shema* (time to recite shema in the morning) that is 3 *
 * [*shaos zmaniyos*][shaahZmanisGra] (solar hours) after [sunrise] or
 * [sea level sunrise][seaLevelSunrise] (depending on the [isUseElevation] setting), according
 * to the [GRA](https://en.wikipedia.org/wiki/Vilna_Gaon).
 * The day is calculated from [sea level sunrise][seaLevelSunrise] to [sea level][seaLevelSunrise] or [sunrise] to [sunset][sunset] (depending on the [isUseElevation]
 * setting).
 *
 * @see sofZmanShma
 * @see shaahZmanisGra
 * @see .isUseElevation
 * @see ComplexZmanimCalendar.getSofZmanShmaBaalHatanya
 * @return the `Date` of the latest *zman shema* according to the GRA. If the calculation can't be
 * computed such as in the Arctic Circle where there is at least one day a year where the sun does not rise,
 * and one where it does not set, a null will be returned. See the detailed explanation on top of the [] documentation.
 */
@property (readonly) STTZmanDateBased *sofZmanShmaGRA __attribute__((swift_name("sofZmanShmaGRA")));

/**
 * This method returns the latest *zman krias shema* (time to recite shema in the morning) that is 3 *
 * [*shaos zmaniyos*][shaahZmanisMGA] (solar hours) after [alos72], according to the
 * [Magen Avraham (MGA)](https://en.wikipedia.org/wiki/Avraham_Gombinern). The day is calculated
 * from 72 minutes before [sea level sunrise][seaLevelSunrise] to 72 minutes after [seaLevelSunrise] or from 72 minutes before [sunrise] to [sunset][sunset] (depending on the [isUseElevation] setting).
 *
 * @return the `Date` of the latest *zman shema*. If the calculation can't be computed such as in
 * the Arctic Circle where there is at least one day a year where the sun does not rise, and one where it
 * does not set, a null will be returned. See detailed explanation on top of the
 * [AstronomicalCalendar] documentation.
 * @see sofZmanShma
 * @see ComplexZmanimCalendar.getShaahZmanis72Minutes
 * @see ComplexZmanimCalendar.getAlos72
 * @see ComplexZmanimCalendar.getSofZmanShmaMGA72Minutes
 */
@property (readonly) STTZmanDateBased *sofZmanShmaMGA __attribute__((swift_name("sofZmanShmaMGA")));

/**
 * This method returns the latest *zman tfila* (time to recite shema in the morning) that is 4 *
 * [*shaos zmaniyos* ][shaahZmanisGra](solar hours) after [sunrise] or
 * [sea level sunrise][seaLevelSunrise] (depending on the [isUseElevation] setting), according
 * to the [GRA](https://en.wikipedia.org/wiki/Vilna_Gaon).
 * The day is calculated from [sea level sunrise][seaLevelSunrise] to [sea level][seaLevelSunrise] or [sunrise] to [sunset][sunset] (depending on the [isUseElevation]
 * setting).
 *
 * @see sofZmanTfila
 * @see shaahZmanisGra
 * @see ComplexZmanimCalendar.getSofZmanTfilaBaalHatanya
 * @return the `Date` of the latest *zman tfilah*. If the calculation can't be computed such as in
 * the Arctic Circle where there is at least one day a year where the sun does not rise, and one where it
 * does not set, a null will be returned. See detailed explanation on top of the [AstronomicalCalendar]
 * documentation.
 */
@property (readonly) STTZmanDateBased *sofZmanTfilaGRA __attribute__((swift_name("sofZmanTfilaGRA")));

/**
 * This method returns the latest *zman tfila* (time to recite shema in the morning) that is 4 *
 * [*shaos zmaniyos*][shaahZmanisMGA] (solar hours) after [alos72], according to the
 * *[Magen Avraham (MGA)](https://en.wikipedia.org/wiki/Avraham_Gombinern)*. The day is calculated
 * from 72 minutes before [sea level sunrise][seaLevelSunrise] to 72 minutes after [][seaLevelSunrise] or from 72 minutes before [sunrise] to [sunset][sunset] (depending on the [isUseElevation] setting).
 *
 * @return the `Date` of the latest *zman tfila*. If the calculation can't be computed such as in
 * the Arctic Circle where there is at least one day a year where the sun does not rise, and one where it
 * does not set), a null will be returned. See detailed explanation on top of the [AstronomicalCalendar]
 * documentation.
 * @see sofZmanTfila
 * @see shaahZmanisMGA
 * @see alos72
 */
@property (readonly) STTZmanDateBased *sofZmanTfilaMGA __attribute__((swift_name("sofZmanTfilaMGA")));

/**
 * A method that returns *tzais* (nightfall) when the sun is [8.5˚][ZENITH_8_POINT_5] below the
 * [geometric horizon][AstronomicalCalendar.GEOMETRIC_ZENITH] (90) after [sunset][sunset], a time that Rabbi Meir
 * Posen in his the *[Ohr Meir](https://www.worldcat.org/oclc/29283612)* calculated that 3 small
 * stars are visible, which is later than the required 3 medium stars. See the [ZENITH_8_POINT_5] constant.
 *
 * @see ZENITH_8_POINT_5
 *
 *
 * @return The `Date` of nightfall. If the calculation can't be computed such as northern and southern
 * locations even south of the Arctic Circle and north of the Antarctic Circle where the sun may not reach
 * low enough below the horizon for this calculation, a null will be returned. See detailed explanation on
 * top of the [AstronomicalCalendar] documentation.
 * @see ZENITH_8_POINT_5
 * ComplexZmanimCalendar.getTzaisGeonim8Point5Degrees
 */
@property (readonly) STTZmanDateBased *tzais __attribute__((swift_name("tzais")));

/**
 * This method returns the *tzais* (nightfall) based on the opinion of *Rabbeinu Tam* that
 * *tzais hakochavim* is calculated as 72 minutes, the time it takes to walk 4 *Mil* at 18 minutes
 * a *Mil*. According to the [Machtzis Hashekel](https://en.wikipedia.org/wiki/Samuel_Loew) in
 * Orach Chaim 235:3, the [Pri Megadim](https://en.wikipedia.org/wiki/Joseph_ben_Meir_Teomim) in Orach
 * Chaim 261:2 (see the Biur Halacha) and others (see Hazmanim Bahalacha 17:3 and 17:5) the 72 minutes are standard
 * clock minutes any time of the year in any location. Depending on the [isUseElevation] setting) a 72
 * minute offset from  either [sunset][sunset] or [sea level sunset][seaLevelSunset] is used.
 *
 * @see ComplexZmanimCalendar.getTzais16Point1Degrees
 * @return the `Date` representing 72 minutes after sunset. If the calculation can't be
 * computed such as in the Arctic Circle where there is at least one day a year where the sun does not rise,
 * and one where it does not set, a null will be returned See detailed explanation on top of the
 * [AstronomicalCalendar] documentation.
 */
@property (readonly) STTZmanDateBased *tzais72 __attribute__((swift_name("tzais72")));
@end


/**
 *
 * This class extends ZmanimCalendar and provides many more *zmanim* than available in the ZmanimCalendar. The basis
 * for most *zmanim* in this class are from the *sefer* **[Yisroel
 * Vehazmanim](https://hebrewbooks.org/9765)** by **[Rabbi Yisrael Dovid Harfenes](https://en.wikipedia.org/wiki/Yisroel_Dovid_Harfenes)**.
 * As an example of the number of different *zmanim* made available by this class, there are methods to return 18
 * different calculations for *alos* (dawn), 18 for *plag hamincha* and 29 for *tzais* available in this
 * API. The real power of this API is the ease in calculating *zmanim* that are not part of the library. The methods for
 * *zmanim* calculations not present in this class or it's superclass  [ZmanimCalendar] are contained in the
 * [AstronomicalCalendar], the base class of the calendars in our API since they are generic methods for calculating
 * time based on degrees or time before or after [sunrise] and [sunset] and are of interest
 * for calculation beyond *zmanim* calculations. Here are some examples.
 *
 * First create the Calendar for the location you would like to calculate:
 *
 * <pre style="background: #FEF0C9; display: inline-block;\">
 * String locationName = &quot;Lakewood, NJ&quot;;
 * double latitude = 40.0828; // Lakewood, NJ
 * double longitude = -74.2094; // Lakewood, NJ
 * double elevation = 20; // optional elevation correction in Meters
 * // the String parameter in timeZone has to be a valid timezone listed in
 * // [java.util.TimeZone.getAvailableIDs]
 * TimeZone timeZone = TimeZone.getTimeZone(&quot;America/New_York&quot;);
 * GeoLocation location = new GeoLocation(locationName, latitude, longitude, elevation, timeZone);
 * ComplexZmanimCalendar czc = new ComplexZmanimCalendar(location);
 * // Optionally set the date or it will default to today's date
 * czc.calendar.set(Calendar.MONTH, Calendar.FEBRUARY);
 * czc.calendar.set(Calendar.DAY_OF_MONTH, 8);</pre>
 *
 *
 * **Note:** For locations such as Israel where the beginning and end of daylight savings time can fluctuate from
 * year to year, if your version of Java does not have an [up to date timezone database](https://www.oracle.com/java/technologies/tzdata-versions.html), create a
 * [java.util.SimpleTimeZone] with the known start and end of DST.
 * To get *alos* calculated as 14 below the horizon (as calculated in the calendars published in Montreal),
 * add [AstronomicalCalendar.GEOMETRIC_ZENITH] (90) to the 14 offset to get the desired time:
 * <br></br><br></br>
 * <pre style="background: #FEF0C9; display: inline-block;\">
 * Date alos14 = czc.getSunriseOffsetByDegrees([AstronomicalCalendar.GEOMETRIC_ZENITH] + 14);</pre>
 *
 *
 * To get *mincha gedola* calculated based on the [Magen Avraham (MGA)](https://en.wikipedia.org/wiki/Avraham_Gombinern) using a *shaah zmanis* based on the day starting
 * 16.1 below the horizon (and ending 16.1 after sunset) the following calculation can be used:
 *
 * <pre style="background: #FEF0C9; display: inline-block;\">
 * Date minchaGedola = czc.getTimeOffset(czc.getAlos16point1Degrees(), czc.getShaahZmanis16Point1Degrees() * 6.5);</pre>
 *
 *
 * or even simpler using the included convenience methods
 * <pre style="background: #FEF0C9; display: inline-block;\">
 * Date minchaGedola = czc.getMinchaGedola(czc.getAlos16point1Degrees(), czc.getShaahZmanis16Point1Degrees());</pre>
 *
 *
 * A little more complex example would be calculating *zmanim* that rely on a *shaah zmanis* that is
 * not present in this library. While a drop more complex, it is still rather easy. An example would be to calculate
 * the [Trumas Hadeshen](https://en.wikipedia.org/wiki/Israel_Isserlein)'s *alos* to
 * *tzais* based *plag hamincha* as calculated in the Machzikei Hadass calendar in Manchester, England.
 * A number of this calendar's *zmanim* are calculated based on a day starting at *alos* of 12 before
 * sunrise and ending at *tzais* of 7.083 after sunset. Be aware that since the *alos* and *tzais*
 * do not use identical degree-based offsets, this leads to *chatzos* being at a time other than the
 * [solar transit][sunTransit] (solar midday). To calculate this *zman*, use the following steps. Note
 * that *plag hamincha* is 10.75 hours after the start of the day, and the following steps are all that it takes.
 * <br></br>
 * <pre style="background: #FEF0C9; display: inline-block;\">
 * Date plag = czc.getPlagHamincha(czc.getSunriseOffsetByDegrees([AstronomicalCalendar.GEOMETRIC_ZENITH] + 12),
 * czc.getSunsetOffsetByDegrees([AstronomicalCalendar.GEOMETRIC_ZENITH] + ZENITH_7_POINT_083));</pre>
 *
 *
 * Something a drop more challenging, but still simple, would be calculating a *zman* using the same "complex"
 * offset day used in the above mentioned Manchester calendar, but for a *shaos zmaniyos* based *zman* not
 * supported by this library, such as calculating the point that one should be *makpid*
 * not to eat on *erev Shabbos* or *erev Yom Tov*. This is 9 *shaos zmaniyos* into the day.
 *
 *  1. Calculate the *shaah zmanis* in milliseconds for this day
 *  1. Add 9 of these *shaos zmaniyos* to *alos* starting at 12
 *
 * <br></br>
 * <pre style="background: #FEF0C9; display: inline-block;\">
 * long shaahZmanis = czc.temporalHour(czc.getSunriseOffsetByDegrees([AstronomicalCalendar.GEOMETRIC_ZENITH] + 12),
 * czc.getSunsetOffsetByDegrees([AstronomicalCalendar.GEOMETRIC_ZENITH] + ZENITH_7_POINT_083));
 * Date sofZmanAchila = getTimeOffset(czc.getSunriseOffsetByDegrees([AstronomicalCalendar.GEOMETRIC_ZENITH] + 12),
 * shaahZmanis * 9);</pre>
 *
 *
 * Calculating this *sof zman achila* according to the [GRA](https://en.wikipedia.org/wiki/Vilna_Gaon)
 * is simplicity itself.
 * <pre style="background: #FEF0C9; display: inline-block;\">
 * Date sofZamnAchila = czc.getTimeOffset(czc.getSunrise(), czc.getShaahZmanisGra() * 9);</pre>
 *
 * <h2>Documentation from the [ZmanimCalendar] parent class</h2>
 * {@inheritDoc}
 *
 * @author  Eliyahu Hershfeld 2004 - 2023
 */
__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("ComplexZmanimCalendar")))
@interface STTComplexZmanimCalendar : STTZmanimCalendar
- (instancetype)initWithLocation:(STTGeoLocation *)location __attribute__((swift_name("init(location:)"))) __attribute__((objc_designated_initializer));
- (instancetype)initWithLocation:(STTGeoLocation *)location date:(STTKotlinx_datetimeLocalDate *)date useElevation:(BOOL)useElevation ateretTorahSunsetOffset:(double)ateretTorahSunsetOffset candleLightingOffset:(double)candleLightingOffset __attribute__((swift_name("init(location:date:useElevation:ateretTorahSunsetOffset:candleLightingOffset:)"))) __attribute__((objc_designated_initializer));
- (instancetype)initWithGeoLocation:(STTGeoLocation *)geoLocation isUseElevation:(BOOL)isUseElevation candleLightingOffset:(double)candleLightingOffset __attribute__((swift_name("init(geoLocation:isUseElevation:candleLightingOffset:)"))) __attribute__((objc_designated_initializer)) __attribute__((unavailable));
@property (class, readonly, getter=companion) STTComplexZmanimCalendarCompanion *companion __attribute__((swift_name("companion")));
- (NSArray<STTZman<id> *> *)getZmanCalculationMethod:(id<STTZmanCalculationMethod>)zmanCalculationMethod __attribute__((swift_name("get(zmanCalculationMethod:)")));
- (NSArray<STTZman<id> *> *)getZmanType:(STTZmanType *)zmanType __attribute__((swift_name("get(zmanType:)")));

/**
 * A utility methos to calculate zmanim based on [Rav Moshe Feinstein](https://en.wikipedia.org/wiki/Moshe_Feinstein)
 * as calculated in [MTJ](https://en.wikipedia.org/wiki/Mesivtha_Tifereth_Jerusalem), [Yeshiva of Staten Island](https://en.wikipedia.org/wiki/Mesivtha_Tifereth_Jerusalem), and Camp Yeshiva
 * of Staten Island. The day is split in two, from *alos* / sunrise to fixed local *chatzos*, and the
 * second half of the day, from fixed local *chatzos* to sunset / *tzais*. Morning based times are calculated
 * based on the first 6 hours, and afternoon times based on the second half of the day.
 *
 * @param startOfHalfDay
 * The start of the half day. This would be *alos* or sunrise for morning based times and fixed
 * local *chatzos* for the second half of the day.
 * @param endOfHalfDay
 * The end of the half day. This would be fixed local *chatzos* for morning based times and sunset
 * or *tzais* for afternoon based times.
 * @param hours
 * the number of hours to offset the beginning of the first or second half of the day
 *
 * @return the `Date` of the later of [.getMinchaGedolaBaalHatanya] and [.getMinchaGedola30Minutes].
 * If the calculation can't be computed such as in the Arctic Circle where there is at least one day a year
 * where the sun does not rise, and one where it does not set, a null will be returned. See detailed
 * explanation on top of the [AstronomicalCalendar] documentation.
 *
 * @see ComplexZmanimCalendar.fixedLocalChatzos
 */
- (STTKotlinx_datetimeInstant * _Nullable)getFixedLocalChatzosBasedZmanimStartOfHalfDay:(STTKotlinx_datetimeInstant * _Nullable)startOfHalfDay endOfHalfDay:(STTKotlinx_datetimeInstant * _Nullable)endOfHalfDay hours:(double)hours __attribute__((swift_name("getFixedLocalChatzosBasedZmanim(startOfHalfDay:endOfHalfDay:hours:)")));

/**
 * Returns the latest time of *Kiddush Levana* calculated as 15 days after the *molad*. This is the
 * opinion brought down in the Shulchan Aruch (Orach Chaim 426). It should be noted that some opinions hold that the
 * [Rema](https://en.wikipedia.org/wiki/Moses_Isserles) who brings down the opinion of the [Maharil's](https://en.wikipedia.org/wiki/Yaakov_ben_Moshe_Levi_Moelin) of calculating
 * [half way between *molad* and *molad*][sofZmanKidushLevanaBetweenMoldos] is of
 * the opinion that the Mechaber agrees to his opinion. Also see the Aruch Hashulchan. For additional details on the subject,
 * see Rabbi Dovid Heber's very detailed write-up in *Siman Daled* (chapter 4) of [Shaarei Zmanim](https://hebrewbooks.org/53000). If the time of *sof zman Kiddush Levana* occurs during
 * the day (between the *alos* and *tzais* passed in as parameters), it returns the *alos* passed in. If a
 * null *alos* or *tzais* are passed to this method, the non-daytime adjusted time will be returned.
 *
 * @param alos
 * the beginning of the Jewish day. If *Kidush Levana* occurs during the day (starting at *alos* and
 * ending at *tzais*), the time returned will be *alos*. If either the *alos* or *tzais*
 * parameters are null, no daytime adjustment will be made.
 * @param tzais
 * the end of the Jewish day. If *Kidush Levana* occurs during the day (starting at *alos* and ending at
 * *tzais*), the time returned will be *alos*. If either the *alos* or *tzais* parameters
 * are null, no daytime adjustment will be made.
 *
 * @return the Date representing the moment 15 days after the molad. If the time occurs between *alos* and
 * *tzais*, *alos* will be returned
 *
 * @see sofZmanKidushLevanaBetweenMoldos
 * @see JewishCalendar.getSofZmanKidushLevana15Days
 */
- (STTKotlinx_datetimeInstant * _Nullable)getSofZmanKidushLevana15DaysAlos:(STTKotlinx_datetimeInstant * _Nullable)alos tzais:(STTKotlinx_datetimeInstant * _Nullable)tzais __attribute__((swift_name("getSofZmanKidushLevana15Days(alos:tzais:)")));

/**
 * Returns the latest time of *Kidush Levana* according to the [Maharil's](https://en.wikipedia.org/wiki/Yaakov_ben_Moshe_Levi_Moelin) opinion that it is calculated as
 * halfway between *molad* and *molad*. This adds half the 29 days, 12 hours and 793 chalakim time
 * between *molad* and *molad* (14 days, 18 hours, 22 minutes and 666 milliseconds) to the month's *molad*.
 * If the time of *sof zman Kiddush Levana* occurs during the day (between the *alos* and *tzais* passed in
 * as parameters), it returns the *alos* passed in. If a null *alos* or *tzais* are passed to this method,
 * the non-daytime adjusted time will be returned.
 *
 * @param alos
 * the beginning of the Jewish day. If *Kidush Levana* occurs during the day (starting at *alos* and
 * ending at *tzais*), the time returned will be *alos*. If either the *alos* or *tzais*
 * parameters are null, no daytime adjustment will be made.
 * @param tzais
 * the end of the Jewish day. If Kidush Levana occurs during the day (starting at *alos* and ending at
 * *tzais*), the time returned will be *alos*. If either the *alos* or *tzais* parameter
 * are null, no daytime adjustment will be made.
 * @return null if the [jewish day of the month][JewishCalendar.jewishDayOfMonth] is < 11 or > 16. Otherwise, the Date representing the moment halfway between molad and molad. If the time occurs between
 * *alos* and *tzais*, *alos* will be returned.
 * @see sofZmanKidushLevanaBetweenMoldos
 * @see sofZmanKidushLevana15Days
 * @see JewishCalendar.getSofZmanKidushLevanaBetweenMoldos
 */
- (STTKotlinx_datetimeInstant * _Nullable)getSofZmanKidushLevanaBetweenMoldosAlos:(STTKotlinx_datetimeInstant * _Nullable)alos tzais:(STTKotlinx_datetimeInstant * _Nullable)tzais __attribute__((swift_name("getSofZmanKidushLevanaBetweenMoldos(alos:tzais:)")));

/**
 * Returns the earliest time of *Kiddush Levana* according to [Rabbeinu Yonah](https://en.wikipedia.org/wiki/Yonah_Gerondi)'s opinion that it can be said 3 days after the *molad*.
 * If the time of *tchilas zman Kiddush Levana* occurs during the day (between *alos* and *tzais* passed to
 * this method) it will return the following *tzais*. If null is passed for either *alos* or *tzais*, the actual
 * *tchilas zman Kiddush Levana* will be returned, regardless of if it is during the day or not.
 *
 * @param alos
 * the beginning of the Jewish day. If Kidush Levana occurs during the day (starting at *alos* and ending
 * at *tzais*), the time returned will be *tzais*. If either the *alos* or *tzais* parameters
 * are null, no daytime adjustment will be made.
 * @param tzais
 * the end of the Jewish day. If *Kidush Levana* occurs during the day (starting at *alos* and ending at
 * *tzais*), the time returned will be *tzais*. If either the *alos* or *tzais* parameters
 * are null, no daytime adjustment will be made.
 *
 * @return the Date representing the moment 3 days after the molad. If the time occurs between *alos* and
 * *tzais*, *tzais* will be returned
 * @see .getTchilasZmanKidushLevana3Days
 * @see .getTchilasZmanKidushLevana7Days
 * @see JewishCalendar.getTchilasZmanKidushLevana3Days
 */
- (STTKotlinx_datetimeInstant * _Nullable)getTchilasZmanKidushLevana3DaysAlos:(STTKotlinx_datetimeInstant * _Nullable)alos tzais:(STTKotlinx_datetimeInstant * _Nullable)tzais __attribute__((swift_name("getTchilasZmanKidushLevana3Days(alos:tzais:)")));

/**
 * Returns the earliest time of *Kiddush Levana* according to the opinions that it should not be said until 7
 * days after the *molad*. If the time of *tchilas zman Kiddush Levana* occurs during the day (between
 * [*alos*][ZmanimCalendar.getAlos72] and [*tzais*][ZmanimCalendar.getTzais72]) it
 * return the next *tzais*.
 *
 * @param alos
 * the beginning of the Jewish day. If *Kidush Levana* occurs during the day (starting at *alos*
 * and ending at *tzais*), the time returned will be *tzais*. If either the *alos* or
 * *tzais* parameters are null, no daytime adjustment will be made.
 * @param tzais
 * the end of the Jewish day. If *Kidush Levana* occurs during the day (starting at *alos* and
 * ending at *tzais*), the time returned will be *tzais*. If either the *alos* or
 * *tzais* parameters are null, no daytime adjustment will be made.
 *
 * @return the Date representing the moment 7 days after the molad. If the time occurs between *alos* and
 * *tzais*, *tzais* will be returned
 * @see .getTchilasZmanKidushLevana3Days
 * @see .getTchilasZmanKidushLevana7Days
 * @see JewishCalendar.getTchilasZmanKidushLevana7Days
 */
- (STTKotlinx_datetimeInstant * _Nullable)getTchilasZmanKidushLevana7DaysAlos:(STTKotlinx_datetimeInstant * _Nullable)alos tzais:(STTKotlinx_datetimeInstant * _Nullable)tzais __attribute__((swift_name("getTchilasZmanKidushLevana7Days(alos:tzais:)")));

/**
 * An unsorted list of all opinions for the length of a sha'ah zmanis (given the time and place this class holds).
 * */
@property (readonly) NSArray<STTZmanValueBased *> *allShaosZmaniyos __attribute__((swift_name("allShaosZmaniyos")));

/**
 * An unsorted list of all zmanim this class exposes. Zmanim are only computed when list is accessed.
 */
@property (readonly) NSArray<STTZmanDateBased *> *allZmanim __attribute__((swift_name("allZmanim")));

/**
 * This method should be used *lechumra* only and returns *alos* (dawn) calculated using 120 minutes
 * before [sea level sunrise][seaLevelSunrise] based on the time
 * to walk the distance of 5 *Mil*(*Ula*) at 24 minutes a *Mil*.
 *
 * Time based offset calculations
 * for *alos* are based on the* opinion of the *[Rishonim](https://en.wikipedia.org/wiki/Rishonim)
 * who stated that the time of the *neshef* (time between dawn and sunrise) does not vary by the time of
 * year or location but purely depends on the time it takes to walk the distance of 5 *Mil*(*Ula*). Since
 * this time is extremely early, it should only be used *lechumra*, such as not eating after this time on a fast
 * day, and not as the start time for *mitzvos* that can only be performed during the day.
 *
 * @return the `Date` representing the time. If the calculation can't be computed such as in the Arctic
 * Circle where there is at least one day a year where the sun does not rise, and one where it does not set,
 * a null will be returned. See detailed explanation on top of the [AstronomicalCalendar]
 * documentation.
 *
 * @see tzais120
 * @see alos26Degrees
 */
@property (readonly) STTZmanDateBased *alos120 __attribute__((swift_name("alos120")));

/**
 * This method should be used *lechumra* only and  method returns *alos* (dawn) calculated using
 * 120 minutes *zmaniyos* or 1/6th of the day before [sunrise] or [seaLevelSunrise] (depending on the [isUseElevation] setting). This is based
 * on a 24-minute *Mil* so the time for 5 *Mil* is 120 minutes which is 1/6th of a day (12 * 60 /
 * 6 = 120). The day is calculated from [sea level sunrise][seaLevelSunrise] to [seaLevelSunrise] or [sunrise] to [sunset] (depending
 * on the [isUseElevation]. The actual calculation used is [sunrise] - ([shaahZmanisGra] * 2). Since this time is extremely early, it should only be used *lechumra*, such
 * as not eating after this time on a fast day, and not as the start time for *mitzvos* that can only be
 * performed during the day.
 *
 * @return the `Date` representing the time. If the calculation can't be computed such as in the Arctic
 * Circle where there is at least one day a year where the sun does not rise, and one where it does not set,
 * a null will be returned. See detailed explanation on top of the [AstronomicalCalendar]
 * documentation.
 * @see alos120
 * @see alos26Degrees
 */
@property (readonly) STTZmanDateBased *alos120Zmanis __attribute__((swift_name("alos120Zmanis")));

/**
 * Method to return *alos* (dawn) calculated when the sun is [16.1˚][ZENITH_16_POINT_1] below the
 * eastern geometric horizon before sunrise.
 *
 * This calculation is based on the same calculation of [72 minutes][alos72],
 * but uses a degree-based calculation instead of 72 exact minutes.
 * This calculation is based on the position of the sun 72 minutes before sunrise in Jerusalem [around the equinox / equilux](https://kosherjava.com/2022/01/12/equinox-vs-equilux-zmanim-calculations/),
 * which calculates to 16.1 below [geometric zenith][AstronomicalCalendar.GEOMETRIC_ZENITH].
 *
 * @return the `Date` representing *alos*. If the calculation can't be computed such as northern
 * and southern locations even south of the Arctic Circle and north of the Antarctic Circle where the sun
 * may not reach low enough below the horizon for this calculation, a null will be returned. See detailed
 * explanation on top of the [AstronomicalCalendar] documentation.
 * @see ZENITH_16_POINT_1
 *
 * @see alos72
 */
@property (readonly) STTZmanDateBased *alos16Point1Degrees __attribute__((swift_name("alos16Point1Degrees")));

/**
 * A method to return *alos* (dawn) calculated when the sun is [18˚][AstronomicalCalendar.ASTRONOMICAL_ZENITH] below the
 * eastern geometric horizon before sunrise.
 *
 * @return the `Date` representing *alos*. If the calculation can't be computed such as northern
 * and southern locations even south of the Arctic Circle and north of the Antarctic Circle where the sun
 * may not reach low enough below the horizon for this calculation, a null will be returned. See detailed
 * explanation on top of the [AstronomicalCalendar] documentation.
 * @see ASTRONOMICAL_ZENITH
 */
@property (readonly) STTZmanDateBased *alos18Degrees __attribute__((swift_name("alos18Degrees")));

/**
 * A method to return *alos* (dawn) calculated when the sun is [19˚][ZENITH_19_DEGREES] below the
 * eastern geometric horizon before sunrise.
 * **Sources:**
 * - This is the [Rambam](https://en.wikipedia.org/wiki/Maimonides) 's *alos* according to
 * - Rabbi Moshe Kosower's [Maaglei Tzedek](https://www.worldcat.org/oclc/145454098), page 88,
 * - Rabbi Dovid Shor's [Ayeles Hashachar Vol. I, page 12](https://hebrewbooks.org/pdfpager.aspx?req=33464&pgnum=13),
 * - Rabbi Yaakov Gershon Weiss's [Yom Valayla Shel Torah, Ch. 34, p. 222](https://hebrewbooks.org/pdfpager.aspx?req=55960&pgnum=258) and
 * - Rabbi Yaakov Shakow's [Luach Ikvei Hayom](https://www.worldcat.org/oclc/1043573513).
 *
 * @return the `Date` representing *alos*. If the calculation can't be computed such as northern
 * and southern locations even south of the Arctic Circle and north of the Antarctic Circle where the sun
 * may not reach low enough below the horizon for this calculation, a null will be returned. See detailed
 * explanation on top of the [AstronomicalCalendar] documentation.
 * @see ASTRONOMICAL_ZENITH
 */
@property (readonly) STTZmanDateBased *alos19Degrees __attribute__((swift_name("alos19Degrees")));

/**
 * Method to return *alos* (dawn) calculated when the sun is [19.8˚][ZENITH_19_POINT_8] below the
 * eastern geometric horizon before sunrise. This calculation is based on the same calculation of
 * [90 minutes][alos90] but uses a degree-based calculation instead of 90 exact minutes. This calculation
 * is based on the position of the sun 90 minutes before sunrise in Jerusalem [around the equinox / equilux](https://kosherjava.com/2022/01/12/equinox-vs-equilux-zmanim-calculations/), which
 * calculates to 19.8 below [geometric zenith][AstronomicalCalendar.GEOMETRIC_ZENITH].
 *
 * @return the `Date` representing *alos*. If the calculation can't be computed such as northern
 * and southern locations even south of the Arctic Circle and north of the Antarctic Circle where the sun
 * may not reach low enough below the horizon for this calculation, a null will be returned. See detailed
 * explanation on top of the [AstronomicalCalendar] documentation.
 * @see ZENITH_19_POINT_8
 *
 * @see alos90
 */
@property (readonly) STTZmanDateBased *alos19Point8Degrees __attribute__((swift_name("alos19Point8Degrees")));

/**
 * This method should be used *lechumra* only and returns *alos* (dawn) calculated when the sun is [ZENITH_26_DEGREES] below the eastern geometric horizon before sunrise.
 * This calculation is based on the same calculation of [120 minutes][alos120] but uses a degree-based calculation instead of 120 exact minutes.
 * This calculation is based on the position of the sun 120 minutes before sunrise in Jerusalem [around the equinox / equilux](https://kosherjava.com/2022/01/12/equinox-vs-equilux-zmanim-calculations/),
 * which calculates to 26 below [geometric zenith][AstronomicalCalendar.GEOMETRIC_ZENITH].
 *
 * Since this time is extremely early, it should only be used *lechumra* only, such as not eating after this time
 * on a fast day, and not as the start time for *mitzvos* that can only be performed during the day.
 *
 * @return the `Date` representing *alos*. If the calculation can't be computed such as northern
 * and southern locations even south of the Arctic Circle and north of the Antarctic Circle where the sun
 * may not reach low enough below the horizon for this calculation, a null will be returned. See detailed
 * explanation on top of the [AstronomicalCalendar] documentation.
 * @see ZENITH_26_DEGREES
 *
 * @see alos120
 * @see tzais120
 * @see tzais26Degrees
 */
@property (readonly) STTZmanDateBased *alos26Degrees __attribute__((swift_name("alos26Degrees")));

/**
 * Method to return *alos* (dawn) calculated as 60 minutes before sunrise.
 *
 * This is the time to walk the distance of 4 *Mil* at 15 minutes per *Mil* (4 * 15 = 60).
 *
 * **Opinions on how long it takes to walk a *mil*:**
 *
 * - This (15 minutes per *mil*) seems to be the opinion of the [Chavas Yair](https://en.wikipedia.org/wiki/Yair_Bacharach) in
 * the Mekor Chaim, Orach Chaim Ch. 90, though the Mekor Chaim in Ch. 58 and in the [Chut Hashani Ch. 97](https://hebrewbooks.org/pdfpager.aspx?req=45193&pgnum=214)
 * states that a person walks 3 and a 1/3 *mil* in an hour, or an 18-minute *mil*.
 *
 * - Also see the [Divrei Malkiel](https://he.wikipedia.org/wiki/%D7%9E%D7%9C%D7%9B%D7%99%D7%90%D7%9C_%D7%A6%D7%91%D7%99_%D7%98%D7%A0%D7%A0%D7%91%D7%95%D7%99%D7%9D) [Vol. 4, Ch. 20, page 34](https://hebrewbooks.org/pdfpager.aspx?req=803&pgnum=33))
 * who mentions the 15 minute *mil* lechumra by baking matzos.
 *
 * - Also see the [Maharik](https://en.wikipedia.org/wiki/Joseph_Colon_Trabotto) [Ch. 173](https://hebrewbooks.org/pdfpager.aspx?req=1142&pgnum=216)
 * where the questioner quoting the [Ra'avan](https://en.wikipedia.org/wiki/Eliezer_ben_Nathan) is of the opinion
 * that the time to walk a *mil* is 15 minutes (5 *mil* in a little over an hour).
 *
 *     - There are many who believe that there is a *ta'us sofer* (scribe's error) in the Ra'avan, and it should 4 *mil*
 * in a little over an hour, or an 18-minute *mil*.
 *
 * Time based offset calculations are based on the opinion of the *[Rishonim](https://en.wikipedia.org/wiki/Rishonim)*
 * who stated that the time of the *neshef* (time between dawn and sunrise) does not vary by the time of year or location
 * but purely depends on the time it takes to walk the distance of 4 *mil*.
 *
 * [tzaisGeonim9Point75Degrees] is a related *zman* that is a degree-based calculation based on 60 minutes.
 *
 * @return the [Instant] representing the time. If the calculation can't be computed such as in the Arctic
 * Circle where there is at least one day a year where the sun does not rise, and one where it does not set,
 * a null will be returned. See detailed explanation on top of the [AstronomicalCalendar].
 * documentation.
 *
 * @see tzais60
 * @see plagHamincha60Minutes
 * @see shaahZmanis60Minutes
 */
@property (readonly) STTZmanDateBased *alos60 __attribute__((swift_name("alos60")));

/**
 * Method to return *alos* (dawn) calculated using 72 minutes *zmaniyos* or 1/10th of the day before
 * sunrise.
 *
 * This is based on an 18-minute *Mil* so the time for 4 *Mil* is 72 minutes.
 *
 * This is 1/10th of a day (12 * 60 = 720), by the calculation that a day starts at [sea level sunrise][seaLevelSunrise]
 * and ends at [sea level sunset][seaLevelSunrise] (or [sunrise] to [sunset], depending on the [isUseElevation] setting).
 *
 * The actual calculation is [seaLevelSunrise] - ([shaahZmanisGra] * 1.2). This calculation
 * is used in the calendars published by the [Hisachdus Harabanim D'Artzos Habris Ve'Canada](https://en.wikipedia.org/wiki/Central_Rabbinical_Congress).
 *
 * @return the `Date` representing the time. If the calculation can't be computed such as in the Arctic
 * Circle where there is at least one day a year where the sun does not rise, and one where it does not set,
 * a null will be returned. See detailed explanation on top of the [AstronomicalCalendar]
 * documentation.
 * @see shaahZmanisGra
 */
@property (readonly) STTZmanDateBased *alos72Zmanis __attribute__((swift_name("alos72Zmanis")));

/**
 * Method to return *alos* (dawn) calculated using 90 minutes before [sea level][seaLevelSunrise] based on the time to walk the distance of 4 *Mil* at 22.5 minutes a *Mil*.
 *
 * Time based offset calculations for *alos* are based on the opinion of the *[Rishonim](https://en.wikipedia.org/wiki/Rishonim)* who stated that the time of the *Neshef*
 * (time between dawn and sunrise) does not vary by the time of year or location but purely depends on the time it
 * takes to walk the distance of 4 *Mil*.
 *
 * @return the `Date` representing the time. If the calculation can't be computed such as in the Arctic
 * Circle where there is at least one day a year where the sun does not rise, and one where it does not set,
 * a null will be returned. See detailed explanation on top of the [AstronomicalCalendar]
 * documentation.
 */
@property (readonly) STTZmanDateBased *alos90 __attribute__((swift_name("alos90")));

/**
 * Method to return *alos* (dawn) calculated using 90 minutes *zmaniyos* or 1/8th of the day before
 * [sunrise] or [sea level sunrise][seaLevelSunrise] (depending on the [isUseElevation] setting).
 *
 * This is based on a 22.5-minute *Mil* so the time for 4 *Mil* is 90 minutes which is 1/8th of a day (12 * 60) / 8 = 90.
 *
 * The day is calculated from [sea level sunrise][seaLevelSunrise] to [sea level sunset][seaLevelSunset] or [sunrise][sunrise] to [sunset][sunset] (depending on the [isUseElevation].
 * The actual calculation used is [sunrise] - ([shaahZmanisGra] * 1.5).
 *
 * @return the `Date` representing the time. If the calculation can't be computed such as in the Arctic
 * Circle where there is at least one day a year where the sun does not rise, and one where it does not set,
 * a null will be returned. See detailed explanation on top of the [AstronomicalCalendar]
 * documentation.
 * @see shaahZmanisGra
 */
@property (readonly) STTZmanDateBased *alos90Zmanis __attribute__((swift_name("alos90Zmanis")));

/**
 * Method to return *alos* (dawn) calculated using 96 minutes before [sunrise] or
 * [sea level sunrise][seaLevelSunrise] (depending on the [isUseElevation] setting) that is based
 * on the time to walk the distance of 4 *Mil* at 24 minutes a *Mil*.
 *
 * Time based offset calculations for *alos* are based on the opinion of the *[Rishonim](https://en.wikipedia.org/wiki/Rishonim)*
 * who stated that the time of the *Neshef* (time between dawn and sunrise) does not vary by the time of year or location
 * but purely depends on the time it takes to walk the distance of 4 *Mil*.
 *
 * @return the `Date` representing the time. If the calculation can't be computed such as in the Arctic
 * Circle where there is at least one day a year where the sun does not rise, and one where it does not set,
 * a null will be returned. See detailed explanation on top of the [AstronomicalCalendar]
 * documentation.
 */
@property (readonly) STTZmanDateBased *alos96 __attribute__((swift_name("alos96")));

/**
 * This method returns *alos* (dawn) calculated using 96 minutes *zmaniyos* or 1/7.5th of the day before
 * [sunrise][sunrise] or [sea level sunrise][seaLevelSunrise] (depending on the [isUseElevation] setting).
 *
 * This is based on a 24-minute *Mil* so the time for 4 *Mil* is 96 minutes which is 1/7.5th of a day (12 * 60 / 7.5 = 96).
 * The day is calculated from [sea level sunrise][seaLevelSunrise] to [sea level][seaLevelSunrise] or [sunrise][sunrise] to [sunset][sunset] (depending on the [isUseElevation].
 * The actual calculation used is [sunrise] - ([shaahZmanisGra] * 1.6).
 *
 * @return the [Instant] representing the time. If the calculation can't be computed such as in the Arctic
 * Circle where there is at least one day a year where the sun does not rise, and one where it does not set,
 * a null will be returned. See detailed explanation on top of the [AstronomicalCalendar]
 * documentation.
 * @see shaahZmanisGra
 */
@property (readonly) STTZmanDateBased *alos96Zmanis __attribute__((swift_name("alos96Zmanis")));

/**
 * Returns the [Baal Hatanya](https://en.wikipedia.org/wiki/Shneur_Zalman_of_Liadi) 's *alos*
 * (dawn) calculated as the time when the sun is 16.9 below the eastern [geometric horizon][AstronomicalCalendar.GEOMETRIC_ZENITH]
 * before [sunrise]. For more information the source of 16.9 see [ZENITH_16_POINT_9].
 *
 * @see ZENITH_16_POINT_9
 *
 * @return The `Date` of dawn. If the calculation can't be computed such as northern and southern
 * locations even south of the Arctic Circle and north of the Antarctic Circle where the sun may not reach
 * low enough below the horizon for this calculation, a null will be returned. See detailed explanation on
 * top of the [AstronomicalCalendar] documentation.
 */
@property (readonly) STTZmanDateBased *alosBaalHatanya __attribute__((swift_name("alosBaalHatanya")));

/**
 * The offset in minutes after sunset used to calculate *tzais* based on the calculations of
 * *Chacham* Yosef Harari-Raful of Yeshivat Ateret Torah calculations. The default value is 40 minutes.
 * This affects most *zmanim*, since almost all zmanim use subset as part of their calculation.
 *
 * This is a `public var` to allow overriding the default and adjusting the offset used in calculating tzais.
 * *Chacham* Yosef Harari-Raful of Yeshivat Ateret Torah uses 40 minutes globally except for in Israel where a
 * 25-minute offset is used.
 * This offset impacts all Ateret Torah *zmanim*.
 *
 * @return the number of minutes after sunset for *Tzait*.
 */
@property double ateretTorahSunsetOffset __attribute__((swift_name("ateretTorahSunsetOffset")));

/**
 * Method to return the beginning of *bain hashmashos* of Rabbeinu Tam calculated when the sun is
 * [13.24˚][ZENITH_13_POINT_24] below the western [geometric horizon][AstronomicalCalendar.GEOMETRIC_ZENITH] (90)
 * after sunset. This calculation is based on the same calculation of [*bain hashmashos* Rabbeinu Tam 58.5 minutes][bainHashmashosRT58Point5Minutes] but uses a degree-based calculation instead of 58.5 exact
 * minutes. This calculation is based on the position of the sun 58.5 minutes after sunset in Jerusalem [around the equinox / equilux](https://kosherjava.com/2022/01/12/equinox-vs-equilux-zmanim-calculations/),
 * which calculates to 13.24 below [geometric zenith][AstronomicalCalendar.GEOMETRIC_ZENITH].
 * NOTE: As per Yisrael Vehazmanim Vol. III page 1028, No. 50, a dip of slightly less than 13 should be used.
 * Calculations show that the proper dip to be 13.2456 (truncated to 13.24 that provides about 1.5 second
 * earlier (*lechumra*) time) below the horizon at that time. This makes a difference of 1 minute and 10
 * seconds in Jerusalem during the Equinox, and 1 minute 29 seconds during the solstice as compared to the proper
 * 13.24 versus 13. For NY during the solstice, the difference is 1 minute 56 seconds.
 * @todo recalculate the above based on equilux/equinox calculations.
 *
 * @return the `Date` of the sun being 13.24 below [geometric zenith][AstronomicalCalendar.GEOMETRIC_ZENITH]
 * (90). If the calculation can't be computed such as northern and southern locations even south of the
 * Arctic Circle and north of the Antarctic Circle where the sun may not reach low enough below the horizon
 * for this calculation, a null will be returned. See detailed explanation on top of the
 * [AstronomicalCalendar] documentation.
 *
 * @see ZENITH_13_POINT_24
 *
 * @see bainHashmashosRT58Point5Minutes
 */
@property (readonly) STTZmanDateBased *bainHashmashosRT13Point24Degrees __attribute__((swift_name("bainHashmashosRT13Point24Degrees")));

/**
 * This method returns the beginning of *bain hashmashos* based on the calculation of 13.5 minutes (3/4 of an
 * 18-minute *Mil*) before *shkiah* calculated as [7.083˚][tzaisGeonim7Point083Degrees].
 *
 * @return the `Date` of the *bain hashmashos* of Rabbeinu Tam in this calculation. If the
 * calculation can't be computed such as northern and southern locations even south of the Arctic Circle and
 * north of the Antarctic Circle where the sun may not reach low enough below the horizon for this
 * calculation, a null will be returned. See detailed explanation on top of the [AstronomicalCalendar]
 * documentation.
 * @see tzaisGeonim7Point083Degrees
 */
@property (readonly) STTZmanDateBased *bainHashmashosRT13Point5MinutesBefore7Point083Degrees __attribute__((swift_name("bainHashmashosRT13Point5MinutesBefore7Point083Degrees")));

/**
 * This method returns the beginning of *bain hashmashos* of Rabbeinu Tam calculated according to the
 * opinion of the *Divrei Yosef* (see Yisrael Vehazmanim) calculated 5/18th (27.77%) of the time between
 * *alos* (calculated as 19.8 before sunrise) and sunrise. This is added to sunset to arrive at the time
 * for *bain hashmashos* of Rabbeinu Tam.
 *
 * @return the `Date` of *bain hashmashos* of Rabbeinu Tam for this calculation. If the
 * calculation can't be computed such as northern and southern locations even south of the Arctic Circle and
 * north of the Antarctic Circle where the sun may not reach low enough below the horizon for this
 * calculation, a null will be returned. See detailed explanation on top of the [AstronomicalCalendar]
 * documentation.
 */
@property (readonly) STTZmanDateBased *bainHashmashosRT2Stars __attribute__((swift_name("bainHashmashosRT2Stars")));

/**
 * This method returns the beginning of *Bain hashmashos* of Rabbeinu Tam calculated as a 58.5
 * minute offset after sunset. *bain hashmashos* is 3/4 of a *Mil* before *tzais* or 3 1/4
 * *Mil* after sunset. With a *Mil* calculated as 18 minutes, 3.25 * 18 = 58.5 minutes.
 *
 * @return the `Date` of 58.5 minutes after sunset. If the calculation can't be computed such as in the
 * Arctic Circle where there is at least one day a year where the sun does not rise, and one where it does
 * not set, a null will be returned. See detailed explanation on top of the [AstronomicalCalendar]
 * documentation.
 */
@property (readonly) STTZmanDateBased *bainHashmashosRT58Point5Minutes __attribute__((swift_name("bainHashmashosRT58Point5Minutes")));

/**
 * This method returns the beginning of *bain hashmashos* (twilight) according to the [Yereim (Rabbi Eliezer of Metz)](https://en.wikipedia.org/wiki/Eliezer_ben_Samuel) calculated as 13.5 minutes
 * or 3/4 of an 18-minute *Mil* before sunset. According to the Yereim, *bain hashmashos* starts 3/4 of
 * a *Mil* before sunset and *tzais* or nightfall starts at sunset.
 *
 * @return the `Date` of 13.5 minutes before sunset. If the calculation can't be computed such as in the
 * Arctic Circle where there is at least one day a year where the sun does not rise, and one where it does
 * not set, a null will be returned. See detailed explanation on top of the [AstronomicalCalendar]
 * documentation.
 *
 * @see bainHashmashosYereim2Point1Degrees
 */
@property (readonly) STTZmanDateBased *bainHashmashosYereim13Point5Minutes __attribute__((swift_name("bainHashmashosYereim13Point5Minutes")));

/**
 * This method returns the beginning of *bain hashmashos* (twilight) according to the [Yereim (Rabbi Eliezer of Metz)](https://en.wikipedia.org/wiki/Eliezer_ben_Samuel) calculated as 16.875
 * minutes or 3/4 of a 22.5-minute *Mil* before sunset. According to the Yereim, *bain hashmashos*
 * starts 3/4 of a *Mil* before sunset and *tzais* or nightfall starts at sunset.
 *
 * @return the `Date` of 16.875 minutes before sunset. If the calculation can't be computed such as in the
 * Arctic Circle where there is at least one day a year where the sun does not rise, and one where it does
 * not set, a null will be returned. See detailed explanation on top of the [AstronomicalCalendar]
 * documentation.
 *
 * @see bainHashmashosYereim2Point8Degrees
 */
@property (readonly) STTZmanDateBased *bainHashmashosYereim16Point875Minutes __attribute__((swift_name("bainHashmashosYereim16Point875Minutes")));

/**
 * This method returns the beginning of *bain hashmashos* (twilight) according to the [Yereim (Rabbi Eliezer of Metz)](https://en.wikipedia.org/wiki/Eliezer_ben_Samuel) calculated as 18 minutes
 * or 3/4 of a 24-minute *Mil* before sunset. According to the Yereim, *bain hashmashos* starts 3/4
 * of a *Mil* before sunset and *tzais* or nightfall starts at sunset.
 *
 * @return the `Date` of 18 minutes before sunset. If the calculation can't be computed such as in the
 * Arctic Circle where there is at least one day a year where the sun does not rise, and one where it does
 * not set, a null will be returned. See detailed explanation on top of the [AstronomicalCalendar]
 * documentation.
 * @see bainHashmashosYereim3Point05Degrees
 */
@property (readonly) STTZmanDateBased *bainHashmashosYereim18Minutes __attribute__((swift_name("bainHashmashosYereim18Minutes")));

/**
 * This method returns the beginning of *bain hashmashos* according to the [Yereim (Rabbi Eliezer of Metz)](https://en.wikipedia.org/wiki/Eliezer_ben_Samuel)
 * calculated as the sun's position 2.1 above the horizon [around the equinox / equilux](https://kosherjava.com/2022/01/12/equinox-vs-equilux-zmanim-calculations/)
 * in Yerushalayim, its position 13.5 minutes or 3/4 of an 18-minute *Mil* before sunset. According to the Yereim,
 * *bain hashmashos* starts 3/4 of a *mil* before sunset and *tzais* or nightfall starts at sunset.
 * Details, including how the degrees were calculated can be seen in the documentation of
 * [bainHashmashosYereim3Point05Degrees].
 *
 * @return the `Date` of the sun's position 2.1 minutes before sunset. If the calculation can't
 * be computed such as in the Arctic Circle where there is at least one day a year where the sun does not
 * rise, and one where it does not set, a null will be returned. See detailed explanation on top of the
 * [AstronomicalCalendar] documentation.
 *
 * @see ZENITH_MINUS_2_POINT_1
 *
 * @see bainHashmashosYereim13Point5Minutes
 * @see bainHashmashosYereim2Point8Degrees
 * @see bainHashmashosYereim3Point05Degrees
 */
@property (readonly) STTZmanDateBased *bainHashmashosYereim2Point1Degrees __attribute__((swift_name("bainHashmashosYereim2Point1Degrees")));

/**
 * This method returns the beginning of *bain hashmashos* (twilight) according to the [Yereim (Rabbi Eliezer of Metz)](https://en.wikipedia.org/wiki/Eliezer_ben_Samuel) calculated as the sun's
 * position 2.8 above the horizon [around the equinox / equilux](https://kosherjava.com/2022/01/12/equinox-vs-equilux-zmanim-calculations/),
 * its position 16.875 minutes or 3/4 of an 18-minute *Mil* before sunset. According to the Yereim, *bain
 * hashmashos* starts 3/4 of a *Mil* before sunset and *tzais* or nightfall starts at sunset.
 * Details, including how the degrees were calculated can be seen in the documentation of
 * [bainHashmashosYereim3Point05Degrees].
 *
 * @return the `Date` of the sun's position 2.8 minutes before sunset. If the calculation can't
 * be computed such as in the Arctic Circle where there is at least one day a year where the sun does not
 * rise, and one where it does not set, a null will be returned. See detailed explanation on top of the
 * [AstronomicalCalendar] documentation.
 *
 * @see ZENITH_MINUS_2_POINT_8
 *
 * @see bainHashmashosYereim16Point875Minutes
 * @see bainHashmashosYereim3Point05Degrees
 * @see bainHashmashosYereim2Point1Degrees
 */
@property (readonly) STTZmanDateBased *bainHashmashosYereim2Point8Degrees __attribute__((swift_name("bainHashmashosYereim2Point8Degrees")));

/**
 * This method returns the beginning of *bain hashmashos* (twilight) according to the [Yereim (Rabbi Eliezer of Metz)](https://en.wikipedia.org/wiki/Eliezer_ben_Samuel) calculated as the sun's
 * position 3.05 above the horizon [around the equinox / equilux](https://kosherjava.com/2022/01/12/equinox-vs-equilux-zmanim-calculations/),
 * its position 18 minutes or 3/4 of a 24-minute *mil* before sunset. According to the Yereim, *bain
 * hashmashos* starts 3/4 of a *Mil* before sunset, and *tzais* /nightfall starts at sunset.
 * Note that *lechumra* (of about 14 seconds) a refraction value of 0.5166 as opposed to the traditional
 * 0.566 is used. This is more inline with the actual refraction in *Eretz Yisrael* and is brought down
 * by [Rabbi Yedidya Manet](http://beinenu.com/rabbis/%D7%94%D7%A8%D7%91-%D7%99%D7%93%D7%99%D7%93%D7%99%D7%94-%D7%9E%D7%A0%D7%AA) in his [Zmanei Halacha Lema’aseh](https://www.nli.org.il/en/books/NNL_ALEPH002542826/NLI) (p. 11). That is the first source that I am aware of that calculates degree-based Yereim
 * *zmanim*. The 0.5166 refraction is also used by the [Luach Itim Lebinah](https://zmanim.online/). Calculating the Yereim's *bain hashmashos* using 18-minute based degrees is also suggested
 * in the upcoming 8th edition of the zmanim Kehilchasam. For more details, see the article [The Yereim’s *Bein Hashmashos*](https://kosherjava.com/2020/12/07/the-yereims-bein-hashmashos/).
 *
 * @todo recalculate based on equinox/equilux
 * @return the `Date` of the sun's position 3.05 minutes before sunset. If the calculation can't
 * be computed such as in the Arctic Circle where there is at least one day a year where the sun does not
 * rise, and one where it does not set, a null will be returned. See detailed explanation on top of the
 * [AstronomicalCalendar] documentation.
 *
 * @see ZENITH_MINUS_3_POINT_05
 *
 * @see bainHashmashosYereim18Minutes
 * @see bainHashmashosYereim2Point8Degrees
 * @see bainHashmashosYereim2Point1Degrees
 */
@property (readonly) STTZmanDateBased *bainHashmashosYereim3Point05Degrees __attribute__((swift_name("bainHashmashosYereim3Point05Degrees")));

/**
 * A method that returns the local time for fixed *chatzos*. This time is noon and midnight adjusted from
 * standard time to account for the local latitude. The 360 of the globe divided by 24 calculates to 15
 * per hour with 4 minutes per degree, so at a longitude of 0 , 15, 30 etc... *Chatzos* is at exactly 12:00
 * noon. This is the time of *chatzos* according to the [Aruch Hashulchan](https://en.wikipedia.org/wiki/Aruch_HaShulchan) in [Orach Chaim 233:14](https://hebrewbooks.org/pdfpager.aspx?req=7705&pgnum=426) and [Rabbi Moshe Feinstein](https://en.wikipedia.org/wiki/Moshe_Feinstein) in Igros Moshe [Orach Chaim 1:24](https://hebrewbooks.org/pdfpager.aspx?req=916&st=&pgnum=67) and [2:20](https://hebrewbooks.org/pdfpager.aspx?req=14675&pgnum=191).
 * Lakewood, N.J., with a longitude of -74.2094, is 0.7906 away from the closest multiple of 15 at -75. This
 * is multiplied by 4 to yield 3 minutes and 10 seconds for a *chatzos* of 11:56:50. This method is not tied
 * to the theoretical 15 timezones, but will adjust to the actual timezone and [Daylight saving time](https://en.wikipedia.org/wiki/Daylight_saving_time).
 *
 * @return the Date representing the local *chatzos*, or null if [geoLocation].[timeZone][GeoLocation.timeZone] is null
 * @see GeoLocation.localMeanTimeOffset
 */
@property (readonly) STTZmanDateBased *fixedLocalChatzos __attribute__((swift_name("fixedLocalChatzos")));
@property STTJewishCalendar *jewishCalendar __attribute__((swift_name("jewishCalendar")));
@property STTKotlinx_datetimeLocalDateTime *localDateTime __attribute__((swift_name("localDateTime")));

/**
 * This method returns the time of *mincha gedola* according to the Magen Avraham with the day starting and
 * ending 16.1 below the horizon. This is the earliest time to pray *mincha*. For more information on
 * this see the documentation on [*mincha gedola*][.getMinchaGedola]. This is calculated as 6.5
 * [solar hours][temporalHour] after *alos*. The calculation used is 6.5 *
 * [shaahZmanis16Point1Degrees] after [*alos*][alos16Point1Degrees].
 *
 * @see shaahZmanis16Point1Degrees
 * @see .getMinchaGedola
 * @see .getMinchaKetana
 * @return the `Date` of the time of *mincha gedola*. If the calculation can't be computed such as
 * northern and southern locations even south of the Arctic Circle and north of the Antarctic Circle where
 * the sun  may not reach low enough below the horizon for this calculation, a null will be returned. See
 * detailed explanation on top of the [AstronomicalCalendar] documentation.
 */
@property (readonly) STTZmanDateBased *minchaGedola16Point1Degrees __attribute__((swift_name("minchaGedola16Point1Degrees")));

/**
 * This method returns *mincha gedola* calculated as 30 minutes after [*chatzos*][chatzos]
 * and not 1/2 of a [*shaah zmanis*][shaahZmanisGra] after [*chatzoschatzos] as
 * calculated by [minchaGedola].
 *
 * Some use this time to delay the start of *mincha* in the winter when 1/2 of a [*shaah zmanis*][shaahZmanisGra]
 * is less than 30 minutes.
 *
 * See [minchaGedolaGreaterThan30] for a convenience method that returns the later of the 2 calculations.
 *
 * One should not use this time to start *mincha* before the standard [*mincha gedola*][minchaGedola].
 * See Shulchan Aruch [Orach Chayim 234:1](https://hebrewbooks.org/pdfpager.aspx?req=49624&st=&pgnum=291) and
 * the Shaar Hatziyon *seif katan ches*.
 *
 * @return the `Date` of 30 minutes after *chatzos*. If the calculation can't be computed such as
 * in the Arctic Circle where there is at least one day a year where the sun does not rise, and one where it
 * does not set, a null will be returned. See detailed explanation on top of the
 * [AstronomicalCalendar] documentation.
 * @see .getMinchaGedola
 * @see .getMinchaGedolaGreaterThan30
 */
@property (readonly) STTZmanDateBased *minchaGedola30Minutes __attribute__((swift_name("minchaGedola30Minutes")));

/**
 * This method returns the time of *mincha gedola* according to the Magen Avraham with the day starting 72
 * minutes before sunrise and ending 72 minutes after sunset. This is the earliest time to pray *mincha*. For
 * more information on this see the documentation on [*mincha gedola*][.getMinchaGedola]. This is
 * calculated as 6.5 [solar hours][temporalHour] after *alos*. The calculation used is 6.5 *
 * [shaahZmanis72Minutes] after [*alos*][alos72].
 *
 * @see alos72
 * @see .getMinchaGedola
 * @see .getMinchaKetana
 * @see ZmanimCalendar.getMinchaGedola
 * @return the `Date` of the time of *mincha gedola*. If the calculation can't be computed such as
 * in the Arctic Circle where there is at least one day a year where the sun does not rise, and one where it
 * does not set, a null will be returned. See detailed explanation on top of the [AstronomicalCalendar]
 * documentation.
 */
@property (readonly) STTZmanDateBased *minchaGedola72Minutes __attribute__((swift_name("minchaGedola72Minutes")));

/**
 * This method returns the time of *mincha gedola* based on the opinion of [Rabbi Yaakov Moshe Hillel](https://en.wikipedia.org/wiki/Yaakov_Moshe_Hillel) as published in the *luach*
 * of the Bais Horaah of Yeshivat Chevrat Ahavat Shalom.
 *
 * It will return the later time of the following two options:
 * - half a *shaah zmanis* after *chatzos*
 *     - with *shaos zmaniyos* calculated based on:
 *          - a day starting 72 minutes before sunrise [*alos* 16.1˚][alos16Point1Degrees] and
 *          - ending 13.5 minutes after sunset [tzaisGeonim3Point7Degrees].
 * - 30 clock minutes after *chatzos*
 *
 * See [minchaGedolaGreaterThan30] (though that calculation is based on *mincha gedola* GRA).
 * *Mincha gedola* is the earliest time to pray *mincha*. For more information about *mincha gedola* see the documentation on [*mincha gedola*][minchaGedola].
 *
 * @return the `Date` of the *mincha gedola*. If the calculation can't be computed such as northern and
 * southern locations even south of the Arctic Circle and north of the Antarctic Circle where the sun may not
 * reach low enough below the horizon for this calculation, a null will be returned. See detailed explanation
 * on top of the [AstronomicalCalendar] documentation.
 *
 * @see alos16Point1Degrees
 * @see tzaisGeonim3Point7Degrees
 * @see shaahZmanisAlos16Point1ToTzais3Point7
 * @see minchaGedolaGreaterThan30
 */
@property (readonly) STTZmanDateBased *minchaGedolaAhavatShalom __attribute__((swift_name("minchaGedolaAhavatShalom")));

/**
 * This method returns the time of *mincha gedola* based on the calculation of *Chacham* Yosef
 * Harari-Raful of Yeshivat Ateret Torah, that the day starts [1/10th of the day][alos72Zmanis]
 * before sunrise and is usually calculated as ending [40 minutes after sunset][tzaisAteretTorah]
 * (configurable to any offset via [.setAteretTorahSunsetOffset]). This is the preferred earliest
 * time to pray *mincha* according to the opinion of the [Rambam](https://en.wikipedia.org/wiki/Maimonides) and others. For more information on this see the documentation on [*mincha][.getMinchaGedola]. This is calculated as 6.5 [solar hours][shaahZmanisAteretTorah] after *alos*. The
 * calculation used is 6.5 * [shaahZmanisAteretTorah] after [*alos*][alos72Zmanis].
 *
 * @see alos72Zmanis
 * @see tzaisAteretTorah
 * @see shaahZmanisAteretTorah
 * @see .getMinchaGedola
 * @see .getMinchaKetanaAteretTorah
 * @see ZmanimCalendar.getMinchaGedola
 * @see ateretTorahSunsetOffset
 * @see .setAteretTorahSunsetOffset
 * @return the `Date` of the time of *mincha gedola*. If the calculation can't be computed such as
 * in the Arctic Circle where there is at least one day a year where the sun does not rise, and one where it
 * does not set, a null will be returned. See detailed explanation on top of the [AstronomicalCalendar]
 * documentation.
 */
@property (readonly) STTZmanDateBased *minchaGedolaAteretTorah __attribute__((swift_name("minchaGedolaAteretTorah")));

/**
 * This method returns the time of *mincha gedola*. *Mincha gedola* is the earliest time one can pray
 * *mincha*. The [Rambam](https://en.wikipedia.org/wiki/Maimonides) is of the opinion that it is
 * better to delay *mincha* until [*mincha ketana*][.getMinchaKetanaBaalHatanya] while the
 * [Ra"sh](https://en.wikipedia.org/wiki/Asher_ben_Jehiel),
 * [Tur](https://en.wikipedia.org/wiki/Jacob_ben_Asher), [GRA](https://en.wikipedia.org/wiki/Vilna_Gaon) and others are of the opinion that *mincha* can be prayed
 * *lechatchila* starting at *mincha gedola*. This is calculated as 6.5 [sea level solar hours][shaahZmanisBaalHatanya] after [*netz amiti* (sunrise)][sunriseBaalHatanya]. This calculation is based
 * on the opinion of the Baal Hatanya that the day is calculated from sunrise to sunset. This returns the time 6.5
 * * [shaahZmanisBaalHatanya] after [*netz amiti* (&quot;real&quot; sunrise)][sunriseBaalHatanya].
 *
 * @see .getMinchaGedola
 * @see shaahZmanisBaalHatanya
 * @see .getMinchaKetanaBaalHatanya
 * @return the `Date` of the time of *mincha gedola*. If the calculation can't be computed such as
 * in the Arctic Circle where there is at least one day a year where the sun does not rise, and one where it
 * does not set, a null will be returned. See detailed explanation on top of the [AstronomicalCalendar]
 * documentation.
 */
@property (readonly) STTZmanDateBased *minchaGedolaBaalHatanya __attribute__((swift_name("minchaGedolaBaalHatanya")));

/**
 * This is a convenience method that returns the later of [minchaGedolaBaalHatanya] and
 * [minchaGedola30Minutes]. In the winter when 1/2 of a [*shaah zmanis*][shaahZmanisBaalHatanya] is less than 30 minutes [minchaGedola30Minutes] will be returned, otherwise
 * [minchaGedolaBaalHatanya] will be returned.
 *
 * @return the `Date` of the later of [minchaGedolaBaalHatanya] and [minchaGedola30Minutes].
 * If the calculation can't be computed such as in the Arctic Circle where there is at least one day a year
 * where the sun does not rise, and one where it does not set, a null will be returned. See detailed
 * explanation on top of the [AstronomicalCalendar] documentation.
 */
@property (readonly) STTZmanDateBased *minchaGedolaBaalHatanyaGreaterThan30 __attribute__((swift_name("minchaGedolaBaalHatanyaGreaterThan30")));

/**
 * This method returns [Rav Moshe Feinstein's](https://en.wikipedia.org/wiki/Moshe_Feinstein) opinion of
 * the calculation of *mincha gedola*, the earliest time one can pray *mincha* [GRA](https://en.wikipedia.org/wiki/Vilna_Gaon) that is 30 minutes after [fixed][fixedLocalChatzos].
 *
 * @return the `Date` of the time of *mincha gedola*. If the calculation can't be computed such as
 * in the Arctic Circle where there is at least one day a year where the sun does not rise, and one where it
 * does not set, a null will be returned. See detailed explanation on top of the [AstronomicalCalendar]
 * documentation.
 *
 * @see .getMinchaGedola
 * @see fixedLocalChatzos
 * @see .getMinchaKetanaGRAFixedLocalChatzosToSunset
 */
@property (readonly) STTZmanDateBased *minchaGedolaGRAFixedLocalChatzos30Minutes __attribute__((swift_name("minchaGedolaGRAFixedLocalChatzos30Minutes")));

/**
 * This is a convenience method that returns the later of [minchaGedola] and
 * [minchaGedola30Minutes]. In the winter when 1/2 of a [*shaah zmanis*][shaahZmanisGra] is
 * less than 30 minutes [minchaGedola30Minutes] will be returned, otherwise [minchaGedola]
 * will be returned.
 *
 * @return the `Date` of the later of [.getMinchaGedola] and [.getMinchaGedola30Minutes].
 * If the calculation can't be computed such as in the Arctic Circle where there is at least one day a year
 * where the sun does not rise, and one where it does not set, a null will be returned. See detailed
 * explanation on top of the [AstronomicalCalendar] documentation.
 */
@property (readonly) STTZmanDateBased *minchaGedolaGreaterThan30 __attribute__((swift_name("minchaGedolaGreaterThan30")));

/**
 * This method returns the time of *mincha ketana* according to the Magen Avraham with the day starting and
 * ending 16.1 below the horizon. This is the preferred earliest time to pray *mincha* according to the
 * opinion of the [Rambam](https://en.wikipedia.org/wiki/Maimonides) and others. For more information on
 * this see the documentation on [*mincha gedola*][.getMinchaGedola]. This is calculated as 9.5
 * [solar hours][temporalHour] after *alos*. The calculation used is 9.5 *
 * [shaahZmanis16Point1Degrees] after [*alos*][alos16Point1Degrees].
 *
 * @see shaahZmanis16Point1Degrees
 * @see .getMinchaGedola
 * @see .getMinchaKetana
 * @return the `Date` of the time of *mincha ketana*. If the calculation can't be computed such
 * as northern and southern locations even south of the Arctic Circle and north of the Antarctic Circle
 * where the sun may not reach low enough below the horizon for this calculation, a null will be returned.
 * See detailed explanation on top of the [AstronomicalCalendar] documentation.
 */
@property (readonly) STTZmanDateBased *minchaKetana16Point1Degrees __attribute__((swift_name("minchaKetana16Point1Degrees")));

/**
 * This method returns the time of *mincha ketana* according to the Magen Avraham with the day
 * starting 72 minutes before sunrise and ending 72 minutes after sunset. This is the preferred earliest time to pray
 * *mincha* according to the opinion of the [Rambam](https://en.wikipedia.org/wiki/Maimonides)
 * and others. For more information on this see the documentation on [*mincha gedola*][.getMinchaGedola].
 * This is calculated as 9.5 [shaahZmanis72Minutes] after *alos*. The calculation used is 9.5 *
 * [shaahZmanis72Minutes] after [*alos*][alos72].
 *
 * @see shaahZmanis16Point1Degrees
 * @see .getMinchaGedola
 * @see .getMinchaKetana
 * @return the `Date` of the time of *mincha ketana*. If the calculation can't be computed such as
 * in the Arctic Circle where there is at least one day a year where the sun does not rise, and one where it
 * does not set, a null will be returned. See detailed explanation on top of the [AstronomicalCalendar]
 * documentation.
 */
@property (readonly) STTZmanDateBased *minchaKetana72Minutes __attribute__((swift_name("minchaKetana72Minutes")));

/**
 * This method returns the time of *mincha ketana* based on the opinion of [Rabbi Yaakov Moshe Hillel](https://en.wikipedia.org/wiki/Yaakov_Moshe_Hillel) as published in the *luach*
 * of the Bais Horaah of Yeshivat Chevrat Ahavat Shalom that *mincha ketana* is calculated as 2.5 *shaos
 * zmaniyos* before [*tzais* 3.8˚][tzaisGeonim3Point8Degrees] with *shaos zmaniyos*
 * calculated based on a day starting at [*alos* 16.1˚][alos16Point1Degrees] and ending at
 * *tzais* 3.8. *Mincha ketana* is the preferred earliest time to pray *mincha* according to
 * the opinion of the [Rambam](https://en.wikipedia.org/wiki/Maimonides) and others. For more information
 * on this see the documentation on [*mincha ketana*][.getMinchaKetana].
 *
 * @return the the `Date` of the time of *mincha ketana*. If the calculation can't be computed such as northern
 * and southern locations even south of the Arctic Circle and north of the Antarctic Circle where the sun may not
 * reach low enough below the horizon for this calculation, a null will be returned. See detailed explanation
 * on top of the [AstronomicalCalendar] documentation.
 *
 * @see shaahZmanisAlos16Point1ToTzais3Point8
 * @see .getMinchaGedolaAhavatShalom
 * @see .getPlagAhavatShalom
 */
@property (readonly) STTZmanDateBased *minchaKetanaAhavatShalom __attribute__((swift_name("minchaKetanaAhavatShalom")));

/**
 * This method returns the time of *mincha ketana* based on the calculation of
 * *Chacham* Yosef Harari-Raful of Yeshivat Ateret Torah, that the day starts
 * [1/10th of the day][alos72Zmanis] before sunrise and is usually calculated as ending
 * [40 minutes after sunset][tzaisAteretTorah] (configurable to any offset via
 * [.setAteretTorahSunsetOffset]). This is the preferred earliest time to pray *mincha*
 * according to the opinion of the [Rambam](https://en.wikipedia.org/wiki/Maimonides) and others.
 * For more information on this see the documentation on [*mincha gedola*][.getMinchaGedola]. This is
 * calculated as 9.5 [solar hours][shaahZmanisAteretTorah] after [*alos*][alos72Zmanis].
 * The calculation used is 9.5 * [shaahZmanisAteretTorah] after [*alos*][alos72Zmanis].
 *
 * @see alos72Zmanis
 * @see tzaisAteretTorah
 * @see shaahZmanisAteretTorah
 * @see ateretTorahSunsetOffset
 * @see .setAteretTorahSunsetOffset
 * @see .getMinchaGedola
 * @see .getMinchaKetana
 * @return the `Date` of the time of *mincha ketana*. If the calculation can't be computed such as
 * in the Arctic Circle where there is at least one day a year where the sun does not rise, and one where it
 * does not set, a null will be returned. See detailed explanation on top of the [AstronomicalCalendar]
 * documentation.
 */
@property (readonly) STTZmanDateBased *minchaKetanaAteretTorah __attribute__((swift_name("minchaKetanaAteretTorah")));

/**
 * This method returns the time of *mincha ketana*. This is the preferred earliest time to pray
 * *mincha* in the opinion of the [Rambam](https://en.wikipedia.org/wiki/Maimonides) and others.
 * For more information on this see the documentation on [*mincha gedola*][.getMinchaGedolaBaalHatanya].
 * This is calculated as 9.5 [sea level solar hours][shaahZmanisBaalHatanya] after [*netz amiti* (sunrise)][sunriseBaalHatanya]. This calculation is calculated based on the opinion of the Baal Hatanya that the
 * day is calculated from sunrise to sunset. This returns the time 9.5 * [shaahZmanisBaalHatanya] after [sunriseBaalHatanya].
 *
 * @see .getMinchaKetana
 * @see shaahZmanisBaalHatanya
 * @see .getMinchaGedolaBaalHatanya
 * @return the `Date` of the time of *mincha ketana*. If the calculation can't be computed such as
 * in the Arctic Circle where there is at least one day a year where the sun does not rise, and one where it
 * does not set, a null will be returned. See detailed explanation on top of the [AstronomicalCalendar]
 * documentation.
 */
@property (readonly) STTZmanDateBased *minchaKetanaBaalHatanya __attribute__((swift_name("minchaKetanaBaalHatanya")));

/**
 * This method returns [Rav Moshe Feinstein's](https://en.wikipedia.org/wiki/Moshe_Feinstein) opinion
 * of the calculation of *mincha ketana* (the preferred time to recite the *mincha prayers* according to
 * the opinion of the [Rambam](https://en.wikipedia.org/wiki/Maimonides) and others) calculated according
 * to the [GRA](https://en.wikipedia.org/wiki/Vilna_Gaon) that is 3.5 *shaos zmaniyos* (solar
 * hours) after [fixed local chatzos][fixedLocalChatzos].
 *
 * @return the `Date` of the time of *mincha gedola*. If the calculation can't be computed such as
 * in the Arctic Circle where there is at least one day a year where the sun does not rise, and one where it
 * does not set, a null will be returned. See detailed explanation on top of the [AstronomicalCalendar]
 * documentation.
 *
 * @see .getMinchaGedola
 * @see fixedLocalChatzos
 * @see .getMinchaGedolaGRAFixedLocalChatzos30Minutes
 */
@property (readonly) STTZmanDateBased *minchaKetanaGRAFixedLocalChatzosToSunset __attribute__((swift_name("minchaKetanaGRAFixedLocalChatzosToSunset")));

/**
 * This method returns *misheyakir* based on the position of the sun when it is [10.2˚][ZENITH_10_POINT_2] below [geometric zenith][AstronomicalCalendar.GEOMETRIC_ZENITH] (90). This calculation is used for calculating
 * *misheyakir* according to some opinions. This calculation is based on the position of the sun 45 minutes
 * before [sunrise] in Jerusalem [around the equinox](https://kosherjava.com/2022/01/12/equinox-vs-equilux-zmanim-calculations/) which calculates
 * to 10.2 below [geometric zenith][AstronomicalCalendar.GEOMETRIC_ZENITH].
 *
 * @return the `Date` of *misheyakir*. If the calculation can't be computed such as
 * northern and southern locations even south of the Arctic Circle and north of the Antarctic Circle where
 * the sun may not reach low enough below the horizon for this calculation, a null will be returned. See
 * detailed explanation on top of the [AstronomicalCalendar] documentation.
 * @see ZENITH_10_POINT_2
 */
@property (readonly) STTZmanDateBased *misheyakir10Point2Degrees __attribute__((swift_name("misheyakir10Point2Degrees")));

/**
 * This method returns *misheyakir* based on the position of the sun when it is [11˚][ZENITH_11_DEGREES] below [geometric zenith][AstronomicalCalendar.GEOMETRIC_ZENITH] (90). This calculation is used for calculating
 * *misheyakir* according to some opinions. This calculation is based on the position of the sun 48 minutes
 * before [sunrise] in Jerusalem [around the equinox / equilux](https://kosherjava.com/2022/01/12/equinox-vs-equilux-zmanim-calculations/),
 * which calculates to 11 below [geometric zenith][AstronomicalCalendar.GEOMETRIC_ZENITH].
 *
 * @return If the calculation can't be computed such as northern and southern locations even south of the Arctic
 * Circle and north of the Antarctic Circle where the sun may not reach low enough below the horizon for
 * this calculation, a null will be returned. See detailed explanation on top of the
 * [AstronomicalCalendar] documentation.
 * @see ZENITH_11_DEGREES
 */
@property (readonly) STTZmanDateBased *misheyakir11Degrees __attribute__((swift_name("misheyakir11Degrees")));

/**
 * This method returns *misheyakir* based on the position of the sun when it is [11.5˚][ZENITH_11_DEGREES] below [geometric zenith][AstronomicalCalendar.GEOMETRIC_ZENITH] (90).
 * This calculation is used for calculating *misheyakir* according to some opinions.
 * This calculation is based on the position of the sun 52 minutes before [sunrise] in Jerusalem [around the equinox / equilux](https://kosherjava.com/2022/01/12/equinox-vs-equilux-zmanim-calculations/),
 * which calculates to 11.5 below [geometric zenith][AstronomicalCalendar.GEOMETRIC_ZENITH].
 * @todo recalculate.
 *
 * @return the `Date` of *misheyakir*. If the calculation can't be computed such as northern and
 * southern locations even south of the Arctic Circle and north of the Antarctic Circle where the sun may
 * not reach low enough below the horizon for this calculation, a null will be returned. See detailed
 * explanation on top of the [AstronomicalCalendar] documentation.
 * @see ZENITH_11_POINT_5
 */
@property (readonly) STTZmanDateBased *misheyakir11Point5Degrees __attribute__((swift_name("misheyakir11Point5Degrees")));

/**
 * This method returns *misheyakir* based on the position of the sun when it is [7.65˚][ZENITH_7_POINT_65] below [geometric zenith][AstronomicalCalendar.GEOMETRIC_ZENITH] (90).
 * The degrees are based on a 35/36 minute *zman* [around the equinox / equilux](https://kosherjava.com/2022/01/12/equinox-vs-equilux-zmanim-calculations/),
 * when the *neshef* (twilight) is the shortest.
 *
 * **Sources:**
 * - This time is based on [Rabbi Moshe Feinstein](https://en.wikipedia.org/wiki/Moshe_Feinstein) who writes in [Ohr Hachaim Vol. 4, Ch. 6](https://hebrewbooks.org/pdfpager.aspx?req=14677&pgnum=7))
 * that *misheyakir* in New York is 35-40 minutes before sunset, something that is a drop less than 8.
 * - [Rabbi Yisroel Taplin](https://en.wikipedia.org/wiki/Yisroel_Taplin) in [Zmanei Yisrael](https://www.worldcat.org/oclc/889556744) (page 117) notes that [Rabbi Yaakov Kamenetsky](https://en.wikipedia.org/wiki/Yaakov_Kamenetsky) stated that it is not less than 36
 * minutes before sunrise (maybe it is 40 minutes).
 * - Sefer Yisrael Vehazmanim (p. 7) quotes the Tamar Yifrach in the name of the [Satmar Rov](https://en.wikipedia.org/wiki/Joel_Teitelbaum) that one should be stringent
 * not consider *misheyakir* before 36 minutes.
 * - This is also the accepted [minhag](https://en.wikipedia.org/wiki/Minhag) in [Lakewood](https://en.wikipedia.org/wiki/Lakewood_Township,_New_Jersey) that is used in the [Yeshiva](https://en.wikipedia.org/wiki/Beth_Medrash_Govoha).
 * - This follows the opinion of [Rabbi Shmuel Kamenetsky](https://en.wikipedia.org/wiki/Shmuel_Kamenetsky) who provided the time of 35/36 minutes,
 * but did not provide a degree-based time.
 *
 * Since this *zman* depends on the level of light, Rabbi Yaakov Shakow presented this degree-based calculations to Rabbi Kamenetsky who agreed to them.
 *
 * @return the `Date` of *misheyakir*. If the calculation can't be computed such as
 * northern and southern locations even south of the Arctic Circle and north of the Antarctic Circle where
 * the sun may not reach low enough below the horizon for this calculation, a null will be returned. See
 * detailed explanation on top of the [AstronomicalCalendar] documentation.
 *
 * @see ZENITH_7_POINT_65
 *
 * @see misheyakir9Point5Degrees
 */
@property (readonly) STTZmanDateBased *misheyakir7Point65Degrees __attribute__((swift_name("misheyakir7Point65Degrees")));

/**
 * This method returns *misheyakir* based on the position of the sun when it is [9.5˚][ZENITH_9_POINT_5] below [geometric zenith][AstronomicalCalendar.GEOMETRIC_ZENITH] (90).
 *
 * **Sources:**
 * This calculation is based on
 * - Rabbi Dovid Kronglass's calculation of 45 minutes in Baltimore as mentioned in [Divrei Chachamim No. 24](https://hebrewbooks.org/pdfpager.aspx?req=20287&pgnum=29)
 * - brought down by Rabbi Yechiel Avraham Zilber's [Birur Halacha, Tinyana, Ch. 18](https://hebrewbooks.org/pdfpager.aspx?req=50535&pgnum=87).
 *     - This calculates to 9.5.
 * - Also see [Rabbi Yaakov Yitzchok Neiman](https://en.wikipedia.org/wiki/Jacob_Isaac_Neiman)
 * in Kovetz Eitz Chaim Vol. 9, p. 202 that the Vya'an Yosef (Rebbe of Pupa - [ZmanAuthority.GREENWALD]) did not want to rely on times earlier than 45 minutes in New York.
 * - This *zman* is also used in the calendars published by Rabbi Hershel Edelstein.
 * - As mentioned in Yisroel Vehazmanim, Rabbi Edelstein who was given the 45 minute *zman* by Rabbi Avraham Yehoshua Bick.
 * - The calendars published by the *[Edot Hamizrach](https://en.wikipedia.org/wiki/Mizrahi_Jews)* communities also use this *zman*.
 * - This also follows the opinion of [Rabbi Shmuel Kamenetsky](https://en.wikipedia.org/wiki/Shmuel_Kamenetsky) who provided
 * the time of 36 and 45 minutes, but did not provide a degree-based time.
 *
 * Since this *zman* depends on the level of light, Rabbi Yaakov Shakow presented these degree-based times to Rabbi Shmuel Kamenetsky who agreed to them.
 *
 * @return the `Date` of *misheyakir*. If the calculation can't be computed such as
 * northern and southern locations even south of the Arctic Circle and north of the Antarctic Circle where
 * the sun may not reach low enough below the horizon for this calculation, a null will be returned. See
 * detailed explanation on top of the [AstronomicalCalendar] documentation.
 *
 * @see ZENITH_9_POINT_5
 *
 * @see misheyakir7Point65Degrees
 */
@property (readonly) STTZmanDateBased *misheyakir9Point5Degrees __attribute__((swift_name("misheyakir9Point5Degrees")));

/**
 * This method returns the time of *plag hamincha* (the earliest time that Shabbos can be started) based on the
 * opinion of [Rabbi Yaakov Moshe Hillel](https://en.wikipedia.org/wiki/Yaakov_Moshe_Hillel) as published in
 * the *luach* of the Bais Horaah of Yeshivat Chevrat Ahavat Shalom that that *plag hamincha* is calculated
 * as 1.25 *shaos zmaniyos* before [*tzais* 3.8˚][tzaisGeonim3Point8Degrees] with *shaos
 * zmaniyos* calculated based on a day starting at [*alos* 16.1˚][alos16Point1Degrees] and
 * ending at *tzais* 3.8.
 *
 * @return the `Date` of the *plag*. If the calculation can't be computed such as northern and
 * southern locations even south of the Arctic Circle and north of the Antarctic Circle where the sun may not
 * reach low enough below the horizon for this calculation, a null will be returned. See detailed explanation
 * on top of the [AstronomicalCalendar] documentation.
 *
 * @see shaahZmanisAlos16Point1ToTzais3Point8
 * @see .getMinchaGedolaAhavatShalom
 * @see .getMinchaKetanaAhavatShalom
 */
@property (readonly) STTZmanDateBased *plagAhavatShalom __attribute__((swift_name("plagAhavatShalom")));

/**
 * This method returns the time of *plag hamincha* based on the opinion that the day starts at
 * [*alos* 16.1˚][alos16Point1Degrees] and ends at [*tzais*][tzaisGeonim7Point083Degrees]. 10.75 *shaos zmaniyos* are calculated based on this day and added to [][alos16Point1Degrees] to reach this time. This time is 10.75 *shaos zmaniyos* (temporal
 * hours) after [dawn][alos16Point1Degrees] based on the opinion that the day is calculated from a
 * [dawn][alos16Point1Degrees] of 16.1 degrees before sunrise to
 * [*tzais*][tzaisGeonim7Point083Degrees] . This returns the time of 10.75 * the calculated
 * *shaah zmanis* after [dawn][alos16Point1Degrees].
 *
 * @return the `Date` of the *plag*. If the calculation can't be computed such as northern and
 * southern locations even south of the Arctic Circle and north of the Antarctic Circle where the sun may not
 * reach low enough below the horizon for this calculation, a null will be returned. See detailed explanation
 * on top of the [AstronomicalCalendar] documentation.
 *
 * @see alos16Point1Degrees
 * @see tzaisGeonim7Point083Degrees
 */
@property (readonly) STTZmanDateBased *plagAlos16Point1ToTzaisGeonim7Point083Degrees __attribute__((swift_name("plagAlos16Point1ToTzaisGeonim7Point083Degrees")));

/**
 * This method should be used *lechumra* only and returns the time of *plag hamincha* based on the opinion
 * that the day starts at [*alos* 16.1˚][alos16Point1Degrees] and ends at [sunset].
 * 10.75 *shaos zmaniyos* are calculated based on this day and added to [*alos*][alos16Point1Degrees] to reach this time. This time is 10.75 *shaos zmaniyos* (temporal hours) after [alos16Point1Degrees] based on the opinion that the day is calculated from a [dawn][alos16Point1Degrees] of 16.1 degrees before sunrise to [sea level sunset][seaLevelSunset]. This returns the time of 10.75 *
 * the calculated *shaah zmanis* after [dawn][alos16Point1Degrees]. Since *plag* by this
 * calculation can occur after sunset, it should only be used *lechumra*.
 *
 * @return the `Date` of the *plag*. If the calculation can't be computed such as northern and southern
 * locations even south of the Arctic Circle and north of the Antarctic Circle where the sun may not reach
 * low enough below the horizon for this calculation, a null will be returned. See detailed explanation on
 * top of the [AstronomicalCalendar] documentation.
 *
 * @see alos16Point1Degrees
 * @see .seaLevelSunset
 */
@property (readonly) STTZmanDateBased *plagAlosToSunset __attribute__((swift_name("plagAlosToSunset"))) __attribute__((deprecated("This method should be used <em>lechumra</em> only since it returns a very late time, and if used\n	          <em>lekula</em> can result in <em>chillul Shabbos</em> etc. There is no current plan to remove this\n	          method from the API, and this deprecation is intended to alert developers of the danger of using it.\n	  \n	  ")));

/**
 * This method should be used *lechumra* only and returns the time of *plag hamincha* according to the
 * [Magen Avraham (MGA)](https://en.wikipedia.org/wiki/Avraham_Gombinern).
 *
 * Day in this calculation starts 120 minutes before sunrise and ends 120 minutes after sunset.
 * This is calculated as 10.75 hours after [dawn 120 minutes][alos120].
 * The formula used is 10.75 [shaahZmanis120Minutes] after [alos120].
 * Since the *zman* based on an extremely early *alos* and a very late *tzais*, it should only be used *lechumra*.
 *
 * @return the `Date` of the time of *plag hamincha*. If the calculation can't be computed such as
 * in the Arctic Circle where there is at least one day a year where the sun does not rise, and one where it
 * does not set, a null will be returned. See detailed explanation on top of the
 * [AstronomicalCalendar] documentation.
 *
 * @see shaahZmanis120Minutes
 * @see .getPlagHamincha26Degrees
 */
@property (readonly) STTZmanDateBased *plagHamincha120Minutes __attribute__((swift_name("plagHamincha120Minutes")));

/**
 * This method should be used *lechumra* only and returns the time of *plag hamincha* based on sunrise
 * being 120 minutes *zmaniyos* or 1/6th of the day before sunrise. This is calculated as 10.75 hours after
 * [dawn][alos120Zmanis]. The formula used is 10.75 * [shaahZmanis120MinutesZmanis] after
 * [dawn][alos120Zmanis]. Since the *zman* based on an extremely early *alos* and a very
 * late *tzais*, it should only be used *lechumra*.
 *
 * @return the `Date` of the time of *plag hamincha*. If the calculation can't be computed such as
 * in the Arctic Circle where there is at least one day a year where the sun does not rise, and one where it
 * does not set, a null will be returned. See detailed explanation on top of the
 * [AstronomicalCalendar] documentation.
 *
 * @see shaahZmanis120MinutesZmanis
 * @see alos120
 * @see tzais120
 * @see plagHamincha26Degrees
 * @see plagHamincha120Minutes
 */
@property (readonly) STTZmanDateBased *plagHamincha120MinutesZmanis __attribute__((swift_name("plagHamincha120MinutesZmanis")));

/**
 * This method should be used *lechumra* only and returns the time of *plag hamincha* based on the
 * opinion that the day starts at [*alos* 16.1˚][alos16Point1Degrees] and ends at [][tzais16Point1Degrees]. This is calculated as 10.75 hours *zmaniyos*
 * after [dawn][alos16Point1Degrees]. The formula used is 10.75 * [shaahZmanis16Point1Degrees]
 * after [alos16Point1Degrees]. Since *plag* by this calculation can occur after sunset, it
 * should only be used *lechumra*.
 *
 * @return the `Date` of the time of *plag hamincha*. If the calculation can't be computed such as
 * northern and southern locations even south of the Arctic Circle and north of the Antarctic Circle where
 * the sun may not reach low enough below the horizon for this calculation, a null will be returned. See
 * detailed explanation on top of the [AstronomicalCalendar] documentation.
 *
 * @see shaahZmanis16Point1Degrees
 */
@property (readonly) STTZmanDateBased *plagHamincha16Point1Degrees __attribute__((swift_name("plagHamincha16Point1Degrees"))) __attribute__((deprecated("This method should be used <em>lechumra</em> only since it returns a very late time, and if used\n	          <em>lekula</em> can result in <em>chillul Shabbos</em> etc. There is no current plan to remove this\n	          method from the API, and this deprecation is intended to alert developers of the danger of using it.\n	  \n	  ")));

/**
 * This method should be used *lechumra* only and returns the time of *plag hamincha* based on the
 * opinion that the day starts at [*alos* 18˚][alos18Degrees] and ends at [tzais18Degrees]. This is calculated as 10.75 hours *zmaniyos* after [][alos18Degrees]. The formula used is 10.75 * [shaahZmanis18Degrees] after [][alos18Degrees]. Since *plag* by this calculation can occur after sunset, it should only be used
 * *lechumra*.
 *
 * @return the `Date` of the time of *plag hamincha*. If the calculation can't be computed such as
 * northern and southern locations even south of the Arctic Circle and north of the Antarctic Circle where
 * the sun may not reach low enough below the horizon for this calculation, a null will be returned. See
 * detailed explanation on top of the [AstronomicalCalendar] documentation.
 *
 * @see shaahZmanis18Degrees
 */
@property (readonly) STTZmanDateBased *plagHamincha18Degrees __attribute__((swift_name("plagHamincha18Degrees"))) __attribute__((deprecated("This method should be used <em>lechumra</em> only since it returns a very late time, and if used\n	          <em>lekula</em> can result in <em>chillul Shabbos</em> etc. There is no current plan to remove this\n	          method from the API, and this deprecation is intended to alert developers of the danger of using it.\n	  \n	  ")));

/**
 * This method should be used *lechumra* only and returns the time of *plag hamincha* based on the
 * opinion that the day starts at [*alos* 19.8˚][alos19Point8Degrees] and ends at [tzais19Point8Degrees]. This is calculated as 10.75 hours *zmaniyos*
 * after [dawn][alos19Point8Degrees]. The formula used is 10.75 * [shaahZmanis19Point8Degrees] after [alos19Point8Degrees]. Since *plag* by this
 * calculation can occur after sunset, it should only be used *lechumra*.
 *
 * @return the `Date` of the time of *plag hamincha*. If the calculation can't be computed such as
 * northern and southern locations even south of the Arctic Circle and north of the Antarctic Circle where
 * the sun may not reach low enough below the horizon for this calculation, a null will be returned. See
 * detailed explanation on top of the [AstronomicalCalendar] documentation.
 *
 * @see shaahZmanis19Point8Degrees
 */
@property (readonly) STTZmanDateBased *plagHamincha19Point8Degrees __attribute__((swift_name("plagHamincha19Point8Degrees"))) __attribute__((deprecated("This method should be used <em>lechumra</em> only since it returns a very late time, and if used\n	          <em>lekula</em> can result in <em>chillul Shabbos</em> etc. There is no current plan to remove this\n	          method from the API, and this deprecation is intended to alert developers of the danger of using it.\n	  \n	  ")));

/**
 * This method should be used *lechumra* only and returns the time of *plag hamincha* based on the
 * opinion that the day starts at [*alos* 26˚][alos26Degrees] and ends at [tzais26Degrees]. This is calculated as 10.75 hours *zmaniyos* after [][alos26Degrees]. The formula used is 10.75 * [shaahZmanis26Degrees] after [][alos26Degrees]. Since the *zman* based on an extremely early *alos* and a very late
 * *tzais*, it should only be used *lechumra*.
 *
 * @return the `Date` of the time of *plag hamincha*. If the calculation can't be computed such as
 * northern and southern locations even south of the Arctic Circle and north of the Antarctic Circle where
 * the sun may not reach low enough below the horizon for this calculation, a null will be returned. See
 * detailed explanation on top of the [AstronomicalCalendar] documentation.
 *
 * @see shaahZmanis26Degrees
 * @see .getPlagHamincha120Minutes
 */
@property (readonly) STTZmanDateBased *plagHamincha26Degrees __attribute__((swift_name("plagHamincha26Degrees"))) __attribute__((deprecated("This method should be used <em>lechumra</em> only since it returns a very late time, and if used\n	          <em>lekula</em> can result in <em>chillul Shabbos</em> etc. There is no current plan to remove this\n	          method from the API, and this deprecation is intended to alert developers of the danger of using it.\n	  \n	  ")));

/**
 * This method returns the time of *plag hamincha* according to the Magen Avraham with the day starting 60
 * minutes before sunrise and ending 60 minutes after sunset. This is calculated as 10.75 hours after
 * [dawn][alos60]. The formula used is 10.75 [shaahZmanis60Minutes] after [alos60].
 *
 * @return the `Date` of the time of *plag hamincha*. If the calculation can't be computed such as
 * in the Arctic Circle where there is at least one day a year where the sun does not rise, and one where it
 * does not set, a null will be returned. See detailed explanation on top of the
 * [AstronomicalCalendar] documentation.
 *
 * @see shaahZmanis60Minutes
 * @see alos60
 * @see tzais60
 */
@property (readonly) STTZmanDateBased *plagHamincha60Minutes __attribute__((swift_name("plagHamincha60Minutes")));

/**
 * This method should be used *lechumra* only and returns the time of *plag hamincha* according to the
 * Magen Avraham with the day starting 72 minutes before sunrise and ending 72 minutes after sunset. This is calculated
 * as 10.75 hours after [dawn][alos72]. The formula used is 10.75 [shaahZmanis72Minutes] after
 * [alos72]. Since *plag* by this calculation can occur after sunset, it should only be used
 * *lechumra*.
 *
 * @return the `Date` of the time of *plag hamincha*. If the calculation can't be computed such as
 * in the Arctic Circle where there is at least one day a year where the sun does not rise, and one where it
 * does not set, a null will be returned. See detailed explanation on top of the
 * [AstronomicalCalendar] documentation.
 *
 * @see shaahZmanis72Minutes
 */
@property (readonly) STTZmanDateBased *plagHamincha72Minutes __attribute__((swift_name("plagHamincha72Minutes"))) __attribute__((deprecated("This method should be used <em>lechumra</em> only since it returns a very late time, and if used\n	          <em>lekula</em> can result in <em>chillul Shabbos</em> etc. There is no current plan to remove this\n	          method from the API, and this deprecation is intended to alert developers of the danger of using it.\n	  \n	  ")));

/**
 * This method should be used *lechumra* only and returns the time of *plag hamincha*. This is calculated as
 * 10.75 hours after [alos72Zmanis]. The formula used is 10.75 * [shaahZmanis72MinutesZmanis] after
 * [dawn][alos72Zmanis]. Since *plag* by this calculation can occur after sunset, it should only be used
 * *lechumra*.
 *
 * @return the `Date` of the time of *plag hamincha*. If the calculation can't be computed such as
 * in the Arctic Circle where there is at least one day a year where the sun does not rise, and one where it
 * does not set, a null will be returned. See detailed explanation on top of the
 * [AstronomicalCalendar] documentation.
 */
@property (readonly) STTZmanDateBased *plagHamincha72MinutesZmanis __attribute__((swift_name("plagHamincha72MinutesZmanis"))) __attribute__((deprecated("This method should be used <em>lechumra</em> only since it returns a very late time, and if used\n	          <em>lekula</em> can result in <em>chillul Shabbos</em> etc. There is no current plan to remove this\n	          method from the API, and this deprecation is intended to alert developers of the danger of using it.\n	  \n	  ")));

/**
 * This method should be used *lechumra* only and returns the time of *plag hamincha* according to the
 * Magen Avraham with the day starting 90 minutes before sunrise and ending 90 minutes after sunset. This is calculated
 * as 10.75 hours after [dawn][alos90]. The formula used is 10.75 [shaahZmanis90Minutes] after
 * [alos90]. Since *plag* by this calculation can occur after sunset, it should only be used
 * *lechumra*.
 *
 * @return the `Date` of the time of *plag hamincha*. If the calculation can't be computed such as
 * in the Arctic Circle where there is at least one day a year where the sun does not rise, and one where it
 * does not set, a null will be returned. See detailed explanation on top of the
 * [AstronomicalCalendar] documentation.
 *
 * @see shaahZmanis90Minutes
 */
@property (readonly) STTZmanDateBased *plagHamincha90Minutes __attribute__((swift_name("plagHamincha90Minutes"))) __attribute__((deprecated("This method should be used <em>lechumra</em> only since it returns a very late time, and if used\n	          <em>lekula</em> can result in <em>chillul Shabbos</em> etc. There is no current plan to remove this\n	          method from the API, and this deprecation is intended to alert developers of the danger of using it.\n	  \n	  ")));

/**
 * This method should be used *lechumra* only and returns the time of *plag hamincha*. This is calculated
 * as 10.75 hours after [dawn][alos90Zmanis]. The formula used is 10.75 * [shaahZmanis90MinutesZmanis] after [dawn][alos90Zmanis]. Since *plag* by this calculation can
 * occur after sunset, it should only be used *lechumra*.
 *
 * @return the `Date` of the time of *plag hamincha*. If the calculation can't be computed such as
 * in the Arctic Circle where there is at least one day a year where the sun does not rise, and one where it
 * does not set, a null will be returned. See detailed explanation on top of the
 * [AstronomicalCalendar] documentation.
 */
@property (readonly) STTZmanDateBased *plagHamincha90MinutesZmanis __attribute__((swift_name("plagHamincha90MinutesZmanis"))) __attribute__((deprecated("This method should be used <em>lechumra</em> only since it returns a very late time, and if used\n	          <em>lekula</em> can result in <em>chillul Shabbos</em> etc. There is no current plan to remove this\n	          method from the API, and this deprecation is intended to alert developers of the danger of using it.\n	  \n	  ")));

/**
 * This method should be used *lechumra* only and returns the time of *plag hamincha* according to the Magen
 * Avraham with the day starting 96 minutes before sunrise and ending 96 minutes after sunset. This is calculated as 10.75
 * hours after [dawn][alos96]. The formula used is 10.75 [shaahZmanis96Minutes] after
 * [alos96]. Since *plag* by this calculation can occur after sunset, it should only be used
 * *lechumra*.
 *
 * @return the `Date` of the time of *plag hamincha*. If the calculation can't be computed such as
 * in the Arctic Circle where there is at least one day a year where the sun does not rise, and one where it
 * does not set, a null will be returned. See detailed explanation on top of the
 * [AstronomicalCalendar] documentation.
 * @see shaahZmanis96Minutes
 */
@property (readonly) STTZmanDateBased *plagHamincha96Minutes __attribute__((swift_name("plagHamincha96Minutes"))) __attribute__((deprecated("This method should be used <em>lechumra</em> only since it returns a very late time, and if used\n	          <em>lekula</em> can result in <em>chillul Shabbos</em> etc. There is no current plan to remove this\n	          method from the API, and this deprecation is intended to alert developers of the danger of using it.\n	  \n	  ")));

/**
 * This method should be used *lechumra* only and returns the time of *plag hamincha*. This is calculated
 * as 10.75 hours after [dawn][alos96Zmanis]. The formula used is 10.75 * [shaahZmanis96MinutesZmanis] after [dawn][alos96Zmanis]. Since *plag* by this calculation can
 * occur after sunset, it should only be used *lechumra*.
 *
 * @return the `Date` of the time of *plag hamincha*. If the calculation can't be computed such as
 * in the Arctic Circle where there is at least one day a year where the sun does not rise, and one where it
 * does not set, a null will be returned. See detailed explanation on top of the
 * [AstronomicalCalendar] documentation.
 */
@property (readonly) STTZmanDateBased *plagHamincha96MinutesZmanis __attribute__((swift_name("plagHamincha96MinutesZmanis"))) __attribute__((deprecated("This method should be used <em>lechumra</em> only since it returns a very late time, and if used\n	          <em>lekula</em> can result in <em>chillul Shabbos</em> etc. There is no current plan to remove this\n	          method from the API, and this deprecation is intended to alert developers of the danger of using it.\n	  \n	  ")));

/**
 * This method returns the time of *plag hamincha* based on the calculation of *Chacham* Yosef Harari-Raful
 * of Yeshivat Ateret Torah, that the day starts [1/10th of the day][alos72Zmanis] before sunrise and is
 * usually calculated as ending [40 minutes after sunset][tzaisAteretTorah] (configurable to any offset
 * via [.setAteretTorahSunsetOffset]). *shaos zmaniyos* are calculated based on this day and
 * added to [*alos*][alos72Zmanis] to reach this time. This time is 10.75
 * [*shaos zmaniyos*][shaahZmanisAteretTorah] (temporal hours) after [dawn][alos72Zmanis].
 *
 * @return the `Date` of the *plag*. If the calculation can't be computed such as in the Arctic Circle
 * where there is at least one day a year where the sun does not rise, and one where it does not set, a null
 * will be returned. See detailed explanation on top of the [AstronomicalCalendar] documentation.
 * @see alos72Zmanis
 * @see tzaisAteretTorah
 * @see shaahZmanisAteretTorah
 * @see .setAteretTorahSunsetOffset
 * @see ateretTorahSunsetOffset
 */
@property (readonly) STTZmanDateBased *plagHaminchaAteretTorah __attribute__((swift_name("plagHaminchaAteretTorah")));

/**
 * This method returns the time of *plag hamincha*. This is calculated as 10.75 hours after sunrise. This
 * calculation is based on the opinion of the Baal Hatanya that the day is calculated
 * from sunrise to sunset. This returns the time 10.75 * [shaahZmanisBaalHatanya] after
 * [*netz amiti* (sunrise)][sunriseBaalHatanya].
 *
 * @see .getPlagHamincha
 * @return the `Date` of the time of *plag hamincha*. If the calculation can't be computed such as
 * in the Arctic Circle where there is at least one day a year where the sun does not rise, and one where it
 * does not set, a null will be returned. See detailed explanation on top of the
 * [AstronomicalCalendar] documentation.
 */
@property (readonly) STTZmanDateBased *plagHaminchaBaalHatanya __attribute__((swift_name("plagHaminchaBaalHatanya")));

/**
 * This method returns [Rav Moshe Feinstein's](https://en.wikipedia.org/wiki/Moshe_Feinstein) opinion
 * of the calculation of *plag hamincha*. This method returns *plag hamincha* calculated according to the
 * [GRA](https://en.wikipedia.org/wiki/Vilna_Gaon) that the day ends at sunset and is 4.75 *shaos
 * zmaniyos* (solar hours) after [fixed local chatzos][fixedLocalChatzos].
 *
 * @return the `Date` of the time of *mincha gedola*. If the calculation can't be computed such as
 * in the Arctic Circle where there is at least one day a year where the sun does not rise, and one where it
 * does not set, a null will be returned. See detailed explanation on top of the [AstronomicalCalendar]
 * documentation.
 *
 * @see .getPlagHamincha
 * @see fixedLocalChatzos
 * @see .getMinchaKetanaGRAFixedLocalChatzosToSunset
 *
 * @see .getMinchaGedolaGRAFixedLocalChatzos30Minutes
 */
@property (readonly) STTZmanDateBased *plagHaminchaGRAFixedLocalChatzosToSunset __attribute__((swift_name("plagHaminchaGRAFixedLocalChatzosToSunset")));

/**
 * A method for calculating *samuch lemincha ketana*, / near *mincha ketana* time that is half an hour before
 * [minchaGedola16Point1Degrees]  or 9 * *shaos zmaniyos* (temporal hours) after the start of the day,
 * calculated using a day starting and ending 16.1 below the horizon. This is the time that eating or other activity
 * can't begin prior to praying *mincha*. The calculation used is 9 * [shaahZmanis16Point1Degrees] after
 * [*alos* 16.1˚][alos16Point1Degrees]. See the [Mechaber and Mishna Berurah 232](https://hebrewbooks.org/pdfpager.aspx?req=60387&st=&pgnum=294).
 *
 * @see shaahZmanis16Point1Degrees
 * @return the `Date` of the time of *samuch lemincha ketana*. If the calculation can't be computed such
 * as northern and southern locations even south of the Arctic Circle and north of the Antarctic Circle
 * where the sun may not reach low enough below the horizon for this calculation, a null will be returned.
 * See detailed explanation on top of the [AstronomicalCalendar] documentation.
 */
@property (readonly) STTZmanDateBased *samuchLeMinchaKetana16Point1Degrees __attribute__((swift_name("samuchLeMinchaKetana16Point1Degrees")));

/**
 * A method for calculating *samuch lemincha ketana*, / near *mincha ketana* time that is half an hour before
 * [minchaKetana72Minutes]  or 9 * *shaos zmaniyos* (temporal hours) after the start of the day,
 * calculated using a day starting 72 minutes before sunrise and ending 72 minutes after sunset. This is the time that eating
 * or other activity can't begin prior to praying *mincha*. The calculation used is 9 * [shaahZmanis16Point1Degrees] after [*alos* 16.1˚][alos16Point1Degrees]. See the [Mechaber and Mishna Berurah 232](https://hebrewbooks.org/pdfpager.aspx?req=60387&st=&pgnum=294).
 *
 * @see shaahZmanis16Point1Degrees
 * @return the `Date` of the time of *samuch lemincha ketana*. If the calculation can't be computed such
 * as northern and southern locations even south of the Arctic Circle and north of the Antarctic Circle
 * where the sun may not reach low enough below the horizon for this calculation, a null will be returned.
 * See detailed explanation on top of the [AstronomicalCalendar] documentation.
 */
@property (readonly) STTZmanDateBased *samuchLeMinchaKetana72Minutes __attribute__((swift_name("samuchLeMinchaKetana72Minutes")));

/**
 * A method for calculating *samuch lemincha ketana*, / near *mincha ketana* time that is half an hour before
 * [.getMinchaKetana] or is 9 * [*shaos zmaniyos*][shaahZmanisGra] (solar hours) after [][sunrise] or [sea level sunrise][seaLevelSunrise] (depending on the [isUseElevation]
 * setting), calculated according to the [GRA](https://en.wikipedia.org/wiki/Vilna_Gaon) using a day starting at
 * sunrise and ending at sunset. This is the time that eating or other activity can't begin prior to praying *mincha*.
 * The calculation used is 9 * [shaahZmanis16Point1Degrees] after [*alos*][alos16Point1Degrees]. See the [Mechaber and Mishna Berurah
 * 232](https://hebrewbooks.org/pdfpager.aspx?req=60387&st=&pgnum=294) for details.
 *
 * @see shaahZmanisGra
 * @see samuchLeMinchaKetana16Point1Degrees
 * @return the `Date` of the time of *samuch lemincha ketana*. If the calculation can't be computed such
 * as northern and southern locations even south of the Arctic Circle and north of the Antarctic Circle
 * where the sun may not reach low enough below the horizon for this calculation, a null will be returned.
 * See detailed explanation on top of the [AstronomicalCalendar] documentation.
 */
@property (readonly) STTZmanDateBased *samuchLeMinchaKetanaGRA __attribute__((swift_name("samuchLeMinchaKetanaGRA")));

/**
 * Method to return a *shaah zmanis* (temporal hour) calculated using a dip of 120 minutes. This calculation
 * divides the day based on the opinion of the [Magen Avraham (MGA)](https://en.wikipedia.org/wiki/Avraham_Gombinern) that the day runs from dawn to dusk.
 *
 * Dawn for this calculation is 120 minutes before sunrise.
 * Dusk is 120 minutes after sunset.
 * This day is split into 12 equal parts with each part being a *shaah zmanis*.
 *
 * Since *zmanim* that use this method are extremely late or early and at a point when the sky is a long time
 * past the 18 point where the darkest point is reached, *zmanim* that use this should only be used
 * *lechumra* only, such as delaying the start of nighttime *mitzvos*.
 *
 * @return the `long` millisecond length of a *shaah zmanis*. If the calculation can't be computed
 * such as in the Arctic Circle where there is at least one day a year where the sun does not rise, and one
 * where it does not set, a [Long.MIN_VALUE] will be returned. See detailed explanation on top of the
 * [AstronomicalCalendar] documentation.
 * @see shaahZmanis26Degrees
 */
@property (readonly) STTZmanValueBased *shaahZmanis120Minutes __attribute__((swift_name("shaahZmanis120Minutes")));

/**
 * Method to return a *shaah zmanis* (temporal hour) according to the opinion of the [Magen Avraham (MGA)](https://en.wikipedia.org/wiki/Avraham_Gombinern) based on *alos* being
 * [120][alos120Zmanis] minutes *zmaniyos* before [sunrise].
 * This calculation divides the day based on the opinion of the MGA that the day runs from dawn to dusk.
 *
 * Dawn for this calculation is 120 minutes *zmaniyos* before sunrise.
 * Dusk is 120 minutes *zmaniyos* after sunset.
 * This day is split into 12 equal parts with each part being a *shaah zmanis*.
 * This is identical to 1/6th of the day from [sunrise] to [sunset].
 *
 * Since *zmanim* that use this method are extremely late or early and at a point when the sky is a long time past
 * the 18 point where the darkest point is reached, *zmanim* that use this should only be used *lechumra* such as
 * delaying the start of  nighttime *mitzvos*.
 *
 * @return the `long` millisecond length of a *shaah zmanis*. If the calculation can't be computed
 * such as in the Arctic Circle where there is at least one day a year where the sun does not rise, and one
 * where it does not set, a [Long.MIN_VALUE] will be returned. See detailed explanation on top of the
 * [AstronomicalCalendar] documentation.
 * @see alos120Zmanis
 * @see tzais120Zmanis
 */
@property (readonly) STTZmanValueBased *shaahZmanis120MinutesZmanis __attribute__((swift_name("shaahZmanis120MinutesZmanis")));

/**
 * Method to return a *shaah zmanis* (temporal hour) calculated using a dip of 16.1. This calculation
 * divides the day based on the opinion of the [Magen Avraham (MGA)](https://en.wikipedia.org/wiki/Avraham_Gombinern) that the day runs from dawn to dusk.
 *
 * Dawn for this calculation is when the sun is 16.1 below the eastern geometric horizon before sunrise.
 * Dusk is when the sun is 16.1 below the western geometric horizon after sunset.
 * This day is split into 12 equal parts with each part being a *shaah zmanis*.
 *
 * @return the `long` millisecond length of a *shaah zmanis*. If the calculation can't be computed
 * such as northern and southern locations even south of the Arctic Circle and north of the Antarctic Circle
 * where the sun may not reach low enough below the horizon for this calculation, a [Long.MIN_VALUE]
 * will be returned. See detailed explanation on top of the [AstronomicalCalendar] documentation.
 *
 * @see alos16Point1Degrees
 * @see tzais16Point1Degrees
 * @see sofZmanShmaMGA16Point1Degrees
 * @see sofZmanTfilaMGA16Point1Degrees
 * @see minchaGedola16Point1Degrees
 * @see minchaKetana16Point1Degrees
 * @see plagHamincha16Point1Degrees
 */
@property (readonly) STTZmanValueBased *shaahZmanis16Point1Degrees __attribute__((swift_name("shaahZmanis16Point1Degrees")));

/**
 * Method to return a *shaah zmanis* (temporal hour) calculated using a 18 dip. This calculation divides
 * the day based on the opinion of the [Magen Avraham (MGA)](https://en.wikipedia.org/wiki/Avraham_Gombinern)
 * that the day runs from dawn to dusk.
 *
 * Dawn for this calculation is when the sun is 18 below the eastern geometric horizon before sunrise.
 * Dusk for this is when the sun is 18 below the western geometric horizon after sunset.
 * This day is split into 12 equal parts with each part being a *shaah zmanis*.
 *
 * @return the `long` millisecond length of a *shaah zmanis*. If the calculation can't be computed
 * such as northern and southern locations even south of the Arctic Circle and north of the Antarctic Circle
 * where the sun may not reach low enough below the horizon for this calculation, a [Long.MIN_VALUE]
 * will be returned. See detailed explanation on top of the [AstronomicalCalendar] documentation.
 */
@property (readonly) STTZmanValueBased *shaahZmanis18Degrees __attribute__((swift_name("shaahZmanis18Degrees")));

/**
 * Method to return a *shaah zmanis* (temporal hour) calculated using a 19.8 dip. This calculation
 * divides the day based on the opinion of the [Magen Avraham (MGA)](https://en.wikipedia.org/wiki/Avraham_Gombinern)
 * that the day runs from dawn to dusk.
 *
 * Dawn for this calculation is when the sun is 19.8 below the eastern geometric horizon before sunrise.
 * Dusk for this is when the sun is 19.8 below the western geometric horizon after sunset.
 * This day is split into 12 equal parts with each part being a *shaah zmanis*.
 *
 * @return the `long` millisecond length of a *shaah zmanis*. If the calculation can't be computed
 * such as northern and southern locations even south of the Arctic Circle and north of the Antarctic Circle
 * where the sun may not reach low enough below the horizon for this calculation, a [Long.MIN_VALUE]
 * will be returned. See detailed explanation on top of the [AstronomicalCalendar] documentation.
 */
@property (readonly) STTZmanValueBased *shaahZmanis19Point8Degrees __attribute__((swift_name("shaahZmanis19Point8Degrees")));

/**
 * Method to return a *shaah zmanis* (temporal hour) calculated using a dip of 26. This calculation
 * divides the day based on the opinion of the [Magen Avraham (MGA)](https://en.wikipedia.org/wiki/Avraham_Gombinern)
 * that the day runs from dawn to dusk.
 *
 * Dawn for this calculation is when the sun is [26˚][alos26Degrees] below the eastern geometric horizon before sunrise.
 * Dusk for this is when the sun is [26˚][tzais26Degrees] below the western geometric horizon after sunset.
 * This day is split into 12 equal parts with each part being a *shaah zmanis*.
 *
 * Since *zmanim* that use this method are extremely late or early and at a point when the sky is a long time past
 * the 18 point where the darkest point is reached, *zmanim* that use this should only be used *lechumra*, such as
 * delaying the start of nighttime *mitzvos*.
 *
 * @return the `long` millisecond length of a *shaah zmanis*. If the calculation can't be computed
 * such as northern and southern locations even south of the Arctic Circle and north of the Antarctic Circle
 * where the sun may not reach low enough below the horizon for this calculation, a [Long.MIN_VALUE]
 * will be returned. See detailed explanation on top of the [AstronomicalCalendar] documentation.
 * @see shaahZmanis120Minutes
 */
@property (readonly) STTZmanValueBased *shaahZmanis26Degrees __attribute__((swift_name("shaahZmanis26Degrees")));

/**
 * Method to return a *shaah zmanis* (solar hour) according to the opinion of the [Magen Avraham (MGA)](https://en.wikipedia.org/wiki/Avraham_Gombinern). This calculation
 * divides the day based on the opinion of the MGA that the day runs from dawn to dusk.
 *
 * Dawn for this calculation is 60 minutes before sunrise.
 * Dusk is 60 minutes after sunset.
 * This day is split into 12 equal parts with each part being a *shaah zmanis*.
 *
 * @return the `long` millisecond length of a *shaah zmanis*. If the calculation can't be computed
 * such as in the Arctic Circle where there is at least one day a year where the sun does not rise, and one
 * where it does not set, a [Long.MIN_VALUE] will be returned. See detailed explanation on top of the
 * [AstronomicalCalendar] documentation.
 *
 * @see alos60
 * @see tzais60
 * @see plagHamincha60Minutes
 */
@property (readonly) STTZmanValueBased *shaahZmanis60Minutes __attribute__((swift_name("shaahZmanis60Minutes")));

/**
 * Method to return a *shaah zmanis* (solar hour) according to the opinion of the [Magen Avraham (MGA)](https://en.wikipedia.org/wiki/Avraham_Gombinern). This calculation divides the day
 * based on the opinion of the MGA that the day runs from dawn to dusk.
 *
 * Dawn for this calculation is 72 minutes before sunrise.
 * Dusk is 72 minutes after sunset.
 * This day is split into 12 equal parts with each part being a *shaah zmanis*.
 *
 * @return the `long` millisecond length of a *shaah zmanis*. If the calculation can't be computed
 * such as in the Arctic Circle where there is at least one day a year where the sun does not rise, and one
 * where it does not set, a [Long.MIN_VALUE] will be returned. See detailed explanation on top of the
 * [AstronomicalCalendar] documentation.
 */
@property (readonly) STTZmanValueBased *shaahZmanis72Minutes __attribute__((swift_name("shaahZmanis72Minutes")));

/**
 * Method to return a *shaah zmanis* (temporal hour) according to the opinion of the [Magen Avraham (MGA)](https://en.wikipedia.org/wiki/Avraham_Gombinern) based on *alos* being
 * [72][alos72Zmanis] minutes *zmaniyos* before [sunrise]. This calculation
 * divides the day based on the opinion of the MGA that the day runs from dawn to dusk.
 *
 * Dawn for this calculation is 72 minutes *zmaniyos* before sunrise.
 * Dusk is 72 minutes *zmaniyos* after sunset.
 * This day is split into 12 equal parts with each part being a *shaah zmanis*.
 * This is identical to 1/10th of the day from [sunrise] to [sunset].
 *
 * @return the `long` millisecond length of a *shaah zmanis*. If the calculation can't be computed
 * such as in the Arctic Circle where there is at least one day a year where the sun does not rise, and one
 * where it does not set, a [Long.MIN_VALUE] will be returned. See detailed explanation on top of the
 * [AstronomicalCalendar] documentation.
 * @see alos72Zmanis
 * @see tzais72Zmanis
 */
@property (readonly) STTZmanValueBased *shaahZmanis72MinutesZmanis __attribute__((swift_name("shaahZmanis72MinutesZmanis")));

/**
 * Method to return a *shaah zmanis* (temporal hour) calculated using a dip of 90 minutes. This calculation
 * divides the day based on the opinion of the [Magen Avraham (MGA)](https://en.wikipedia.org/wiki/Avraham_Gombinern) that the day runs from dawn to dusk.
 *
 * Dawn for this calculation is 90 minutes before sunrise.
 * Dusk is 90 minutes after sunset.
 * This day is split into 12 equal parts with each part being a *shaah zmanis*.
 *
 * @return the `long` millisecond length of a *shaah zmanis*. If the calculation can't be computed
 * such as in the Arctic Circle where there is at least one day a year where the sun does not rise, and one
 * where it does not set, a [Long.MIN_VALUE] will be returned. See detailed explanation on top of the
 * [AstronomicalCalendar] documentation.
 */
@property (readonly) STTZmanValueBased *shaahZmanis90Minutes __attribute__((swift_name("shaahZmanis90Minutes")));

/**
 * Method to return a *shaah zmanis* (temporal hour) according to the opinion of the [Magen Avraham (MGA)](https://en.wikipedia.org/wiki/Avraham_Gombinern) based on *alos* being
 * [90][alos90Zmanis] minutes *zmaniyos* before [sunrise]. This calculation divides
 * the day based on the opinion of the MGA that the day runs from dawn to dusk.
 *
 * Dawn for this calculation is 90 minutes *zmaniyos* before sunrise.
 * Dusk is 90 minutes *zmaniyos* after sunset.
 * This day is split into 12 equal parts with each part being a *shaah zmanis*.
 * This is 1/8th of the day from [sunrise] to [sunset].
 *
 * @return the `long` millisecond length of a *shaah zmanis*. If the calculation can't be computed
 * such as in the Arctic Circle where there is at least one day a year where the sun does not rise, and one
 * where it does not set, a [Long.MIN_VALUE] will be returned. See detailed explanation on top of the
 * [AstronomicalCalendar] documentation.
 * @see alos90Zmanis
 * @see tzais90Zmanis
 */
@property (readonly) STTZmanValueBased *shaahZmanis90MinutesZmanis __attribute__((swift_name("shaahZmanis90MinutesZmanis")));

/**
 * Method to return a *shaah zmanis* (temporal hour) calculated using a dip of 96 minutes. This calculation
 * divides the day based on the opinion of the [Magen Avraham (MGA)](https://en.wikipedia.org/wiki/Avraham_Gombinern) that the day runs from dawn to dusk.
 *
 * Dawn for this calculation is 96 minutes before sunrise
 * Dusk is 96 minutes after sunset.
 * This day is split into 12 equal parts with each part being a *shaah zmanis*.
 *
 * @return the `long` millisecond length of a *shaah zmanis*. If the calculation can't be computed
 * such as in the Arctic Circle where there is at least one day a year where the sun does not rise, and one
 * where it does not set, a [Long.MIN_VALUE] will be returned. See detailed explanation on top of the
 * [AstronomicalCalendar] documentation.
 */
@property (readonly) STTZmanValueBased *shaahZmanis96Minutes __attribute__((swift_name("shaahZmanis96Minutes")));

/**
 * Method to return a *shaah zmanis* (temporal hour) according to the opinion of the [Magen Avraham (MGA)](https://en.wikipedia.org/wiki/Avraham_Gombinern) based on *alos* being
 * [96][alos96Zmanis] minutes *zmaniyos* before [sunrise]. This calculation divides the
 * day based on the opinion of the MGA that the day runs from dawn to dusk.
 *
 * Dawn for this calculation is 96 minutes *zmaniyos* before sunrise.
 * Dusk is 96 minutes *zmaniyos* after sunset.
 * This day is split into 12 equal parts with each part being a *shaah zmanis*.
 * This is identical to 1/7.5th of the day from [sunrise] to [sunset].
 *
 * @return the `long` millisecond length of a *shaah zmanis*. If the calculation can't be computed
 * such as in the Arctic Circle where there is at least one day a year where the sun does not rise, and one
 * where it does not set, a [Long.MIN_VALUE] will be returned. See detailed explanation on top of the
 * [AstronomicalCalendar] documentation.
 * @see alos96Zmanis
 * @see tzais96Zmanis
 */
@property (readonly) STTZmanValueBased *shaahZmanis96MinutesZmanis __attribute__((swift_name("shaahZmanis96MinutesZmanis")));

/**
 * Method to return a *shaah zmanis* (temporal hour) used by some *zmanim* according to the opinion of
 * [Rabbi Yaakov Moshe Hillel](https://en.wikipedia.org/wiki/Yaakov_Moshe_Hillel) as published in the
 * *luach* of the Bais Horaah of Yeshivat Chevrat Ahavat Shalom.
 *
 * Day in this calculation day starts 72 minutes before sunrise in degrees [*alos* 16.1˚][alos16Point1Degrees]
 * and ending 13.5 minutes after sunset in degrees [*tzais* 3.7˚][tzaisGeonim3Point7Degrees].
 * This day is split into 12 equal parts with each part being a *shaah zmanis*.
 *
 * Note that with this system, *chatzos* (mid-day) will not be the point that the sun is [halfway across the sky][sunTransit].
 * These *shaos zmaniyos* are used for *Mincha Gedola* calculation.
 *
 * @return the `long` millisecond length of a *shaah zmanis*. If the calculation can't be computed
 * such as in the Arctic Circle where there is at least one day a year where the sun does not rise, and one
 * where it does not set, a [Long.MIN_VALUE] will be returned. See detailed explanation on top of the
 * [AstronomicalCalendar] documentation.
 *
 * @see minchaGedolaAhavatShalom
 */
@property (readonly) STTZmanValueBased *shaahZmanisAlos16Point1ToTzais3Point7 __attribute__((swift_name("shaahZmanisAlos16Point1ToTzais3Point7")));

/**
 * Method to return a *shaah zmanis* (temporal hour) used by some *zmanim* according to the opinion of
 * [Rabbi Yaakov Moshe Hillel](https://en.wikipedia.org/wiki/Yaakov_Moshe_Hillel) as published in the
 * *luach* of the Bais Horaah of Yeshivat Chevrat Ahavat Shalom.
 *
 * Dawn for this calculation is 72 minutes before sunrise in degrees [*alos* 16.1˚][alos16Point1Degrees]
 * Dusk for this calculation is 14 minutes after sunset in degrees [*tzais* 3.8˚][tzaisGeonim3Point8Degrees].
 * This day is split into 12 equal parts with each part being a *shaah zmanis*.
 *
 * Note that with this system, *chatzos* (mid-day) will not be the point that the sun is [halfway across the sky][sunTransit].
 * These *shaos zmaniyos* are used for *Mincha Ketana* and *Plag Hamincha*.
 * The 14 minutes are based on 3/4 of an 18 minute *mil*, with half a minute added for Rav Yosi.
 *
 * @return the `long` millisecond length of a *shaah zmanis*. If the calculation can't be computed
 * such as in the Arctic Circle where there is at least one day a year where the sun does not rise, and one
 * where it does not set, a [Long.MIN_VALUE] will be returned. See detailed explanation on top of the
 * [AstronomicalCalendar] documentation.
 *
 * @see minchaKetanaAhavatShalom
 * @see plagAhavatShalom
 */
@property (readonly) STTZmanValueBased *shaahZmanisAlos16Point1ToTzais3Point8 __attribute__((swift_name("shaahZmanisAlos16Point1ToTzais3Point8")));

/**
 * Method to return a *shaah zmanis* (temporal hour) according to the opinion of the
 * *Chacham* Yosef Harari-Raful of Yeshivat Ateret Torah.
 *
 * Dawn for this calculation is 1/10th of sunrise to sunset day, or [72][alos72Zmanis] minutes *zmaniyos* of such a day before [sunrise].
 * Dusk is usually calculated as [40][tzaisAteretTorah] (configurable to any offset via setting [ateretTorahSunsetOffset]) after [sunset].
 * This day is split into 12 equal parts with each part being a *shaah zmanis*.
 *
 * Note that with this system, *chatzos* (mid-day) will not be the point that the sun is [halfway across][sunTransit].
 *
 * @return the `long` millisecond length of a *shaah zmanis*. If the calculation can't be computed
 * such as in the Arctic Circle where there is at least one day a year where the sun does not rise, and one
 * where it does not set, a [Long.MIN_VALUE] will be returned. See detailed explanation on top of the
 * [AstronomicalCalendar] documentation.
 * @see alos72Zmanis
 * @see tzaisAteretTorah
 * @see ateretTorahSunsetOffset
 * @see ateretTorahSunsetOffset
 */
@property (readonly) STTZmanValueBased *shaahZmanisAteretTorah __attribute__((swift_name("shaahZmanisAteretTorah")));

/**
 * A method that returns the [Baal Hatanya](https://en.wikipedia.org/wiki/Shneur_Zalman_of_Liadi)'s
 * a *shaah zmanis* ([temporal hour][temporalHour]). This forms the base for the
 * Baal Hatanya's  day  based calculations that are calculated as a 1.583 dip below the horizon after sunset.
 * According to the Baal Hatanya, *shkiah amiti*, true (halachic) sunset, is when the top of the
 * sun's disk disappears from view at an elevation similar to the mountains of Eretz Yisrael.
 * This time is calculated as the point at which the center of the sun's disk is 1.583 degrees below the horizon.
 * A method that returns a *shaah zmanis* ([temporal hour][temporalHour]) calculated
 * based on the [Baal Hatanya](https://en.wikipedia.org/wiki/Shneur_Zalman_of_Liadi)'s *netz
 * amiti* and *shkiah amiti* using a dip of 1.583 below the sea level horizon. This calculation divides
 * the day based on the opinion of the Baal Hatanya that the day runs from [netz amiti][sunriseBaalHatanya]
 * to [*shkiah amiti*][sunsetBaalHatanya]. The calculations are based on a day from [sunriseBaalHatanya] to [sea level *shkiah amiti*][sunsetBaalHatanya].
 * The day is split into 12 equal parts with each one being a *shaah zmanis*. This method is similar to [][temporalHour], but all calculations are based on a sea level sunrise and sunset.
 * @return the `long` millisecond length of a *shaah zmanis* calculated from
 * [*netz amiti* (sunrise)][sunriseBaalHatanya] to [*shkiah amiti*][sunsetBaalHatanya]. If the calculation can't be computed such as in the Arctic Circle where there is at least one day a
 * year where the sun does not rise, and one where it does not set, [Long.MIN_VALUE] will be returned. See
 * detailed explanation on top of the [AstronomicalCalendar] documentation.
 *
 * @see .temporalHour
 * @see sunriseBaalHatanya
 * @see sunsetBaalHatanya
 * @see ZENITH_1_POINT_583
 */
@property (readonly) int64_t shaahZmanisBaalHatanya __attribute__((swift_name("shaahZmanisBaalHatanya")));

/**
 * This method returns the latest time one is allowed eating *chametz* on *Erev Pesach* according to the
 * opinion of the Baal Hatanya. This time is identical to the [*Sof zman tfilah*][sofZmanTfilaBaalHatanya]. This time is 4 hours into the day based on the opinion of the Baal Hatanya that the day is calculated
 * from sunrise to sunset. This returns the time 4 [shaahZmanisBaalHatanya] after
 * [*netz amiti* (sunrise)][sunriseBaalHatanya].
 *
 * @see shaahZmanisBaalHatanya
 * @see sofZmanTfilaBaalHatanya
 * @return the `Date` one is allowed eating *chametz* on *Erev Pesach*. If the calculation can't
 * be computed such as in the Arctic Circle where there is at least one day a year where the sun does not rise,
 * and one where it does not set, a null will be returned. See detailed explanation on top of the
 * [AstronomicalCalendar] documentation.
 */
@property (readonly) STTZmanDateBased *sofZmanAchilasChametzBaalHatanya __attribute__((swift_name("sofZmanAchilasChametzBaalHatanya")));

/**
 * This method returns the latest time one is allowed eating *chametz* on *Erev Pesach* according to
 * the opinion of the[GRA](https://en.wikipedia.org/wiki/Vilna_Gaon). This time is identical to the [sofZmanTfilaGRA] and is provided as a convenience method for those who are
 * unaware how this *zman* is calculated. This time is 4 hours into the day based on the opinion of the
 * [GRA](https://en.wikipedia.org/wiki/Vilna_Gaon) that the day is calculated from sunrise to sunset.
 * This returns the time 4 * [shaahZmanisGra] after [sea level sunrise][seaLevelSunrise].
 *
 * @see ZmanimCalendar.getShaahZmanisGra
 * @see ZmanimCalendar.getSofZmanTfilaGRA
 * @return the `Date` one is allowed eating *chametz* on *Erev Pesach*. If the calculation
 * can't be computed such as in the Arctic Circle where there is at least one day a year where the sun does
 * not rise, and one where it does not set, a null will be returned. See detailed explanation on top of the
 * [AstronomicalCalendar] documentation.
 */
@property (readonly) STTZmanDateBased *sofZmanAchilasChametzGRA __attribute__((swift_name("sofZmanAchilasChametzGRA")));

/**
 * This method returns the latest time one is allowed eating *chametz* on *Erev Pesach* according to the
 * opinion of the[Magen Avraham (MGA)](https://en.wikipedia.org/wiki/Avraham_Gombinern) based on *alos*
 * being [16.1˚][alos16Point1Degrees] before [sunrise]. This time is 4 [][shaahZmanis16Point1Degrees] (solar hours) after [dawn][alos16Point1Degrees]
 * based on the opinion of the MGA that the day is calculated from dawn to nightfall with both being 16.1
 * below sunrise or sunset. This returns the time of 4 [shaahZmanis16Point1Degrees] after
 * [dawn][alos16Point1Degrees].
 *
 * @return the `Date` of the latest time of eating *chametz*. If the calculation can't be computed such
 * as northern and southern locations even south of the Arctic Circle and north of the Antarctic Circle where
 * the sun may not reach low enough below the horizon for this calculation,ZmanCalculationMethod.FixedDuration(72), a null will be returned. See
 * detailed explanation on top of the [AstronomicalCalendar] documentation.
 *
 * @see shaahZmanis16Point1Degrees
 * @see alos16Point1Degrees
 * @see sofZmanTfilaMGA16Point1Degrees
 */
@property (readonly) STTZmanDateBased *sofZmanAchilasChametzMGA16Point1Degrees __attribute__((swift_name("sofZmanAchilasChametzMGA16Point1Degrees")));

/**
 * This method returns the latest time one is allowed eating *chametz* on *Erev Pesach* according to the
 * opinion of the [Magen Avraham (MGA)](https://en.wikipedia.org/wiki/Avraham_Gombinern) based on *alos*
 * being [72][alos72] minutes before [sunrise]. This time is identical to the
 * [*Sof zman tfilah* MGA 72 minutes][sofZmanTfilaMGA72Minutes]. This time is 4 [*shaos zmaniyos*][shaahZmanisMGA] (temporal hours) after [dawn][alos72] based on the opinion of the MGA that the day is
 * calculated from a [dawn][alos72] of 72 minutes before sunrise to [nightfall][tzais72] of 72 minutes
 * after sunset. This returns the time of 4 * [shaahZmanisMGA] after [dawn][alos72].
 *
 * @return the `Date` of the latest time of eating *chametz*. If the calculation can't be computed such as
 * in the Arctic Circle where there is at least one day a year where the sun does not rise, and one where it
 * does not set), a null will be returned. See detailed explanation on top of the
 * [AstronomicalCalendar] documentation.
 * @see shaahZmanisMGA
 * @see alos72
 * @see sofZmanTfilaMGA72Minutes
 */
@property (readonly) STTZmanDateBased *sofZmanAchilasChametzMGA72Minutes __attribute__((swift_name("sofZmanAchilasChametzMGA72Minutes")));

/**
 * This method returns the latest time for burning *chametz* on *Erev Pesach* according to the opinion of
 * the Baal Hatanya. This time is 5 hours into the day based on the opinion of the Baal Hatanya that the day is calculated
 * from sunrise to sunset. This returns the time 5 * [shaahZmanisBaalHatanya] after
 * [*netz amiti* (sunrise)][sunriseBaalHatanya].
 *
 * @see shaahZmanisBaalHatanya
 * @return the `Date` of the latest time for burning *chametz* on *Erev Pesach*. If the calculation
 * can't be computed such as in the Arctic Circle where there is at least one day a year where the sun does not rise,
 * and one where it does not set, a null will be returned. See detailed explanation on top of the
 * [AstronomicalCalendar] documentation.
 */
@property (readonly) STTZmanDateBased *sofZmanBiurChametzBaalHatanya __attribute__((swift_name("sofZmanBiurChametzBaalHatanya")));

/**
 * This method returns the latest time for burning *chametz* on *Erev Pesach* according to the opinion
 * of the [GRA](https://en.wikipedia.org/wiki/Vilna_Gaon). This time is 5 hours into the day based on the
 * opinion of the [GRA](https://en.wikipedia.org/wiki/Vilna_Gaon) that the day is calculated from
 * sunrise to sunset. This returns the time 5 * [shaahZmanisGra] after [sea][seaLevelSunrise].
 *
 * @see ZmanimCalendar.getShaahZmanisGra
 * @return the `Date` of the latest time for burning *chametz* on *Erev Pesach*. If the
 * calculation can't be computed such as in the Arctic Circle where there is at least one day a year where
 * the sun does not rise, and one where it does not set, a null will be returned. See detailed explanation on
 * top of the [AstronomicalCalendar] documentation.
 */
@property (readonly) STTZmanDateBased *sofZmanBiurChametzGRA __attribute__((swift_name("sofZmanBiurChametzGRA")));

/**
 * This method returns the latest time for burning *chametz* on *Erev Pesach* according to the opinion
 * of the [Magen Avraham (MGA)](https://en.wikipedia.org/wiki/Avraham_Gombinern) based on *alos*
 * being [16.1˚][alos16Point1Degrees] before [sunrise]. This time is 5
 * [*shaos zmaniyos*][shaahZmanis16Point1Degrees] (solar hours) after [dawn][alos16Point1Degrees] based on the opinion of the MGA that the day is calculated from dawn to nightfall with both being 16.1
 * below sunrise or sunset. This returns the time of 5 [shaahZmanis16Point1Degrees] after
 * [dawn][alos16Point1Degrees].
 *
 * @return the `Date` of the latest time for burning *chametz* on *Erev Pesach*. If the calculation
 * can't be computed such as northern and southern locations even south of the Arctic Circle and north of the
 * Antarctic Circle where the sun may not reach low enough below the horizon for this calculation, a null
 * will be returned. See detailed explanation on top of the [AstronomicalCalendar] documentation.
 *
 * @see shaahZmanis16Point1Degrees
 * @see alos16Point1Degrees
 */
@property (readonly) STTZmanDateBased *sofZmanBiurChametzMGA16Point1Degrees __attribute__((swift_name("sofZmanBiurChametzMGA16Point1Degrees")));

/**
 * This method returns the latest time for burning *chametz* on *Erev Pesach* according to the opinion of
 * the [Magen Avraham (MGA)](https://en.wikipedia.org/wiki/Avraham_Gombinern) based on *alos*
 * being [72][alos72] minutes before [sunrise]. This time is 5 [shaahZmanisMGA] (temporal hours) after [dawn][alos72] based on the opinion of
 * the MGA that the day is calculated from a [dawn][alos72] of 72 minutes before sunrise to [][tzais72] of 72 minutes after sunset. This returns the time of 5 * [shaahZmanisMGA] after
 * [dawn][alos72].
 *
 * @return the `Date` of the latest time for burning *chametz* on *Erev Pesach*. If the calculation
 * can't be computed such as in the Arctic Circle where there is at least one day a year where the sun does not rise,
 * and one where it does not set), a null will be returned. See detailed explanation on top of the
 * [AstronomicalCalendar] documentation.
 * @see shaahZmanisMGA
 * @see alos72
 */
@property (readonly) STTZmanDateBased *sofZmanBiurChametzMGA72Minutes __attribute__((swift_name("sofZmanBiurChametzMGA72Minutes")));

/**
 * Returns the latest time of *Kiddush Levana* calculated as 15 days after the molad. This is the opinion of
 * the Shulchan Aruch (Orach Chaim 426). It should be noted that some opinions hold that the
 * [Rema](https://en.wikipedia.org/wiki/Moses_Isserles) who brings down the opinion of the [Maharil's](https://en.wikipedia.org/wiki/Yaakov_ben_Moshe_Levi_Moelin) of calculating
 * [half way between *molad* and *molad*][sofZmanKidushLevanaBetweenMoldos] is of
 * the opinion that the Mechaber agrees to his opinion. Also see the Aruch Hashulchan. For additional details on the subject,
 * See Rabbi Dovid Heber's very detailed write-up in Siman Daled (chapter 4) of [Shaarei
 * Zmanim](https://hebrewbooks.org/53000). The *sof zman Kiddush Levana* will be returned even if it occurs during the day. To limit the time to
 * between *tzais* and *alos*, see [sofZmanKidushLevana15Days].
 *
 * @return the Date representing the moment 15 days after the *molad*. If the time occurs between
 * *alos* and *tzais*, *alos* will be returned
 *
 * @see getSofZmanKidushLevana15Days
 * @see getSofZmanKidushLevanaBetweenMoldos
 * @see JewishCalendar.sofZmanKidushLevana15Days
 */
@property (readonly) STTZmanDateBased *sofZmanKidushLevana15Days __attribute__((swift_name("sofZmanKidushLevana15Days")));

/**
 * Returns the latest time of Kiddush Levana according to the [Maharil's](https://en.wikipedia.org/wiki/Yaakov_ben_Moshe_Levi_Moelin) opinion that it is calculated as
 * halfway between *molad* and *molad*. This adds half the 29 days, 12 hours and 793 chalakim time between
 * *molad* and *molad* (14 days, 18 hours, 22 minutes and 666 milliseconds) to the month's *molad*.
 * The *sof zman Kiddush Levana* will be returned even if it occurs during the day. To limit the time to between
 * *tzais* and *alos*, see [JewishCalendar.sofZmanKidushLevanaBetweenMoldos].
 *
 * @return the Date representing the moment halfway between molad and molad. If the time occurs between
 * *alos* and *tzais*, *alos* will be returned
 * @see sofZmanKidushLevanaBetweenMoldos
 * @see sofZmanKidushLevana15Days
 * @see JewishCalendar.sofZmanKidushLevanaBetweenMoldos
 */
@property (readonly) STTZmanDateBased *sofZmanKidushLevanaBetweenMoldos __attribute__((swift_name("sofZmanKidushLevanaBetweenMoldos")));

/**
 * This method returns the latest *zman krias shema* (time to recite *Shema* in the morning) calculated
 * as 3 hours (regular clock hours and not *sha'os zmaniyos*) before [ZmanimCalendar.chatzos].
 *
 *
 * Generally known as part of the "Komarno" *zmanim* after [Rav Yitzchak Eizik of Komarno](https://en.wikipedia.org/wiki/Komarno_(Hasidic_dynasty)#Rabbi_Yitzchak_Eisik_Safrin),
 * a proponent of this calculation, it actually predates him a lot.
 *
 * It is the opinion of
 * - the *Shach* in the Nekudas Hakesef (Yoreh Deah 184),
 * - [Rav Moshe Lifshitz](https://hebrewbooks.org/pdfpager.aspx?req=21638&st=&pgnum=30) in his commentary
 * [Lechem Mishneh on Brachos 1:2](https://hebrewbooks.org/pdfpager.aspx?req=21638&st=&pgnum=50).
 * - It is next brought down about 100 years later by the [Yaavetz](https://en.wikipedia.org/wiki/Jacob_Emden)
 *     - (in his *siddur*, [Mor Uktziah Orach Chaim 1](https://hebrewbooks.org/pdfpager.aspx?req=7920&st=&pgnum=6),
 *     - [Lechem Shamayim, Brachos 1:2](https://hebrewbooks.org/pdfpager.aspx?req=22309&st=&pgnum=30)
 *     - and [She'elos Yaavetz vol. 1 no. 40](https://hebrewbooks.org/pdfpager.aspx?req=1408&st=&pgnum=69)),
 * - Rav Yitzchak Eizik of Komarno in the Ma'aseh Oreg on Mishnayos Brachos 11:2,
 * - Shevus Yaakov,
 * - Chasan Sofer
 * - and others.
 * - See Yisrael Vehazmanim [vol. 1 7:3, page 55 - 62](https://hebrewbooks.org/pdfpager.aspx?req=9765&st=&pgnum=83).
 *
 * A variant of this calculation ([sofZmanShmaGRASunriseToFixedLocalChatzos]) uses [fixed][fixedLocalChatzos] for calculating this type of *zman*.
 *
 * @return the `Date` of the latest *zman krias shema*. If the calculation can't be computed such
 * as in the Arctic Circle where there is at least one day a year where the sun does not rise, and one where
 * it does not set, a null will be returned. See detailed explanation on top of the
 * [AstronomicalCalendar] documentation.
 * @see ZmanimCalendar.getChatzos
 * @see sofZmanShmaFixedLocal
 * @see sofZmanTfila2HoursBeforeChatzos
 */
@property (readonly) STTZmanDateBased *sofZmanShma3HoursBeforeChatzos __attribute__((swift_name("sofZmanShma3HoursBeforeChatzos")));

/**
 * This method returns the latest *zman krias shema* (time to recite *Shema* in the morning) based
 * on the opinion that the day starts at [*alos* 16.1˚][alos16Point1Degrees] and ends at
 * [sea level sunset][seaLevelSunset].
 *
 * This is the opinion of the [חידושי וכללות הרז״ה](https://hebrewbooks.org/40357) and the [מנורה הטהורה](https://hebrewbooks.org/14799)
 * as mentioned by Yisrael Vehazmanim [vol 1, sec. 7, ch. 3 no. 16](https://hebrewbooks.org/pdfpager.aspx?req=9765&pgnum=81).
 *
 * Three *shaos zmaniyos* are calculated based on this day and added to [alos16Point1Degrees] to reach this time.
 * This time is 3 *shaos zmaniyos* (solar hours) after [dawn][alos16Point1Degrees] based on the opinion that
 * the day is calculated from a [alos16Point1Degrees] to [sea level sunset][seaLevelSunset].
 *
 * **Note:** Based on this calculation *chatzos* will not be at midday.
 *
 * @return the `Date` of the latest *zman krias shema* based on this day. If the calculation can't
 * be computed such as northern and southern locations even south of the Arctic Circle and north of the
 * Antarctic Circle where the sun may not reach low enough below the horizon for this calculation, a null
 * will be returned. See detailed explanation on top of the [AstronomicalCalendar] documentation.
 * @see alos16Point1Degrees
 * @see seaLevelSunset
 */
@property (readonly) STTZmanDateBased *sofZmanShmaAlos16Point1ToSunset __attribute__((swift_name("sofZmanShmaAlos16Point1ToSunset")));

/**
 * This method returns the latest *zman krias shema* (time to recite Shema in the morning) based on the
 * opinion that the day starts at [*alos* 16.1˚][alos16Point1Degrees] and ends at
 * [*tzais* 7.083˚][tzaisGeonim7Point083Degrees].
 *
 * 3 *shaos zmaniyos* are calculated based on this day and added to [*alos*][alos16Point1Degrees] to reach this time.
 *
 * This time is 3 *shaos zmaniyos* (temporal hours) after [*alos* 16.1˚][alos16Point1Degrees] based on
 * the opinion that the day is calculated from a [*alos* 16.1˚][alos16Point1Degrees] to
 * [*tzais* 7.083˚][tzaisGeonim7Point083Degrees].
 *
 * **Note: ** Based on this calculation *chatzos* will not be at midday.
 *
 * @return the `Date` of the latest *zman krias shema* based on this calculation. If the
 * calculation can't be computed such as northern and southern locations even south of the Arctic Circle and
 * north of the Antarctic Circle where the sun may not reach low enough below the horizon for this
 * calculation, a null will be returned. See detailed explanation on top of the [AstronomicalCalendar]
 * documentation.
 * @see alos16Point1Degrees
 * @see tzaisGeonim7Point083Degrees
 */
@property (readonly) STTZmanDateBased *sofZmanShmaAlos16Point1ToTzaisGeonim7Point083Degrees __attribute__((swift_name("sofZmanShmaAlos16Point1ToTzaisGeonim7Point083Degrees")));

/**
 * This method returns the latest *zman krias shema* (time to recite Shema in the morning) based on the
 * calculation of *Chacham* Yosef Harari-Raful of Yeshivat Ateret Torah, that the day starts
 * [1/10th of the day][alos72Zmanis] before sunrise and is usually calculated as ending
 * [40 minutes after sunset][tzaisAteretTorah] (configurable to any offset via
 * [.setAteretTorahSunsetOffset]). *shaos zmaniyos* are calculated based on this day and added
 * to [*alos*][alos72Zmanis] to reach this time. This time is 3
 * [*shaos zmaniyos*][shaahZmanisAteretTorah] (temporal hours) after
 * [*alos* 72 *zmaniyos*][alos72Zmanis]. **Note: ** Based on this calculation *chatzos*
 * will not be at midday.
 *
 * @return the `Date` of the latest *zman krias shema* based on this calculation. If the
 * calculation can't be computed such as in the Arctic Circle where there is at least one day a year where
 * the sun does not rise, and one where it does not set, a null will be returned. See detailed explanation
 * on top of the [AstronomicalCalendar] documentation.
 * @see alos72Zmanis
 * @see tzaisAteretTorah
 * @see ateretTorahSunsetOffset
 * @see .setAteretTorahSunsetOffset
 * @see shaahZmanisAteretTorah
 */
@property (readonly) STTZmanDateBased *sofZmanShmaAteretTorah __attribute__((swift_name("sofZmanShmaAteretTorah")));

/**
 * This method returns the latest *zman krias shema* (time to recite Shema in the morning). This time is 3
 * [*shaos zmaniyos*][shaahZmanisBaalHatanya] (solar hours) after [*netz amiti* (sunrise)][sunriseBaalHatanya] based on the opinion of the Baal Hatanya that the day is calculated from
 * sunrise to sunset. This returns the time 3 * [shaahZmanisBaalHatanya] after [*netz amiti* (sunrise)][sunriseBaalHatanya].
 *
 * @see ZmanimCalendar.getSofZmanShma
 * @see shaahZmanisBaalHatanya
 * @return the `Date` of the latest *zman shema* according to the Baal Hatanya. If the calculation
 * can't be computed such as in the Arctic Circle where there is at least one day a year where the sun does
 * not rise, and one where it does not set, a null will be returned. See detailed explanation on top of the
 * [AstronomicalCalendar] documentation.
 */
@property (readonly) STTZmanDateBased *sofZmanShmaBaalHatanya __attribute__((swift_name("sofZmanShmaBaalHatanya")));

/**
 * This method returns [Rav Moshe Feinstein's](https://en.wikipedia.org/wiki/Moshe_Feinstein) opinion of the
 * calculation of *sof zman krias shema* (latest time to recite *Shema* in the morning) according to the
 * opinion of the [GRA](https://en.wikipedia.org/wiki/Vilna_Gaon) that the day is calculated from
 * sunrise to sunset, but calculated using the first half of the day only. The half a day starts at [sunrise][sunrise] and ends at [fixed local chatzos]fixedLocalChatzos]. *Sof zman Shema* is 3 *shaos
 * zmaniyos* (solar hours) after sunrise or half of this half-day.
 *
 * @return the `Date` of the latest *zman krias shema*. If the calculation can't be computed such
 * as northern and southern locations even south of the Arctic Circle and north of the Antarctic Circle
 * where the sun may not reach low enough below the horizon for this calculation, a null will be returned.
 * See detailed explanation on top of the [AstronomicalCalendar] documentation.
 * @see sunrise
 * @see fixedLocalChatzos
 * @see .getFixedLocalChatzosBasedZmanim
 */
@property (readonly) STTZmanDateBased *sofZmanShmaGRASunriseToFixedLocalChatzos __attribute__((swift_name("sofZmanShmaGRASunriseToFixedLocalChatzos")));

/**
 * This method returns the latest *zman krias shema* (time to recite Shema in the morning) according to the
 * opinion of the [Magen Avraham (MGA)](https://en.wikipedia.org/wiki/Avraham_Gombinern) based
 * on *alos* being [120][alos120] minutes or 1/6th of the day before [sunrise].
 * This time is 3 [*shaos zmaniyos*][shaahZmanis120Minutes] (solar hours) after [dawn][alos120] based on the opinion of the MGA that the day is calculated from a [dawn][alos120] of 120 minutes
 * before sunrise to [nightfall][tzais120] of 120 minutes after sunset. This returns the time of 3
 * [shaahZmanis120Minutes] after [dawn][alos120]. This is an extremely early *zman* that
 * is very much a *chumra*.
 *
 * @return the `Date` of the latest *zman krias shema*. If the calculation can't be computed such
 * as in the Arctic Circle where there is at least one day a year where the sun does not rise, and one where
 * it does not set, a null will be returned. See detailed explanation on top of the
 * [AstronomicalCalendar] documentation.
 * @see shaahZmanis120Minutes
 * @see alos120
 */
@property (readonly) STTZmanDateBased *sofZmanShmaMGA120Minutes __attribute__((swift_name("sofZmanShmaMGA120Minutes")));

/**
 * This method returns the latest *zman krias shema* (time to recite Shema in the morning) according to the
 * opinion of the [Magen Avraham (MGA)](https://en.wikipedia.org/wiki/Avraham_Gombinern) based
 * on *alos* being [16.1˚][alos16Point1Degrees] before [sunrise].
 *
 * This time is 3 [*shaos zmaniyos*][shaahZmanis16Point1Degrees] (solar hours) after
 * [dawn][alos16Point1Degrees] based on the opinion of the MGA that the day is calculated from
 * dawn to nightfall with both being 16.1 below sunrise or sunset. This returns the time of
 * 3 * [shaahZmanis16Point1Degrees] after [dawn][alos16Point1Degrees].
 *
 * @return the `Date` of the latest *zman krias shema*. If the calculation can't be computed such
 * as northern and southern locations even south of the Arctic Circle and north of the Antarctic Circle
 * where the sun may not reach low enough below the horizon for this calculation, a null will be returned.
 * See detailed explanation on top of the [AstronomicalCalendar] documentation.
 * @see shaahZmanis16Point1Degrees
 * @see alos16Point1Degrees
 */
@property (readonly) STTZmanDateBased *sofZmanShmaMGA16Point1Degrees __attribute__((swift_name("sofZmanShmaMGA16Point1Degrees")));

/**
 * This method returns [Rav Moshe Feinstein's](https://en.wikipedia.org/wiki/Moshe_Feinstein) opinion of the
 * calculation of *sof zman krias shema* (latest time to recite *Shema* in the morning) according to the
 * opinion of the [Magen Avraham (MGA)](https://en.wikipedia.org/wiki/Avraham_Gombinern) that the
 * day is calculated from dawn to nightfall, but calculated using the first half of the day only. The half a day starts
 * at *alos* defined as [16.1˚][alos16Point1Degrees] and ends at [fixed local]fixedLocalChatzos]. *Sof Zman Shema* is 3 *shaos zmaniyos* (solar hours) after this *alos* or half of this half-day.
 *
 * @return the `Date` of the latest *zman krias shema*. If the calculation can't be computed such
 * as northern and southern locations even south of the Arctic Circle and north of the Antarctic Circle
 * where the sun may not reach low enough below the horizon for this calculation, a null will be returned.
 * See detailed explanation on top of the [AstronomicalCalendar] documentation.
 * @see alos16Point1Degrees
 * @see fixedLocalChatzos
 * @see .getFixedLocalChatzosBasedZmanim
 */
@property (readonly) STTZmanDateBased *sofZmanShmaMGA16Point1DegreesToFixedLocalChatzos __attribute__((swift_name("sofZmanShmaMGA16Point1DegreesToFixedLocalChatzos")));

/**
 * This method returns the latest *zman krias shema* (time to recite Shema in the morning) according to the
 * opinion of the [Magen Avraham (MGA)](https://en.wikipedia.org/wiki/Avraham_Gombinern) based
 * on *alos* being [18˚][alos18Degrees] before [sunrise]. This time is 3
 * [*shaos zmaniyos*][shaahZmanis18Degrees] (solar hours) after [dawn][alos18Degrees]
 * based on the opinion of the MGA that the day is calculated from dawn to nightfall with both being 18
 * below sunrise or sunset. This returns the time of 3 * [shaahZmanis18Degrees] after [dawn][alos18Degrees].
 *
 * @return the `Date` of the latest *zman krias shema*. If the calculation can't be computed such
 * as northern and southern locations even south of the Arctic Circle and north of the Antarctic Circle
 * where the sun may not reach low enough below the horizon for this calculation, a null will be returned.
 * See detailed explanation on top of the [AstronomicalCalendar] documentation.
 * @see shaahZmanis18Degrees
 * @see alos18Degrees
 */
@property (readonly) STTZmanDateBased *sofZmanShmaMGA18Degrees __attribute__((swift_name("sofZmanShmaMGA18Degrees")));

/**
 * This method returns [Rav Moshe Feinstein's](https://en.wikipedia.org/wiki/Moshe_Feinstein) opinion of the
 * calculation of *sof zman krias shema* (latest time to recite *Shema* in the morning) according to the
 * opinion of the [Magen Avraham (MGA)](https://en.wikipedia.org/wiki/Avraham_Gombinern) that the
 * day is calculated from dawn to nightfall, but calculated using the first half of the day only. The half a day starts
 * at *alos* defined as [18˚][alos18Degrees] and ends at [fixed local]fixedLocalChatzos]. *Sof Zman Shema* is 3 *shaos zmaniyos* (solar hours) after *alos* or half of this half-day.
 *
 * @return the `Date` of the latest *zman krias shema*. If the calculation can't be computed such
 * as northern and southern locations even south of the Arctic Circle and north of the Antarctic Circle
 * where the sun may not reach low enough below the horizon for this calculation, a null will be returned.
 * See detailed explanation on top of the [AstronomicalCalendar] documentation.
 * @see alos18Degrees
 * @see fixedLocalChatzos
 * @see .getFixedLocalChatzosBasedZmanim
 */
@property (readonly) STTZmanDateBased *sofZmanShmaMGA18DegreesToFixedLocalChatzos __attribute__((swift_name("sofZmanShmaMGA18DegreesToFixedLocalChatzos")));

/**
 * This method returns the latest *zman krias shema* (time to recite Shema in the morning) according to the
 * opinion of the [Magen Avraham (MGA)](https://en.wikipedia.org/wiki/Avraham_Gombinern) based on
 * *alos* being [19.8˚][alos19Point8Degrees] before [sunrise].
 *
 * This time is 3 *[shaos zmaniyos][shaahZmanis19Point8Degrees]* (solar hours) after [alos19Point8Degrees],
 * based on the opinion of the MGA that the day is calculated from dawn to dusk, with both being 19.8 below
 * sunrise or sunset.
 *
 * This returns the time of 3 * [shaahZmanis19Point8Degrees] after [dawn][alos19Point8Degrees].
 *
 * @return the `Date` of the latest *zman krias shema*. If the calculation can't be computed such
 * as northern and southern locations even south of the Arctic Circle and north of the Antarctic Circle
 * where the sun may not reach low enough below the horizon for this calculation, a null will be returned.
 * See detailed explanation on top of the [AstronomicalCalendar] documentation.
 * @see shaahZmanis19Point8Degrees
 * @see alos19Point8Degrees
 */
@property (readonly) STTZmanDateBased *sofZmanShmaMGA19Point8Degrees __attribute__((swift_name("sofZmanShmaMGA19Point8Degrees")));

/**
 * This method returns the latest *zman krias shema* (time to recite Shema in the morning) according to the
 * opinion of the [Magen Avraham (MGA)](https://en.wikipedia.org/wiki/Avraham_Gombinern) based on
 * *alos* being [72][alos72] minutes before [sunrise]. This time is 3 [shaahZmanis72Minutes] (solar hours) after [dawn][alos72] based on the opinion
 * of the MGA that the day is calculated from a [dawn][alos72] of 72 minutes before sunrise to
 * [nightfall][tzais72] of 72 minutes after sunset. This returns the time of 3 * [shaahZmanis72Minutes] after [dawn][alos72].
 *
 * This class returns an identical time to [sofZmanShmaMGA] and is repeated here for clarity.
 *
 * @return the `Date` of the latest *zman krias shema*. If the calculation can't be computed such
 * as in the Arctic Circle where there is at least one day a year where the sun does not rise, and one where
 * it does not set, a null will be returned. See detailed explanation on top of the
 * [AstronomicalCalendar] documentation.
 * @see shaahZmanis72Minutes
 * @see alos72
 * @see sofZmanShmaMGA
 */
@property (readonly) STTZmanDateBased *sofZmanShmaMGA72Minutes __attribute__((swift_name("sofZmanShmaMGA72Minutes")));

/**
 * This method returns [Rav Moshe Feinstein's](https://en.wikipedia.org/wiki/Moshe_Feinstein) opinion of the
 * calculation of *sof zman krias shema* (latest time to recite *Shema* in the morning) according to the
 * opinion of the [Magen Avraham (MGA)](https://en.wikipedia.org/wiki/Avraham_Gombinern) that the
 * day is calculated from dawn to nightfall, but calculated using the first half of the day only. The half a day starts
 * at *alos* defined as [72 minutes before sunrise][alos72] and ends at [fixed local chatzos]fixedLocalChatzos]. *Sof Zman Shema* is 3 *shaos zmaniyos* (solar hours) after this *alos* or
 * half of this half-day.
 *
 * @return the `Date` of the latest *zman krias shema*. If the calculation can't be computed such
 * as northern and southern locations even south of the Arctic Circle and north of the Antarctic Circle
 * where the sun may not reach low enough below the horizon for this calculation, a null will be returned.
 * See detailed explanation on top of the [AstronomicalCalendar] documentation.
 * @see alos72
 * @see fixedLocalChatzos
 * @see .getFixedLocalChatzosBasedZmanim
 */
@property (readonly) STTZmanDateBased *sofZmanShmaMGA72MinutesToFixedLocalChatzos __attribute__((swift_name("sofZmanShmaMGA72MinutesToFixedLocalChatzos")));

/**
 * This method returns the latest *zman krias shema* (time to recite *Shema* in the morning) according
 * to the opinion of the [Magen Avraham (MGA)](https://en.wikipedia.org/wiki/Avraham_Gombinern) based
 * on *alos* being [72][alos72Zmanis] minutes *zmaniyos*, or 1/10th of the day before
 * [sunrise]. This time is 3 [*shaos zmaniyos*][shaahZmanis90MinutesZmanis]
 * (solar hours) after [dawn][alos72Zmanis] based on the opinion of the MGA that the day is calculated
 * from a [dawn][alos72Zmanis] of 72 minutes *zmaniyos*, or 1/10th of the day before
 * [sea level sunrise][seaLevelSunrise] to [nightfall][tzais72Zmanis] of 72 minutes
 * *zmaniyos* after [sea level sunset][seaLevelSunset]. This returns the time of 3 *
 * [shaahZmanis72MinutesZmanis] after [dawn][alos72Zmanis].
 *
 * @return the `Date` of the latest *zman krias shema*. If the calculation can't be computed such
 * as in the Arctic Circle where there is at least one day a year where the sun does not rise, and one where
 * it does not set, a null will be returned. See detailed explanation on top of the
 * [AstronomicalCalendar] documentation.
 * @see shaahZmanis72MinutesZmanis
 * @see alos72Zmanis
 */
@property (readonly) STTZmanDateBased *sofZmanShmaMGA72MinutesZmanis __attribute__((swift_name("sofZmanShmaMGA72MinutesZmanis")));

/**
 * This method returns the latest *zman krias shema* (time to recite *Shema* in the morning) according
 * to the opinion of the [Magen Avraham (MGA)](https://en.wikipedia.org/wiki/Avraham_Gombinern) based on
 * *alos* being [90][alos90] minutes before [sunrise]. This time is 3
 * [*shaos zmaniyos*][shaahZmanis90Minutes] (solar hours) after [dawn][alos90] based on
 * the opinion of the MGA that the day is calculated from a [dawn][alos90] of 90 minutes before sunrise to
 * [nightfall][tzais90] of 90 minutes after sunset. This returns the time of 3 *
 * [shaahZmanis90Minutes] after [dawn][alos90].
 *
 * @return the `Date` of the latest *zman krias shema*. If the calculation can't be computed such
 * as in the Arctic Circle where there is at least one day a year where the sun does not rise, and one where
 * it does not set, a null will be returned. See detailed explanation on top of the
 * [AstronomicalCalendar] documentation.
 * @see shaahZmanis90Minutes
 * @see alos90
 */
@property (readonly) STTZmanDateBased *sofZmanShmaMGA90Minutes __attribute__((swift_name("sofZmanShmaMGA90Minutes")));

/**
 * This method returns [Rav Moshe Feinstein's](https://en.wikipedia.org/wiki/Moshe_Feinstein) opinion of the
 * calculation of *sof zman krias shema* (latest time to recite *Shema* in the morning) according to the
 * opinion of the [Magen Avraham (MGA)](https://en.wikipedia.org/wiki/Avraham_Gombinern) that the
 * day is calculated from dawn to nightfall, but calculated using the first half of the day only. The half a day starts
 * at *alos* defined as [90 minutes before sunrise][alos90] and ends at [fixed local chatzos]fixedLocalChatzos]. *Sof Zman Shema* is 3 *shaos zmaniyos* (solar hours) after this *alos* or
 * half of this half-day.
 *
 * @return the `Date` of the latest *zman krias shema*. If the calculation can't be computed such
 * as northern and southern locations even south of the Arctic Circle and north of the Antarctic Circle
 * where the sun may not reach low enough below the horizon for this calculation, a null will be returned.
 * See detailed explanation on top of the [AstronomicalCalendar] documentation.
 * @see alos90
 * @see fixedLocalChatzos
 * @see .getFixedLocalChatzosBasedZmanim
 */
@property (readonly) STTZmanDateBased *sofZmanShmaMGA90MinutesToFixedLocalChatzos __attribute__((swift_name("sofZmanShmaMGA90MinutesToFixedLocalChatzos")));

/**
 * This method returns the latest *zman krias shema* (time to recite Shema in the morning) according to the
 * opinion of the [Magen Avraham (MGA)](https://en.wikipedia.org/wiki/Avraham_Gombinern) based
 * on *alos* being [90][alos90Zmanis] minutes *zmaniyos* before [sunrise][sunrise]. This time is 3 [*shaos zmaniyos*][shaahZmanis90MinutesZmanis] (solar hours) after
 * [dawn][alos90Zmanis] based on the opinion of the MGA that the day is calculated from a [alos90Zmanis] of 90 minutes *zmaniyos* before sunrise to [nightfall][tzais90Zmanis]
 * of 90 minutes *zmaniyos* after sunset. This returns the time of 3 * [shaahZmanis90MinutesZmanis]
 * after [dawn][alos90Zmanis].
 *
 * @return the `Date` of the latest *zman krias shema*. If the calculation can't be computed such
 * as in the Arctic Circle where there is at least one day a year where the sun does not rise, and one where
 * it does not set, a null will be returned. See detailed explanation on top of the
 * [AstronomicalCalendar] documentation.
 * @see shaahZmanis90MinutesZmanis
 * @see alos90Zmanis
 */
@property (readonly) STTZmanDateBased *sofZmanShmaMGA90MinutesZmanis __attribute__((swift_name("sofZmanShmaMGA90MinutesZmanis")));

/**
 * This method returns the latest *zman krias shema* (time to recite Shema in the morning) according to the
 * opinion of the [Magen Avraham (MGA)](https://en.wikipedia.org/wiki/Avraham_Gombinern) based
 * on *alos* being [96][alos96] minutes before [sunrise]. This time is 3
 * [*shaos zmaniyos*][shaahZmanis96Minutes] (solar hours) after [dawn][alos96] based on
 * the opinion of the MGA that the day is calculated from a [dawn][alos96] of 96 minutes before
 * sunrise to [nightfall][tzais96] of 96 minutes after sunset. This returns the time of 3 * [shaahZmanis96Minutes] after [dawn][alos96].
 *
 * @return the `Date` of the latest *zman krias shema*. If the calculation can't be computed such
 * as in the Arctic Circle where there is at least one day a year where the sun does not rise, and one where
 * it does not set, a null will be returned. See detailed explanation on top of the
 * [AstronomicalCalendar] documentation.
 * @see shaahZmanis96Minutes
 * @see alos96
 */
@property (readonly) STTZmanDateBased *sofZmanShmaMGA96Minutes __attribute__((swift_name("sofZmanShmaMGA96Minutes")));

/**
 * This method returns the latest *zman krias shema* (time to recite Shema in the morning) according to the
 * opinion of the [Magen Avraham (MGA)](https://en.wikipedia.org/wiki/Avraham_Gombinern) based
 * on *alos* being [96][alos90Zmanis] minutes *zmaniyos* before [sunrise][sunrise]. This time is 3 [*shaos zmaniyos*][shaahZmanis96MinutesZmanis] (solar hours) after
 * [dawn][alos96Zmanis] based on the opinion of the MGA that the day is calculated from a [alos96Zmanis] of 96 minutes *zmaniyos* before sunrise to [nightfall][tzais90Zmanis]
 * of 96 minutes *zmaniyos* after sunset. This returns the time of 3 * [shaahZmanis96MinutesZmanis]
 * after [dawn][alos96Zmanis].
 *
 * @return the `Date` of the latest *zman krias shema*. If the calculation can't be computed such
 * as in the Arctic Circle where there is at least one day a year where the sun does not rise, and one where
 * it does not set, a null will be returned. See detailed explanation on top of the
 * [AstronomicalCalendar] documentation.
 * @see shaahZmanis96MinutesZmanis
 * @see alos96Zmanis
 */
@property (readonly) STTZmanDateBased *sofZmanShmaMGA96MinutesZmanis __attribute__((swift_name("sofZmanShmaMGA96MinutesZmanis")));

/**
 * This method returns the latest *zman tfila* (time to recite the morning prayers) calculated as 2 hours
 * before [ZmanimCalendar.getChatzos]. This is based on the opinions that calculate
 * *sof zman krias shema* as [sofZmanShma3HoursBeforeChatzos]. This returns the time of 2 hours
 * before [ZmanimCalendar.getChatzos].
 *
 * @return the `Date` of the latest *zman krias shema*. If the calculation can't be computed such
 * as in the Arctic Circle where there is at least one day a year where the sun does not rise, and one where
 * it does not set, a null will be returned. See detailed explanation on top of the
 * [AstronomicalCalendar] documentation.
 * @see ZmanimCalendar.getChatzos
 * @see sofZmanShma3HoursBeforeChatzos
 */
@property (readonly) STTZmanDateBased *sofZmanTfila2HoursBeforeChatzos __attribute__((swift_name("sofZmanTfila2HoursBeforeChatzos")));

/**
 * This method returns the latest *zman tfilah* (time to recite the morning prayers). This time is 4
 * hours into the day based on the opinion of the Baal Hatanya that the day is
 * calculated from sunrise to sunset. This returns the time 4 * [shaahZmanisBaalHatanya] after
 * [*netz amiti* (sunrise)][sunriseBaalHatanya].
 *
 * @see ZmanimCalendar.getSofZmanTfila
 * @see shaahZmanisBaalHatanya
 * @return the `Date` of the latest *zman tfilah*. If the calculation can't be computed such as in
 * the Arctic Circle where there is at least one day a year where the sun does not rise, and one where it does
 * not set, a null will be returned. See detailed explanation on top of the [AstronomicalCalendar]
 * documentation.
 */
@property (readonly) STTZmanDateBased *sofZmanTfilaBaalHatanya __attribute__((swift_name("sofZmanTfilaBaalHatanya")));

/**
 * This method returns [Rav Moshe Feinstein's](https://en.wikipedia.org/wiki/Moshe_Feinstein) opinion of the
 * calculation of *sof zman tfila* (*zman tfilah* (the latest time to recite the morning prayers))
 * according to the opinion of the [GRA](https://en.wikipedia.org/wiki/Vilna_Gaon) that the day is
 * calculated from sunrise to sunset, but calculated using the first half of the day only. The half a day starts at
 * [sunrise] and ends at [fixed local chatzos]fixedLocalChatzos]. *Sof zman tefila*
 * is 4 *shaos zmaniyos* (solar hours) after sunrise or 2/3 of this half-day.
 *
 * @return the `Date` of the latest *zman krias shema*. If the calculation can't be computed such
 * as northern and southern locations even south of the Arctic Circle and north of the Antarctic Circle
 * where the sun may not reach low enough below the horizon for this calculation, a null will be returned.
 * See detailed explanation on top of the [AstronomicalCalendar] documentation.
 * @see sunrise
 * @see fixedLocalChatzos
 * @see .getFixedLocalChatzosBasedZmanim
 */
@property (readonly) STTZmanDateBased *sofZmanTfilaGRASunriseToFixedLocalChatzos __attribute__((swift_name("sofZmanTfilaGRASunriseToFixedLocalChatzos")));

/**
 * This method returns the latest *zman tfila* (time to recite the morning prayers) according to the opinion
 * of the [Magen Avraham (MGA)](https://en.wikipedia.org/wiki/Avraham_Gombinern) based on
 * *alos* being [120][alos120] minutes before [sunrise] . This time is 4
 * [*shaos zmaniyos*][shaahZmanis120Minutes] (solar hours) after [dawn][alos120]
 * based on the opinion of the MGA that the day is calculated from a [dawn][alos120] of 120
 * minutes before sunrise to [nightfall][tzais120] of 120 minutes after sunset. This returns the time of
 * 4 * [shaahZmanis120Minutes] after [dawn][alos120]. This is an extremely early *zman*
 * that is very much a *chumra*.
 *
 * @return the `Date` of the latest *zman krias shema*. If the calculation can't be computed such
 * as in the Arctic Circle where there is at least one day a year where the sun does not rise, and one where
 * it does not set, a null will be returned. See detailed explanation on top of the
 * [AstronomicalCalendar] documentation.
 * @see shaahZmanis120Minutes
 * @see alos120
 */
@property (readonly) STTZmanDateBased *sofZmanTfilaMGA120Minutes __attribute__((swift_name("sofZmanTfilaMGA120Minutes")));

/**
 * This method returns the latest *zman tfila* (time to recite the morning prayers) according to the opinion
 * of the [Magen Avraham (MGA)](https://en.wikipedia.org/wiki/Avraham_Gombinern) based on
 * *alos* being [16.1˚][alos16Point1Degrees] before [sunrise].
 *
 * This time is 4 [*shaos zmaniyos*][shaahZmanis16Point1Degrees] (solar hours) after [alos16Point1Degrees]
 * based on the opinion of the MGA that the day is calculated from dawn to nightfall,
 * with both being 16.1 below sunrise or sunset.
 *
 * This returns the time of 4 * [shaahZmanis16Point1Degrees] after [dawn][alos16Point1Degrees].
 *
 * @return the `Date` of the latest *zman krias shema*. If the calculation can't be computed such
 * as northern and southern locations even south of the Arctic Circle and north of the Antarctic Circle
 * where the sun may not reach low enough below the horizon for this calculation, a null will be returned.
 * See detailed explanation on top of the [AstronomicalCalendar] documentation.
 *
 * @see shaahZmanis16Point1Degrees
 * @see alos16Point1Degrees
 */
@property (readonly) STTZmanDateBased *sofZmanTfilaMGA16Point1Degrees __attribute__((swift_name("sofZmanTfilaMGA16Point1Degrees")));

/**
 * This method returns the latest *zman tfila* (time to recite the morning prayers) according to the opinion
 * of the [Magen Avraham (MGA)](https://en.wikipedia.org/wiki/Avraham_Gombinern) based on
 * *alos* being [18˚][alos18Degrees] before [sunrise]. This time is 4
 * [*shaos zmaniyos*][shaahZmanis18Degrees] (solar hours) after [dawn][alos18Degrees]
 * based on the opinion of the MGA that the day is calculated from dawn to nightfall with both being 18
 * below sunrise or sunset. This returns the time of 4 * [shaahZmanis18Degrees] after
 * [dawn][alos18Degrees].
 *
 * @return the `Date` of the latest *zman krias shema*. If the calculation can't be computed such
 * as northern and southern locations even south of the Arctic Circle and north of the Antarctic Circle
 * where the sun may not reach low enough below the horizon for this calculation, a null will be returned.
 * See detailed explanation on top of the [AstronomicalCalendar] documentation.
 *
 * @see shaahZmanis18Degrees
 * @see alos18Degrees
 */
@property (readonly) STTZmanDateBased *sofZmanTfilaMGA18Degrees __attribute__((swift_name("sofZmanTfilaMGA18Degrees")));

/**
 * This method returns the latest *zman tfila* (time to recite the morning prayers) according to the opinion
 * of the [Magen Avraham (MGA)](https://en.wikipedia.org/wiki/Avraham_Gombinern) based on
 * *alos* being [19.8˚][alos19Point8Degrees] before [sunrise].
 *
 * This time is 4 [*shaos zmaniyos*][shaahZmanis19Point8Degrees] (solar hours) after [alos19Point8Degrees] based on the opinion of the MGA that the day is calculated from dawn to
 * nightfall with both being 19.8 below sunrise or sunset.
 *
 * This returns the time of 4 * [shaahZmanis19Point8Degrees] after [dawn][alos19Point8Degrees].
 *
 * @return the `Date` of the latest *zman krias shema*. If the calculation can't be computed such
 * as northern and southern locations even south of the Arctic Circle and north of the Antarctic Circle
 * where the sun may not reach low enough below the horizon for this calculation, a null will be returned.
 * See detailed explanation on top of the [AstronomicalCalendar] documentation.
 *
 * @see shaahZmanis19Point8Degrees
 * @see alos19Point8Degrees
 */
@property (readonly) STTZmanDateBased *sofZmanTfilaMGA19Point8Degrees __attribute__((swift_name("sofZmanTfilaMGA19Point8Degrees")));

/**
 * This method returns the latest *zman tfila* (time to recite the morning prayers) according to the opinion
 * of the [Magen Avraham (MGA)](https://en.wikipedia.org/wiki/Avraham_Gombinern) based on
 * *alos* being [72][alos72] minutes before [sunrise]. This time is 4
 * [*shaos zmaniyos*][shaahZmanis72Minutes] (solar hours) after [dawn][alos72] based on
 * the opinion of the MGA that the day is calculated from a [dawn][alos72] of 72 minutes before
 * sunrise to [nightfall][tzais72] of 72 minutes after sunset. This returns the time of 4 *
 * [shaahZmanis72Minutes] after [dawn][alos72]. This class returns an identical time to
 * [sofZmanTfilaMGA] and is repeated here for clarity.
 *
 * @return the `Date` of the latest *zman tfila*. If the calculation can't be computed such as in
 * the Arctic Circle where there is at least one day a year where the sun does not rise, and one where it
 * does not set, a null will be returned. See detailed explanation on top of the
 * [AstronomicalCalendar] documentation.
 * @see shaahZmanis72Minutes
 * @see alos72
 * @see sofZmanShmaMGA
 */
@property (readonly) STTZmanDateBased *sofZmanTfilaMGA72Minutes __attribute__((swift_name("sofZmanTfilaMGA72Minutes")));

/**
 * This method returns the latest *zman tfila* (time to the morning prayers) according to the opinion of the
 * [Magen Avraham (MGA)](https://en.wikipedia.org/wiki/Avraham_Gombinern) based on *alos*
 * being [72][alos72Zmanis] minutes *zmaniyos* before [sunrise]. This time is 4
 * [*shaos zmaniyos*][shaahZmanis72MinutesZmanis] (solar hours) after [dawn][alos72Zmanis]
 * based on the opinion of the MGA that the day is calculated from a [dawn][alos72Zmanis] of 72
 * minutes *zmaniyos* before sunrise to [nightfall][tzais72Zmanis] of 72 minutes *zmaniyos*
 * after sunset. This returns the time of 4 * [shaahZmanis72MinutesZmanis] after [dawn][alos72Zmanis].
 *
 * @return the `Date` of the latest *zman krias shema*. If the calculation can't be computed such
 * as in the Arctic Circle where there is at least one day a year where the sun does not rise,ZmanCalculationMethod.FixedDuration(72), and one where
 * it does not set, a null will be returned. See detailed explanation on top of the
 * [AstronomicalCalendar] documentation.
 * @see shaahZmanis72MinutesZmanis
 * @see alos72Zmanis
 */
@property (readonly) STTZmanDateBased *sofZmanTfilaMGA72MinutesZmanis __attribute__((swift_name("sofZmanTfilaMGA72MinutesZmanis")));

/**
 * This method returns the latest *zman tfila* (time to recite the morning prayers) according to the opinion
 * of the [Magen Avraham (MGA)](https://en.wikipedia.org/wiki/Avraham_Gombinern) based on
 * *alos* being [90][alos90] minutes before [sunrise]. This time is 4
 * [*shaos zmaniyos*][shaahZmanis90Minutes] (solar hours) after [dawn][alos90] based on
 * the opinion of the MGA that the day is calculated from a [dawn][alos90] of 90 minutes before sunrise to
 * [nightfall][tzais90] of 90 minutes after sunset. This returns the time of 4 *
 * [shaahZmanis90Minutes] after [dawn][alos90].
 *
 * @return the `Date` of the latest *zman tfila*. If the calculation can't be computed such as in
 * the Arctic Circle where there is at least one day a year where the sun does not rise, and one where it
 * does not set, a null will be returned. See detailed explanation on top of the
 * [AstronomicalCalendar] documentation.
 * @see shaahZmanis90Minutes
 * @see alos90
 */
@property (readonly) STTZmanDateBased *sofZmanTfilaMGA90Minutes __attribute__((swift_name("sofZmanTfilaMGA90Minutes")));

/**
 * This method returns the latest *zman tfila* (time to the morning prayers) according to the opinion of the
 * [Magen Avraham (MGA)](https://en.wikipedia.org/wiki/Avraham_Gombinern) based on *alos*
 * being [90][alos90Zmanis] minutes *zmaniyos* before [sunrise]. This time is
 * 4 [*shaos zmaniyos*][shaahZmanis90MinutesZmanis] (solar hours) after [dawn][alos90Zmanis] based on the opinion of the MGA that the day is calculated from a [dawn][alos90Zmanis]
 * of 90 minutes *zmaniyos* before sunrise to [nightfall][tzais90Zmanis] of 90 minutes
 * *zmaniyos* after sunset. This returns the time of 4 * [shaahZmanis90MinutesZmanis] after
 * [dawn][alos90Zmanis].
 *
 * @return the `Date` of the latest *zman krias shema*. If the calculation can't be computed such
 * as in the Arctic Circle where there is at least one day a year where the sun does not rise, and one where
 * it does not set, a null will be returned. See detailed explanation on top of the
 * [AstronomicalCalendar] documentation.
 * @see shaahZmanis90MinutesZmanis
 * @see alos90Zmanis
 */
@property (readonly) STTZmanDateBased *sofZmanTfilaMGA90MinutesZmanis __attribute__((swift_name("sofZmanTfilaMGA90MinutesZmanis")));

/**
 * This method returns the latest *zman tfila* (time to recite the morning prayers) according to the opinion
 * of the [Magen Avraham (MGA)](https://en.wikipedia.org/wiki/Avraham_Gombinern) based on
 * *alos* being [96][alos96] minutes before [sunrise]. This time is 4
 * [*shaos zmaniyos*][shaahZmanis96Minutes] (solar hours) after [dawn][alos96] based on
 * the opinion of the MGA that the day is calculated from a [dawn][alos96] of 96 minutes before
 * sunrise to [nightfall][tzais96] of 96 minutes after sunset. This returns the time of 4 *
 * [shaahZmanis96Minutes] after [dawn][alos96].
 *
 * @return the `Date` of the latest *zman tfila*. If the calculation can't be computed such as in
 * the Arctic Circle where there is at least one day a year where the sun does not rise, and one where it
 * does not set, a null will be returned. See detailed explanation on top of the
 * [AstronomicalCalendar] documentation.
 * @see shaahZmanis96Minutes
 * @see alos96
 */
@property (readonly) STTZmanDateBased *sofZmanTfilaMGA96Minutes __attribute__((swift_name("sofZmanTfilaMGA96Minutes")));

/**
 * This method returns the latest *zman tfila* (time to the morning prayers) according to the opinion of the
 * [Magen Avraham (MGA)](https://en.wikipedia.org/wiki/Avraham_Gombinern) based on *alos*
 * being [96][alos96Zmanis] minutes *zmaniyos* before [sunrise]. This time is
 * 4 [*shaos zmaniyos*][shaahZmanis96MinutesZmanis] (solar hours) after [dawn][alos96Zmanis] based on the opinion of the MGA that the day is calculated from a [dawn][alos96Zmanis]
 * of 96 minutes *zmaniyos* before sunrise to [nightfall][tzais96Zmanis] of 96 minutes
 * *zmaniyos* after sunset. This returns the time of 4 * [shaahZmanis96MinutesZmanis] after
 * [dawn][alos96Zmanis].
 *
 * @return the `Date` of the latest *zman krias shema*. If the calculation can't be computed such
 * as in the Arctic Circle where there is at least one day a year where the sun does not rise, and one where
 * it does not set, a null will be returned. See detailed explanation on top of the
 * [AstronomicalCalendar] documentation.
 * @see shaahZmanis90MinutesZmanis
 * @see alos90Zmanis
 */
@property (readonly) STTZmanDateBased *sofZmanTfilaMGA96MinutesZmanis __attribute__((swift_name("sofZmanTfilaMGA96MinutesZmanis")));

/**
 * This method returns the latest *zman tfila* (time to recite the morning prayers) based on the calculation
 * of *Chacham* Yosef Harari-Raful of Yeshivat Ateret Torah, that the day starts [1/10th of the day][alos72Zmanis]
 * before sunrise and is usually calculated as ending [40 minutes][tzaisAteretTorah] (configurable to any offset via
 * setting [ateretTorahSunsetOffset]).
 *
 * *shaos zmaniyos* are calculated based on this day and added to [*alos*][alos72Zmanis] to reach this time. This time
 * is 4 * [*shaos zmaniyos*][shaahZmanisAteretTorah] (temporal hours) after
 * [*alos* 72 zmaniyos][alos72Zmanis].
 * **Note: ** Based on this calculation *chatzos* will not be at midday.
 *
 * @return the `Date` of the latest *zman krias shema* based on this calculation. If the
 * calculation can't be computed such as in the Arctic Circle where there is at least one day a year where
 * the sun does not rise, and one where it does not set, a null will be returned. See detailed explanation
 * on top of the [AstronomicalCalendar] documentation.
 * @see alos72Zmanis
 * @see tzaisAteretTorah
 * @see shaahZmanisAteretTorah
 * @see .setAteretTorahSunsetOffset
 */
@property (readonly) STTZmanDateBased *sofZmanTfilahAteretTorah __attribute__((swift_name("sofZmanTfilahAteretTorah")));

/**
 * A method that returns "solar" midnight, or the time when the sun is at its [nadir](https://en.wikipedia.org/wiki/Nadir).
 * **Note:** this method is experimental and might be removed.
 *
 * @return the `Date` of Solar Midnight (chatzos layla). If the calculation can't be computed such as in
 * the Arctic Circle where there is at least one day a year where the sun does not rise, and one where it
 * does not set, a null will be returned. See detailed explanation on top of the
 * [AstronomicalCalendar] documentation.
 */
@property (readonly) STTZmanDateBased *solarMidnight __attribute__((swift_name("solarMidnight")));

/**
 * Returns the earliest time of *Kiddush Levana* according to [Rabbeinu Yonah](https://en.wikipedia.org/wiki/Yonah_Gerondi)'s opinion that it can be said 3 days after the
 * *molad*. The time will be returned even if it occurs during the day when *Kiddush Levana* can't be said.
 * Use [getTchilasZmanKidushLevana3Days] if you want to limit the time to night hours.
 *
 * @return the Date representing the moment 3 days after the molad.
 * @see getTchilasZmanKidushLevana3Days
 * @see getTchilasZmanKidushLevana7Days
 * @see JewishCalendar.tchilasZmanKidushLevana3Days
 */
@property (readonly) STTZmanDateBased *tchilasZmanKidushLevana3Days __attribute__((swift_name("tchilasZmanKidushLevana3Days")));

/**
 * Returns the earliest time of *Kiddush Levana* according to the opinions that it should not be said until 7
 * days after the *molad*. The time will be returned even if it occurs during the day when *Kiddush Levana*
 * can't be recited. Use [getTchilasZmanKidushLevana7Days] if you want to limit the time to night hours.
 *
 * @return the Date representing the moment 7 days after the molad regardless of it is day or night.
 * @see getTchilasZmanKidushLevana7Days
 * @see JewishCalendar.getTchilasZmanKidushLevana7Days
 * @see getTchilasZmanKidushLevana3Days
 */
@property (readonly) STTZmanDateBased *tchilasZmanKidushLevana7Days __attribute__((swift_name("tchilasZmanKidushLevana7Days")));
@property (readonly) NSDictionary<STTZmanType *, NSArray<STTZmanDateBased *> *> *typeToZman __attribute__((swift_name("typeToZman")));

/**
 * This method should be used *lechumra* only and returns *tzais* (nightfall) based on the calculations
 * of [Rav Chaim Naeh](https://en.wikipedia.org/wiki/Avraham_Chaim_Naeh) that the time to walk the
 * distance of a *Mil* according to the [Rambam](https://en.wikipedia.org/wiki/Maimonides)'s opinion
 * is 2/5 of an hour (24 minutes) for a total of 120 minutes based on the opinion of *Ula* who calculated
 * *tzais* as 5 *Mil* after sea level *shkiah* (sunset). A similar calculation [][tzais26Degrees] uses degree-based calculations based on this 120 minute calculation. Since the *zman*
 * is extremely late and at a point that is long past the 18 point where the darkest point is
 * reached, it should only be used *lechumra*, such as delaying the start of nighttime *mitzvos*.
 *
 * @return the `Date` representing the time. If the calculation can't be computed such as in the Arctic
 * Circle where there is at least one day a year where the sun does not rise, and one where it does not set,
 * a null will be returned. See detailed explanation on top of the [AstronomicalCalendar].
 * documentation.
 * @see tzais26Degrees
 * @see alos120
 */
@property (readonly) STTZmanDateBased *tzais120 __attribute__((swift_name("tzais120"))) __attribute__((deprecated("This method should be used <em>lechumra</em> only since it returns a very late time, and if used\n	          <em>lekula</em> can result in <em>chillul Shabbos</em> etc. There is no current plan to remove this\n	          method from the API, and this deprecation is intended to alert developers of the danger of using it.\n	  \n	  ")));

/**
 * This method should be used *lechumra* only and returns *tzais* (dusk) calculated using 120 minutes
 * *zmaniyos* after [sea level sunset][seaLevelSunset]. Since the *zman*
 * is extremely late and at a point when the it is long past the 18 point where the darkest point is
 * reached, it should only be used *lechumra*, such as delaying the start of nighttime *mitzvos*.
 *
 * @return the `Date` representing the time. If the calculation can't be computed such as in the Arctic
 * Circle where there is at least one day a year where the sun does not rise, and one where it does not set,
 * a null will be returned. See detailed explanation on top of the [AstronomicalCalendar]
 * documentation.
 * @see alos120Zmanis
 * @see tzais120
 * @see tzais26Degrees
 */
@property (readonly) STTZmanDateBased *tzais120Zmanis __attribute__((swift_name("tzais120Zmanis"))) __attribute__((deprecated("This method should be used <em>lechumra</em> only since it returns a very late time, and if used\n	          <em>lekula</em> can result in <em>chillul Shabbos</em> etc. There is no current plan to remove this\n	          method from the API, and this deprecation is intended to alert developers of the danger of using it.\n	  \n	  ")));

/**
 * This calculates the time of *tzais* at the point when the sun is 16.1 below the horizon. This is
 * the sun's dip below the horizon 72 minutes after sunset according Rabbeinu Tam's calculation of *tzais*
 * [around the equinox / equilux](https://kosherjava.com/2022/01/12/equinox-vs-equilux-zmanim-calculations/) in
 * Jerusalem. The question of equinox VS equilux is complex, with Rabbi Meir Posen in the [Ohr Meir](https://www.worldcat.org/oclc/956316270) of the opinion that the equilux should be used. See
 * Yisrael Vehazmanim vol I, 34:1:4. Rabbi Yedidya Manet in his [Zmanei Halacha Lema'aseh](https://www.nli.org.il/en/books/NNL_ALEPH002542826/NLI) (4th edition part 2, pages
 * and 22 and 24) and Rabbi Yonah Metzbuch (in a letter published by Rabbi Manet) are of the opinion that the
 * astronomical equinox should be used. The difference adds up to about 9 seconds, too trivial to make much of a
 * difference. For information on how this is calculated see the comments on [alos16Point1Degrees].
 *
 * @return the `Date` representing the time. If the calculation can't be computed such as northern and
 * southern locations even south of the Arctic Circle and north of the Antarctic Circle where the sun may
 * not reach low enough below the horizon for this calculation, a null will be returned. See detailed
 * explanation on top of the [AstronomicalCalendar] documentation.
 * @see tzais72
 * @see alos16Point1Degrees
 */
@property (readonly) STTZmanDateBased *tzais16Point1Degrees __attribute__((swift_name("tzais16Point1Degrees")));

/**
 * For information on how this is calculated see the comments on [alos18Degrees]
 *
 * @return the `Date` representing the time. If the calculation can't be computed such as northern and
 * southern locations even south of the Arctic Circle and north of the Antarctic Circle where the sun may
 * not reach low enough below the horizon for this calculation, a null will be returned. See detailed
 * explanation on top of the [AstronomicalCalendar] documentation.
 * @see alos18Degrees
 */
@property (readonly) STTZmanDateBased *tzais18Degrees __attribute__((swift_name("tzais18Degrees")));

/**
 * For information on how this is calculated see the comments on [alos19Point8Degrees]
 *
 * @return the `Date` representing the time. If the calculation can't be computed such as northern and
 * southern locations even south of the Arctic Circle and north of the Antarctic Circle where the sun may
 * not reach low enough below the horizon for this calculation, a null will be returned. See detailed
 * explanation on top of the [AstronomicalCalendar] documentation.
 * @see tzais90
 * @see alos19Point8Degrees
 */
@property (readonly) STTZmanDateBased *tzais19Point8Degrees __attribute__((swift_name("tzais19Point8Degrees")));

/**
 * This method should be used *lechumra* only and returns *tzais* based on when the sun is 26
 * below the horizon.For information on how this is calculated see the comments on [alos26Degrees].
 * Since the *zman* is extremely late and at a point when it is long past the 18 point where the
 * darkest point is reached, it should only be used *lechumra* such as delaying the start of nighttime
 * *mitzvos*.
 *
 * @return the `Date` representing the time. If the calculation can't be computed such as northern and
 * southern locations even south of the Arctic Circle and north of the Antarctic Circle where the sun may
 * not reach low enough below the horizon for this calculation, a null will be returned. See detailed
 * explanation on top of the [AstronomicalCalendar] documentation.
 * @see tzais120
 * @see alos26Degrees
 */
@property (readonly) STTZmanDateBased *tzais26Degrees __attribute__((swift_name("tzais26Degrees"))) __attribute__((deprecated("This method should be used <em>lechumra</em> only since it returns a very late time, and if used\n	          <em>lekula</em> can result in <em>chillul Shabbos</em> etc. There is no current plan to remove this\n	          method from the API, and this deprecation is intended to alert developers of the danger of using it.\n	  \n	  ")));

/**
 * Method to return *tzais* (dusk) calculated as 50 minutes after sea level sunset. This method returns
 * *tzais* (nightfall) based on the opinion of Rabbi Moshe Feinstein for the New York area. This time should
 * not be used for latitudes different than the NY area.
 *
 * @return the `Date` representing the time. If the calculation can't be computed such as in the Arctic
 * Circle where there is at least one day a year where the sun does not rise, and one where it does not set,
 * a null will be returned. See detailed explanation on top of the [AstronomicalCalendar]
 * documentation.
 */
@property (readonly) STTZmanDateBased *tzais50 __attribute__((swift_name("tzais50")));

/**
 * This method returns the *tzais* (nightfall) based on the opinion of the [Chavas Yair](https://en.wikipedia.org/wiki/Yair_Bacharach) and [Divrei Malkiel](https://he.wikipedia.org/wiki/%D7%9E%D7%9C%D7%9B%D7%99%D7%90%D7%9C_%D7%A6%D7%91%D7%99_%D7%98%D7%A0%D7%A0%D7%91%D7%95%D7%99%D7%9D) that the time to walk the distance of a *Mil* is 15 minutes for a total of 60 minutes
 * for 4 *Mil* after [sea level sunset][seaLevelSunset]. See detailed documentation explaining the
 * 60 minute concept at [alos60].
 *
 * @return the `Date` representing 60 minutes after sea level sunset. If the calculation can't be
 * computed such as in the Arctic Circle where there is at least one day a year where the sun does not rise,
 * and one where it does not set, a null will be returned. See detailed explanation on top of the
 * [AstronomicalCalendar] documentation.
 *
 * @see alos60
 * @see .getPlagHamincha60Minutes
 * @see shaahZmanis60Minutes
 */
@property (readonly) STTZmanDateBased *tzais60 __attribute__((swift_name("tzais60")));

/**
 * Method to return *tzais* (dusk) calculated as 72 minutes zmaniyos, or 1/10th of the day after
 * [sea level sunset][seaLevelSunset]. This is the way that the [Minchas Cohen](https://en.wikipedia.org/wiki/Abraham_Cohen_Pimentel) in Ma'amar 2:4 calculates Rebbeinu Tam's
 * time of *tzeis*. It should be noted that this calculation results in the shortest time from sunset to
 * *tzais* being during the winter solstice, the longest at the summer solstice and 72 clock minutes at the
 * equinox. This does not match reality, since there is no direct relationship between the length of the day and
 * twilight. The shortest twilight is during the equinox, the longest is during the the summer solstice, and in the
 * winter with the shortest daylight, the twilight period is longer than during the equinoxes.
 *
 * @return the `Date` representing the time. If the calculation can't be computed such as in the Arctic
 * Circle where there is at least one day a year where the sun does not rise, and one where it does not set,
 * a null will be returned. See detailed explanation on top of the [AstronomicalCalendar]
 * documentation.
 * @see alos72Zmanis
 */
@property (readonly) STTZmanDateBased *tzais72Zmanis __attribute__((swift_name("tzais72Zmanis")));

/**
 * Method to return *tzais* (dusk) calculated as 90 minutes after sea level sunset. This method returns
 * *tzais* (nightfall) based on the opinion of the Magen Avraham that the time to walk the distance of a
 * *Mil* according to the [Rambam](https://en.wikipedia.org/wiki/Maimonides)'s opinion
 * is 18 minutes for a total of 90 minutes based on the opinion of Ula who calculated *tzais* as 5
 * *Mil* after sea level *shkiah* (sunset). A similar calculation [tzais19Point8Degrees]
 * uses solar position calculations based on this time.
 *
 * @return the `Date` representing the time. If the calculation can't be computed such as in the Arctic
 * Circle where there is at least one day a year where the sun does not rise, and one where it does not set,
 * a null will be returned. See detailed explanation on top of the [AstronomicalCalendar]
 * documentation.
 * @see tzais19Point8Degrees
 * @see alos90
 */
@property (readonly) STTZmanDateBased *tzais90 __attribute__((swift_name("tzais90")));

/**
 * Method to return *tzais* (dusk) calculated using 90 minutes zmaniyos or 1/8th of the day after [seaLevelSunset]. This time is known in Yiddish as the *achtel* (an eighth)
 * *zman*.
 *
 * @return the `Date` representing the time. If the calculation can't be computed such as in the Arctic
 * Circle where there is at least one day a year where the sun does not rise, and one where it does not set,
 * a null will be returned. See detailed explanation on top of the [AstronomicalCalendar]
 * documentation.
 * @see alos90Zmanis
 */
@property (readonly) STTZmanDateBased *tzais90Zmanis __attribute__((swift_name("tzais90Zmanis")));

/**
 * A method to return *tzais* (dusk) calculated as 96 minutes after sea level sunset. For information on how
 * this is calculated see the comments on [alos96].
 *
 * @return the `Date` representing the time. If the calculation can't be computed such as in the Arctic
 * Circle where there is at least one day a year where the sun does not rise, and one where it does not set,
 * a null will be returned. See detailed explanation on top of the [AstronomicalCalendar]
 * documentation.
 * @see alos96
 */
@property (readonly) STTZmanDateBased *tzais96 __attribute__((swift_name("tzais96")));

/**
 * Method to return *tzais* (dusk) calculated using 96 minutes *zmaniyos* or 1/7.5 of the day after
 * [sea level sunset][seaLevelSunset].
 *
 * @return the `Date` representing the time. If the calculation can't be computed such as in the Arctic
 * Circle where there is at least one day a year where the sun does not rise, and one where it does not set,
 * a null will be returned. See detailed explanation on top of the [AstronomicalCalendar]
 * documentation.
 * @see alos96Zmanis
 */
@property (readonly) STTZmanDateBased *tzais96Zmanis __attribute__((swift_name("tzais96Zmanis")));

/**
 * This method returns *tzais* usually calculated as 40 minutes (configurable to any offset via
 * [.setAteretTorahSunsetOffset]) after sunset. Please note that *Chacham* Yosef Harari-Raful
 * of Yeshivat Ateret Torah who uses this time, does so only for calculating various other *zmanai hayom*
 * such as *Sof Zman Krias Shema* and *Plag Hamincha*. His calendars do not publish a *zman*
 * for *Tzais*. It should also be noted that *Chacham* Harari-Raful provided a 25 minute *zman*
 * for Israel. This API uses 40 minutes year round in any place on the globe by default. This offset can be change
 * by calling [.setAteretTorahSunsetOffset].
 *
 * @return the `Date` representing 40 minutes (configurable via [.setAteretTorahSunsetOffset])
 * after sea level sunset. If the calculation can't be computed such as in the Arctic Circle where there is
 * at least one day a year where the sun does not rise, and one where it does not set, a null will be
 * returned. See detailed explanation on top of the [AstronomicalCalendar] documentation.
 * @see ateretTorahSunsetOffset
 * @see .setAteretTorahSunsetOffset
 */
@property (readonly) STTZmanDateBased *tzaisAteretTorah __attribute__((swift_name("tzaisAteretTorah")));

/**
 * A method that returns *tzais* (nightfall) when the sun is 6 below the western geometric horizon
 * (90) after [sunset][sunset]. For information on the source of this calculation see
 * [ZENITH_6_DEGREES].
 *
 * @return The `Date` of nightfall. If the calculation can't be computed such as northern and southern
 * locations even south of the Arctic Circle and north of the Antarctic Circle where the sun may not reach
 * low enough below the horizon for this calculation, a null will be returned. See detailed explanation on
 * top of the [AstronomicalCalendar] documentation.
 * @see ZENITH_6_DEGREES
 */
@property (readonly) STTZmanDateBased *tzaisBaalHatanya __attribute__((swift_name("tzaisBaalHatanya")));

/**
 * This method returns the *tzais* (nightfall) based on the opinion of the *Geonim* calculated as 3/4
 * of a [Mil](https://en.wikipedia.org/wiki/Biblical_and_Talmudic_units_of_measurement) based on an 18
 * minute Mil, or 13.5 minutes. It is the sun's position at [3.65˚][ZENITH_3_POINT_65] below the western
 * horizon. This is a very early *zman* and should not be relied on without Rabbinical guidance.
 *
 * @return the `Date` representing the time when the sun is 3.65 below sea level. If the calculation
 * can't be computed such as northern and southern locations even south of the Arctic Circle and north of
 * the Antarctic Circle where the sun may not reach low enough below the horizon for this calculation, a
 * null will be returned. See detailed explanation on top of the [AstronomicalCalendar] documentation.
 * @see ZENITH_3_POINT_65
 */
@property (readonly) STTZmanDateBased *tzaisGeonim3Point65Degrees __attribute__((swift_name("tzaisGeonim3Point65Degrees")));

/**
 * This method returns the *tzais* (nightfall) based on the opinion of the *Geonim* calculated as 3/4
 * of a [Mil](https://en.wikipedia.org/wiki/Biblical_and_Talmudic_units_of_measurement) based on an 18
 * minute Mil, or 13.5 minutes. It is the sun's position at [3.676˚][ZENITH_3_POINT_676] below the western
 * horizon based on the calculations of Stanley Fishkind. This is a very early *zman* and should not be
 * relied on without Rabbinical guidance.
 *
 * @return the `Date` representing the time when the sun is 3.676 below sea level. If the
 * calculation can't be computed such as northern and southern locations even south of the Arctic Circle and
 * north of the Antarctic Circle where the sun may not reach low enough below the horizon for this
 * calculation, a null will be returned. See detailed explanation on top of the [AstronomicalCalendar]
 * documentation.
 * @see ZENITH_3_POINT_676
 */
@property (readonly) STTZmanDateBased *tzaisGeonim3Point676Degrees __attribute__((swift_name("tzaisGeonim3Point676Degrees")));

/**
 * This method returns the *tzais* (nightfall) based on the opinion of the *Geonim* calculated at the
 * sun's position at [3.7˚][ZENITH_3_POINT_7] below the western horizon.
 *
 * @return the `Date` representing the time when the sun is 3.7 below sea level.
 * @see ZENITH_3_POINT_7
 */
@property (readonly) STTZmanDateBased *tzaisGeonim3Point7Degrees __attribute__((swift_name("tzaisGeonim3Point7Degrees")));

/**
 * This method returns the *tzais* (nightfall) based on the opinion of the *Geonim* calculated at the
 * sun's position at [3.8˚][ZENITH_3_POINT_8] below the western horizon.
 *
 * @return the `Date` representing the time when the sun is 3.8 below sea level.
 * @see ZENITH_3_POINT_8
 */
@property (readonly) STTZmanDateBased *tzaisGeonim3Point8Degrees __attribute__((swift_name("tzaisGeonim3Point8Degrees")));

/**
 * This method returns the *tzais* (nightfall) based on the opinion of the *Geonim* calculated as 3/4
 * of a [Mil](https://en.wikipedia.org/wiki/Biblical_and_Talmudic_units_of_measurement), based on a 22.5
 * minute Mil, or 16 7/8 minutes. It is the sun's position at [4.37˚][ZENITH_4_POINT_37] below the western
 * horizon. This is a very early *zman* and should not be relied on without Rabbinical guidance.
 *
 * @return the `Date` representing the time when the sun is 4.37 below sea level. If the calculation
 * can't be computed such as northern and southern locations even south of the Arctic Circle and north of
 * the Antarctic Circle where the sun may not reach low enough below the horizon for this calculation, a
 * null will be returned. See detailed explanation on top of the [AstronomicalCalendar] documentation.
 * @see ZENITH_4_POINT_37
 */
@property (readonly) STTZmanDateBased *tzaisGeonim4Point37Degrees __attribute__((swift_name("tzaisGeonim4Point37Degrees")));

/**
 * This method returns the *tzais* (nightfall) based on the opinion of the *Geonim* calculated as 3/4
 * of a *[mil](https://en.wikipedia.org/wiki/Biblical_and_Talmudic_units_of_measurement)* based
 * on a 24-minute Mil, or 18 minutes. It is the sun's position at [4.61˚][ZENITH_4_POINT_61] below the
 * western horizon. This is a very early *zman* and should not be relied on without Rabbinical guidance.
 *
 * @return the `Date` representing the time when the sun is 4.61 below sea level. If the calculation
 * can't be computed such as northern and southern locations even south of the Arctic Circle and north of
 * the Antarctic Circle where the sun may not reach low enough below the horizon for this calculation, a
 * null will be returned. See detailed explanation on top of the [AstronomicalCalendar] documentation.
 * @see ZENITH_4_POINT_61
 */
@property (readonly) STTZmanDateBased *tzaisGeonim4Point61Degrees __attribute__((swift_name("tzaisGeonim4Point61Degrees")));

/**
 * This method returns the *tzais* (nightfall) based on the opinion of the *Geonim* calculated as 3/4
 * of a [Mil](https://en.wikipedia.org/wiki/Biblical_and_Talmudic_units_of_measurement) based on the
 * sun's position at [4.8˚][ZENITH_4_POINT_8] below the western horizon. This is based on Rabbi Leo Levi's
 * calculations. This is the This is a very early *zman* and should not be relied on without Rabbinical guidance.
 * @todo Additional documentation needed.
 *
 * @return the `Date` representing the time when the sun is 4.8 below sea level. If the calculation
 * can't be computed such as northern and southern locations even south of the Arctic Circle and north of
 * the Antarctic Circle where the sun may not reach low enough below the horizon for this calculation, a
 * null will be returned. See detailed explanation on top of the [AstronomicalCalendar] documentation.
 * @see ZENITH_4_POINT_8
 */
@property (readonly) STTZmanDateBased *tzaisGeonim4Point8Degrees __attribute__((swift_name("tzaisGeonim4Point8Degrees")));

/**
 * This method returns the *tzais* (nightfall) based on the opinion of the *Geonim* calculated as 3/4
 * of a 24-minute *[Mil](https://en.wikipedia.org/wiki/Biblical_and_Talmudic_units_of_measurement)*,
 * based on a *Mil* being 24 minutes, and is calculated as 18 + 2 + 4 for a total of 24 minutes. It is the
 * sun's position at [5.88˚][ZENITH_5_POINT_88] below the western horizon. This is a very early
 * *zman* and should not be relied on without Rabbinical guidance.
 *
 * @todo Additional detailed documentation needed.
 * @return the `Date` representing the time when the sun is 5.88 below sea level. If the calculation
 * can't be computed such as northern and southern locations even south of the Arctic Circle and north of
 * the Antarctic Circle where the sun may not reach low enough below the horizon for this calculation, a
 * null will be returned. See detailed explanation on top of the [AstronomicalCalendar] documentation.
 * @see ZENITH_5_POINT_88
 */
@property (readonly) STTZmanDateBased *tzaisGeonim5Point88Degrees __attribute__((swift_name("tzaisGeonim5Point88Degrees")));

/**
 * This method returns the *tzais* (nightfall) based on the opinion of the *Geonim* calculated at the
 * sun's position at [5.95˚][ZENITH_5_POINT_95] below the western horizon.
 *
 * @return the `Date` representing the time when the sun is 5.95 below sea level. If the calculation
 * can't be computed such as northern and southern locations even south of the Arctic Circle and north of
 * the Antarctic Circle where the sun may not reach low enough below the horizon for this calculation, a
 * null will be returned. See detailed explanation on top of the [AstronomicalCalendar] documentation.
 * @see ZENITH_5_POINT_95
 */
@property (readonly) STTZmanDateBased *tzaisGeonim5Point95Degrees __attribute__((swift_name("tzaisGeonim5Point95Degrees")));

/**
 * This method returns the *tzais* (nightfall) based on the opinion of the *Geonim* as calculated by
 * [Rabbi Yechiel Michel Tucazinsky](https://en.wikipedia.org/wiki/Yechiel_Michel_Tucazinsky). It is
 * based on of the position of the sun no later than [31 minutes][tzaisGeonim6Point45Degrees] after sunset
 * in Jerusalem the height of the summer solstice and is 28 minutes after *shkiah* [around the equinox / equilux](https://kosherjava.com/2022/01/12/equinox-vs-equilux-zmanim-calculations/). This
 * computes to 6.45 below the western horizon.
 * @todo Additional documentation details needed.
 *
 * @return the `Date` representing the time when the sun is 6.45 below sea level. If the
 * calculation can't be computed such as northern and southern locations even south of the Arctic Circle and
 * north of the Antarctic Circle where the sun may not reach low enough below the horizon for this
 * calculation, a null will be returned. See detailed explanation on top of the [AstronomicalCalendar]
 * documentation.
 * @see ZENITH_6_POINT_45
 */
@property (readonly) STTZmanDateBased *tzaisGeonim6Point45Degrees __attribute__((swift_name("tzaisGeonim6Point45Degrees")));

/**
 * This method returns the *tzais* (nightfall) based on the opinion of the *Geonim* calculated when the
 * sun's position is [7.083˚ (or 7˚5′)][ZENITH_7_POINT_083]) below the western horizon.
 *
 * This is often referred to as 75' or 7 degrees and 5 minutes.
 *
 * This calculation is based on
 * - the observation of 3 medium sized stars by Dr. Baruch (Berthold) Cohn in his *luach* [Tabellen enthaltend die Zeitangaben für den Beginn der Nacht und des Tages für die Breitengrade + 66 bis -38](https://sammlungen.ub.uni-frankfurt.de/freimann/content/titleinfo/983088)
 * published in Strasbourg, France in 1899.
 *
 * This calendar was very popular in Europe, and many other calendars based their time on it.
 *
 * - [Rav Dovid Tzvi Hoffman](https://en.wikipedia.org/wiki/David_Zvi_Hoffmann) in his [Sh"Ut Melamed Leho'il](https://hebrewbooks.org/1053) in an exchange of letters with Baruch Cohn in [Orach Chaim 30](https://hebrewbooks.org/pdfpager.aspx?req=1053&st=&pgnum=37) agreed to this *zman* (page 36),
 * - as did the Sh"Ut Bnei Tziyon and
 * - the Tenuvas Sadeh.
 * - It is very close to the time of the [Mekor Chesed](https://hebrewbooks.org/22044) of the Sefer chasidim.
 *
 * It is close to the position of the sun 30 minutes after sunset in Jerusalem [around the equinox / equilux](https://kosherjava.com/2022/01/12/equinox-vs-equilux-zmanim-calculations/),
 * but not exactly. The actual position of the sun 30 minutes after sunset in Jerusalem at the equilux is 7.205 and 7.199
 * at the equinox.
 *
 * See Hazmanim Bahalacha vol 2, pages 520-521 for more details.
 *
 * @return the `Date` representing the time when the sun is 7.083 below sea level. If the
 * calculation can't be computed such as northern and southern locations even south of the Arctic Circle and
 * north of the Antarctic Circle where the sun may not reach low enough below the horizon for this
 * calculation, a null will be returned. See detailed explanation on top of the [AstronomicalCalendar]
 * documentation.
 * @see ZENITH_7_POINT_083
 */
@property (readonly) STTZmanDateBased *tzaisGeonim7Point083Degrees __attribute__((swift_name("tzaisGeonim7Point083Degrees")));

/**
 * This method returns *tzais* (nightfall) based on the opinion of the *Geonim* calculated as 45 minutes
 * after sunset during the summer solstice in New York, when the *neshef* (twilight) is the longest.
 *
 * The sun's position at this time computes to [7.75˚][ZENITH_7_POINT_67] below the western horizon.
 *
 * See
 * - [Igros Moshe Even Haezer 4, Ch. 4](https://hebrewbooks.org/pdfpager.aspx?req=921&pgnum=149) (regarding *tzais* for *krias Shema*).
 * - It is also mentioned in Rabbi Heber's [Shaarei Zmanim](https://hebrewbooks.org/53000) on in [chapter 10 (page 87)](https://hebrewbooks.org/pdfpager.aspx?req=53055&pgnum=101) and [chapter 12 (page 108)](https://hebrewbooks.org/pdfpager.aspx?req=53055&pgnum=122).
 * - Also see the time of 45 minutes in [Rabbi Simcha Bunim Cohen's](https://en.wikipedia.org/wiki/Simcha_Bunim_Cohen) [The radiance of Shabbos](https://www.worldcat.org/oclc/179728985) as the earliest *zman* for New York.
 * - This *zman* is also listed in the [Divrei Shalom Vol. III, chapter 75](https://hebrewbooks.org/pdfpager.aspx?req=1927&pgnum=90),
 * - and [Bais Av"i Vol. III, chapter 117](https://hebrewbooks.org/pdfpager.aspx?req=892&pgnum=431).
 * - This *zman* is also listed in the Divrei Shalom etc. chapter 177 (FIXME - could not be located).
 *
 * Since this *zman* depends on the level of light, Rabbi Yaakov Shakow presented this degree-based calculation to
 * Rabbi [Rabbi Shmuel Kamenetsky](https://en.wikipedia.org/wiki/Shmuel_Kamenetsky) who agreed to it.
 *
 * @todo add hyperlinks to source of Divrei Shalom.
 * @return the `Date` representing the time when the sun is 7.67 below sea level. If the
 * calculation can't be computed such as northern and southern locations even south of the Arctic Circle and
 * north of the Antarctic Circle where the sun may not reach low enough below the horizon for this
 * calculation, a null will be returned. See detailed explanation on top of the [AstronomicalCalendar]
 * documentation.
 * @see ZENITH_7_POINT_67
 */
@property (readonly) STTZmanDateBased *tzaisGeonim7Point67Degrees __attribute__((swift_name("tzaisGeonim7Point67Degrees")));

/**
 * This method returns the *tzais* (nightfall) based on the opinion of the *Geonim* calculated at the
 * sun's position at [8.5˚][ZENITH_8_POINT_5] below the western horizon.
 *
 * @return the `Date` representing the time when the sun is 8.5 below sea level. If the calculation
 * can't be computed such as northern and southern locations even south of the Arctic Circle and north of
 * the Antarctic Circle where the sun may not reach low enough below the horizon for this calculation, a
 * null will be returned. See detailed explanation on top of the [AstronomicalCalendar] documentation.
 * @see ZENITH_8_POINT_5
 */
@property (readonly) STTZmanDateBased *tzaisGeonim8Point5Degrees __attribute__((swift_name("tzaisGeonim8Point5Degrees")));

/**
 * This method returns the *tzais* (nightfall) based on the calculations used in the [Luach Itim Lebinah](https://www.worldcat.org/oclc/243303103) as the stringent time for *tzais*.  It is
 * calculated at the sun's position at [9.3˚][ZENITH_9_POINT_3] below the western horizon.
 *
 * @return the `Date` representing the time when the sun is 9.3 below sea level. If the calculation
 * can't be computed such as northern and southern locations even south of the Arctic Circle and north of
 * the Antarctic Circle where the sun may not reach low enough below the horizon for this calculation, a
 * null will be returned. See detailed explanation on top of the [AstronomicalCalendar] documentation.
 */
@property (readonly) STTZmanDateBased *tzaisGeonim9Point3Degrees __attribute__((swift_name("tzaisGeonim9Point3Degrees")));

/**
 * This method returns the *tzais* (nightfall) based on the opinion of the *Geonim* calculated as 60
 * minutes after sunset [around the equinox / equilux](https://kosherjava.com/2022/01/12/equinox-vs-equilux-zmanim-calculations/), the
 * day that a solar hour is 60 minutes in New York. The sun's position at this time computes to
 * [9.75˚][ZENITH_9_POINT_75] below the western horizon. This is the opinion of [Rabbi Eliyahu Henkin](https://en.wikipedia.org/wiki/Yosef_Eliyahu_Henkin).  This also follows the opinion of
 * [Rabbi Shmuel Kamenetsky](https://en.wikipedia.org/wiki/Shmuel_Kamenetsky). Rabbi Yaakov Shakow presented
 * these degree-based times to Rabbi Shmuel Kamenetsky who agreed to them.
 *
 * @todo recalculate based on equinox / equilux.
 * @return the `Date` representing the time when the sun is 9.75 below sea level. If the calculation
 * can't be computed such as northern and southern locations even south of the Arctic Circle and north of
 * the Antarctic Circle where the sun may not reach low enough below the horizon for this calculation, a
 * null will be returned. See detailed explanation on top of the [AstronomicalCalendar] documentation.
 *
 * @see tzais60
 */
@property (readonly) STTZmanDateBased *tzaisGeonim9Point75Degrees __attribute__((swift_name("tzaisGeonim9Point75Degrees")));

/**
 * Returns the point in time of *Molad*. For the traditional day of week, hour,
 * minute and chalakim, [JewishCalendar.moladAsInstant] and the not yet completed
 * [com.kosherjava.zmanim.hebrewcalendar.HebrewDateFormatter] that will have formatting for this.
 *
 * @return the Date representing the moment of the molad. If the molad does not occur on this day, a null will be returned.
 *
 * @see .getTchilasZmanKidushLevana3Days
 * @see .getTchilasZmanKidushLevana7Days
 * @see JewishCalendar.moladAsInstant
 */
@property (readonly) STTZmanDateBased *zmanMolad __attribute__((swift_name("zmanMolad")));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("ComplexZmanimCalendar.Companion")))
@interface STTComplexZmanimCalendarCompanion : STTBase
+ (instancetype)alloc __attribute__((unavailable));
+ (instancetype)allocWithZone:(struct _NSZone *)zone __attribute__((unavailable));
+ (instancetype)companion __attribute__((swift_name("init()")));
@property (class, readonly, getter=shared) STTComplexZmanimCalendarCompanion *shared __attribute__((swift_name("shared")));
- (id _Nullable)maxOfA:(id _Nullable)a b:(id _Nullable)b __attribute__((swift_name("maxOf(a:b:)")));
@property (readonly) double ATERET_TORAH_DEFAULT_OFFSET __attribute__((swift_name("ATERET_TORAH_DEFAULT_OFFSET")));
@property (readonly) STTKotlinx_datetimeLocalTime *MIDNIGHT __attribute__((swift_name("MIDNIGHT")));

/**
 * The zenith of 10.2 below [geometric zenith][AstronomicalCalendar.GEOMETRIC_ZENITH] (90). This calculation is used for
 * calculating *misheyakir* according to some opinions. This calculation is based on the position of the sun
 * 45 minutes before [sunrise] in Jerusalem [around the equinox / equilux](https://kosherjava.com/2022/01/12/equinox-vs-equilux-zmanim-calculations/) which
 * calculates to 10.2 below [geometric zenith][AstronomicalCalendar.GEOMETRIC_ZENITH].
 *
 * @see .getMisheyakir10Point2Degrees
 */
@property (readonly) double ZENITH_10_POINT_2 __attribute__((swift_name("ZENITH_10_POINT_2")));

/**
 * The zenith of 11 below [geometric zenith][AstronomicalCalendar.GEOMETRIC_ZENITH] (90). This calculation is used for
 * calculating *misheyakir* according to some opinions. This calculation is based on the position of the sun
 * 48 minutes before [sunrise] in Jerusalem [around the equinox / equilux](https://kosherjava.com/2022/01/12/equinox-vs-equilux-zmanim-calculations/), which
 * calculates to 11 below [geometric zenith][AstronomicalCalendar.GEOMETRIC_ZENITH].
 *
 * @see .getMisheyakir11Degrees
 */
@property (readonly) double ZENITH_11_DEGREES __attribute__((swift_name("ZENITH_11_DEGREES")));

/**
 * The zenith of 11.5 below [geometric zenith][AstronomicalCalendar.GEOMETRIC_ZENITH] (90). This calculation is used for
 * calculating *misheyakir* according to some opinions. This calculation is based on the position of the sun
 * 52 minutes before [sunrise] in Jerusalem [around the equinox / equilux](https://kosherjava.com/2022/01/12/equinox-vs-equilux-zmanim-calculations/), which
 * calculates to 11.5 below [geometric zenith][AstronomicalCalendar.GEOMETRIC_ZENITH].
 *
 * @see .getMisheyakir11Point5Degrees
 */
@property (readonly) double ZENITH_11_POINT_5 __attribute__((swift_name("ZENITH_11_POINT_5")));

/**
 * The zenith of 13.24 below [geometric zenith][AstronomicalCalendar.GEOMETRIC_ZENITH] (90). This calculation is used for
 * calculating Rabbeinu Tam's *bain hashmashos* according to some opinions.
 * NOTE: See comments on [bainHashmashosRT13Point24Degrees] for additional details about the degrees.
 *
 * @see bainHashmashosRT13Point24Degrees
 */
@property (readonly) double ZENITH_13_POINT_24 __attribute__((swift_name("ZENITH_13_POINT_24")));

/**
 * The zenith of 16.9 below geometric zenith (90). This calculation is used for determining *alos*
 * (dawn) based on the opinion of the Baal Hatanya. It is based on the calculation that the time between dawn
 * and *netz amiti* (sunrise) is 72 minutes, the time that is takes to walk 4 *mil* at 18 minutes
 * a *mil* ([Rambam](https://en.wikipedia.org/wiki/Maimonides) and others). The sun's position at 72
 * minutes before [*netz amiti* (sunrise)][sunriseBaalHatanya] in Jerusalem [around the equinox / equilux](https://kosherjava.com/2022/01/12/equinox-vs-equilux-zmanim-calculations/) is
 * 16.9 below [geometric zenith][AstronomicalCalendar.GEOMETRIC_ZENITH].
 *
 * @see alosBaalHatanya
 */
@property (readonly) double ZENITH_16_POINT_9 __attribute__((swift_name("ZENITH_16_POINT_9")));

/**
 * The zenith of 19 below [geometric zenith][AstronomicalCalendar.GEOMETRIC_ZENITH] (90). This calculation is used for
 * calculating *alos* according to some opinions.
 *
 * @see alos19Degrees
 * @see ZENITH_19_POINT_8
 */
@property (readonly) double ZENITH_19_DEGREES __attribute__((swift_name("ZENITH_19_DEGREES")));

/**
 * The zenith of 19.8 below [geometric zenith][AstronomicalCalendar.GEOMETRIC_ZENITH] (90). This calculation is used for
 * calculating *alos* (dawn) and *tzais* (nightfall) according to some opinions. This calculation is
 * based on the position of the sun 90 minutes after sunset in Jerusalem [around the equinox / equilux](https://kosherjava.com/2022/01/12/equinox-vs-equilux-zmanim-calculations/) which
 * calculates to 19.8 below [geometric zenith][AstronomicalCalendar.GEOMETRIC_ZENITH].
 *
 * @see tzais19Point8Degrees
 * @see alos19Point8Degrees
 * @see alos90
 * @see tzais90
 * @see ZENITH_19_DEGREES
 */
@property (readonly) double ZENITH_19_POINT_8 __attribute__((swift_name("ZENITH_19_POINT_8")));

/**
 * The zenith of 1.583 below [geometric zenith][AstronomicalCalendar.GEOMETRIC_ZENITH] (90). This calculation is used for
 * calculating *netz amiti* (sunrise) and *shkiah amiti* (sunset) based on the opinion of the
 * [Baal Hatanya](https://en.wikipedia.org/wiki/Shneur_Zalman_of_Liadi).
 *
 * @see sunriseBaalHatanya
 * @see sunsetBaalHatanya
 */
@property (readonly) double ZENITH_1_POINT_583 __attribute__((swift_name("ZENITH_1_POINT_583")));

/**
 * The zenith of 26 below [geometric zenith][AstronomicalCalendar.GEOMETRIC_ZENITH] (90). This calculation is used for
 * calculating *alos* (dawn) and *tzais* (nightfall) according to some opinions. This calculation is
 * based on the position of the sun [120 minutes][alos120] after sunset in Jerusalem o[around the equinox / equilux](https://kosherjava.com/2022/01/12/equinox-vs-equilux-zmanim-calculations/) which
 * calculates to 26 below [geometric zenith][AstronomicalCalendar.GEOMETRIC_ZENITH]. Since the level of darkness when the sun is
 * 26 and at a point when the level of darkness is long past the 18 point where the darkest point is reached,
 * it should only be used *lechumra* such as delaying the start of nighttime *mitzvos* or avoiding eating
 * this early on a fast day.
 *
 * @see alos26Degrees
 * @see tzais26Degrees
 * @see alos120
 * @see tzais120
 */
@property (readonly) double ZENITH_26_DEGREES __attribute__((swift_name("ZENITH_26_DEGREES")));

/**
 * The zenith of 3.65 below [geometric zenith][AstronomicalCalendar.GEOMETRIC_ZENITH] (90). This calculation is used for
 * calculating *tzais* (nightfall) according to some opinions. This calculation is based on the position of
 * the sun [13.5 minutes][tzaisGeonim3Point65Degrees] after sunset (3/4 of an 18-minute *Mil*)
 * in Jerusalem [around the equinox / equilux](https://kosherjava.com/2022/01/12/equinox-vs-equilux-zmanim-calculations/) which
 * calculates to 3.65 below [geometric zenith][AstronomicalCalendar.GEOMETRIC_ZENITH].
 *
 * @see tzaisGeonim3Point65Degrees
 */
@property (readonly) double ZENITH_3_POINT_65 __attribute__((swift_name("ZENITH_3_POINT_65")));

/**
 * The zenith of 3.676 below [geometric zenith][AstronomicalCalendar.GEOMETRIC_ZENITH] (90).
 * @todo Add more documentation.
 */
@property (readonly) double ZENITH_3_POINT_676 __attribute__((swift_name("ZENITH_3_POINT_676")));

/**
 * The zenith of 3.7 below [geometric zenith][AstronomicalCalendar.GEOMETRIC_ZENITH] (90). This calculation is used for
 * calculating *tzais* (nightfall) based on the opinion of the *Geonim* that *tzais* is the
 * time it takes to walk 3/4 of a *Mil* at 18 minutes a *Mil*, or 13.5 minutes after sunset. The sun
 * is 3.7 below [geometric zenith][AstronomicalCalendar.GEOMETRIC_ZENITH] at this time in Jerusalem [around the equinox / equilux](https://kosherjava.com/2022/01/12/equinox-vs-equilux-zmanim-calculations/).
 *
 * @see tzaisGeonim3Point7Degrees
 */
@property (readonly) double ZENITH_3_POINT_7 __attribute__((swift_name("ZENITH_3_POINT_7")));

/**
 * The zenith of 3.8 below [geometric zenith][AstronomicalCalendar.GEOMETRIC_ZENITH] (90). This calculation is used for
 * calculating *tzais* (nightfall) based on the opinion of the *Geonim* that *tzais* is the
 * time it takes to walk 3/4 of a *Mil* at 18 minutes a *Mil*, or 13.5 minutes after sunset. The sun
 * is 3.8 below [geometric zenith][AstronomicalCalendar.GEOMETRIC_ZENITH] at this time in Jerusalem [around the equinox / equilux](https://kosherjava.com/2022/01/12/equinox-vs-equilux-zmanim-calculations/).
 *
 * @see tzaisGeonim3Point8Degrees
 */
@property (readonly) double ZENITH_3_POINT_8 __attribute__((swift_name("ZENITH_3_POINT_8")));

/**
 * The zenith of 4.37 below [geometric zenith][AstronomicalCalendar.GEOMETRIC_ZENITH] (90). This calculation is used for
 * calculating *tzais* (nightfall) according to some opinions. This calculation is based on the position of
 * the sun [16 7/8 minutes][tzaisGeonim4Point37Degrees] after sunset (3/4 of a 22.5-minute *Mil*)
 * in Jerusalem [around the equinox / equilux](https://kosherjava.com/2022/01/12/equinox-vs-equilux-zmanim-calculations/),
 * which calculates to 4.37 below [geometric zenith][AstronomicalCalendar.GEOMETRIC_ZENITH].
 *
 * @see tzaisGeonim4Point37Degrees
 */
@property (readonly) double ZENITH_4_POINT_37 __attribute__((swift_name("ZENITH_4_POINT_37")));

/**
 * The zenith of 4.61 below [geometric zenith][AstronomicalCalendar.GEOMETRIC_ZENITH] (90). This calculation is used for
 * calculating *tzais* (nightfall) according to some opinions. This calculation is based on the position of
 * the sun [18 minutes][tzaisGeonim4Point37Degrees] after sunset (3/4 of a 24-minute *Mil*) in
 * Jerusalem [around the equinox
 * / equilux](https://kosherjava.com/2022/01/12/equinox-vs-equilux-zmanim-calculations/), which calculates to 4.61 below [geometric zenith][AstronomicalCalendar.GEOMETRIC_ZENITH].
 * @todo add documentation links
 *
 * @see tzaisGeonim4Point61Degrees
 */
@property (readonly) double ZENITH_4_POINT_61 __attribute__((swift_name("ZENITH_4_POINT_61")));

/**
 * The zenith of 4.8 below [geometric zenith][AstronomicalCalendar.GEOMETRIC_ZENITH] (90).
 * @todo Add more documentation.
 * @see tzaisGeonim4Point8Degrees
 */
@property (readonly) double ZENITH_4_POINT_8 __attribute__((swift_name("ZENITH_4_POINT_8")));

/**
 * The zenith of 5.88 below [geometric zenith][AstronomicalCalendar.GEOMETRIC_ZENITH] (90).
 * @todo Add more documentation.
 */
@property (readonly) double ZENITH_5_POINT_88 __attribute__((swift_name("ZENITH_5_POINT_88")));

/**
 * The zenith of 5.95 below [geometric zenith][AstronomicalCalendar.GEOMETRIC_ZENITH] (90). This calculation is used for
 * calculating *tzais* (nightfall) according to some opinions. This calculation is based on the position of
 * the sun 24 minutes after sunset in Jerusalem [around the equinox / equilux](https://kosherjava.com/2022/01/12/equinox-vs-equilux-zmanim-calculations/),
 * which calculates to 5.95 below [geometric zenith][AstronomicalCalendar.GEOMETRIC_ZENITH].
 *
 * @see tzaisGeonim5Point95Degrees
 */
@property (readonly) double ZENITH_5_POINT_95 __attribute__((swift_name("ZENITH_5_POINT_95")));

/**
 * The zenith of 6 below [geometric zenith][AstronomicalCalendar.GEOMETRIC_ZENITH] (90). This calculation is used for
 * calculating *tzais* / nightfall based on the opinion of the Baal Hatanya. This calculation is based on the
 * position of the sun 24 minutes after [sunset][sunset] in Jerusalem [around the equinox / equilux](https://kosherjava.com/2022/01/12/equinox-vs-equilux-zmanim-calculations/), which
 * is 6 below [geometric zenith][AstronomicalCalendar.GEOMETRIC_ZENITH].
 *
 * @see tzaisBaalHatanya
 */
@property (readonly) double ZENITH_6_DEGREES __attribute__((swift_name("ZENITH_6_DEGREES")));

/**
 * The zenith of 6.45 below [geometric zenith][AstronomicalCalendar.GEOMETRIC_ZENITH] (90). This calculation is used for
 * calculating *tzais* (nightfall) according to some opinions. This is based on the calculations of [Rabbi Yechiel Michel Tucazinsky](https://en.wikipedia.org/wiki/Yechiel_Michel_Tucazinsky) of the position of
 * the sun no later than [31 minutes][tzaisGeonim6Point45Degrees] after sunset in Jerusalem, and at the
 * height of the summer solstice, this *zman* is 28 minutes after *shkiah*. This computes to 6.45
 * below [geometric zenith][AstronomicalCalendar.GEOMETRIC_ZENITH]. This calculation is found in the [Birur Halacha Yoreh Deah 262](https://hebrewbooks.org/pdfpager.aspx?req=50536&st=&pgnum=51) it the commonly
 * used *zman* in Israel. It should be noted that this differs from the 6.1/6.2 calculation for
 * Rabbi Tucazinsky's time as calculated by the Hazmanim Bahalacha Vol II chapter 50:7 (page 515).
 *
 * @see tzaisGeonim6Point45Degrees
 */
@property (readonly) double ZENITH_6_POINT_45 __attribute__((swift_name("ZENITH_6_POINT_45")));

/**
 * The zenith of 7.083 below [geometric zenith][AstronomicalCalendar.GEOMETRIC_ZENITH] (90). This is often referred to as
 * 75' or 7 and 5 minutes. This calculation is used for calculating *alos* (dawn) and
 * *tzais* (nightfall) according to some opinions. This calculation is based on observation of 3 medium sized
 * stars by Dr. Baruch Cohen in his calendar published in in 1899 in Strasbourg, France. This calculates to
 * 7.0833333 below [geometric zenith][AstronomicalCalendar.GEOMETRIC_ZENITH]. The [Sh"Ut
 * Melamed Leho'il](https://hebrewbooks.org/1053) in Orach Chaim 30 agreed to this *zman*, as did the Sh"Ut Bnei Tziyon, Tenuvas Sadeh and
 * it is very close to the time of the [Mekor Chesed](https://hebrewbooks.org/22044) of the Sefer chasidim.
 * It is close to the position of the sun 30 minutes after sunset in Jerusalem [around the equinox / equilux](https://kosherjava.com/2022/01/12/equinox-vs-equilux-zmanim-calculations/), but not
 * Exactly. The actual position of the sun 30 minutes after sunset in Jerusalem at the equilux is 7.205 and
 * 7.199 at the equinox. See Hazmanim Bahalacha vol 2, pages 520-521 for details.
 * @todo Hyperlink the proper sources.
 *
 * @see tzaisGeonim7Point083Degrees
 * @see bainHashmashosRT13Point5MinutesBefore7Point083Degrees
 */
@property (readonly) double ZENITH_7_POINT_083 __attribute__((swift_name("ZENITH_7_POINT_083")));

/**
 * The zenith of 7.65 below [geometric zenith][AstronomicalCalendar.GEOMETRIC_ZENITH] (90). This calculation is used for
 * calculating *misheyakir* according to some opinions.
 *
 * @see .getMisheyakir7Point65Degrees
 */
@property (readonly) double ZENITH_7_POINT_65 __attribute__((swift_name("ZENITH_7_POINT_65")));

/**
 * The zenith of 7.67 below [geometric zenith][AstronomicalCalendar.GEOMETRIC_ZENITH] (90). This calculation is used for
 * calculating *tzais* according to some opinions.
 *
 * @see tzaisGeonim7Point67Degrees
 */
@property (readonly) double ZENITH_7_POINT_67 __attribute__((swift_name("ZENITH_7_POINT_67")));

/**
 * The zenith of 9.3 below [geometric zenith][AstronomicalCalendar.GEOMETRIC_ZENITH] (90). This calculation is used for
 * calculating *tzais* (nightfall) according to some opinions.
 *
 * @see tzaisGeonim9Point3Degrees
 */
@property (readonly) double ZENITH_9_POINT_3 __attribute__((swift_name("ZENITH_9_POINT_3")));

/**
 * The zenith of 9.5 below [geometric zenith][AstronomicalCalendar.GEOMETRIC_ZENITH] (90). This calculation is used for
 * calculating *misheyakir* according to some opinions.
 *
 * @see .getMisheyakir9Point5Degrees
 */
@property (readonly) double ZENITH_9_POINT_5 __attribute__((swift_name("ZENITH_9_POINT_5")));

/**
 * The zenith of 9.75 below [geometric zenith][AstronomicalCalendar.GEOMETRIC_ZENITH] (90). This calculation is used for
 * calculating *alos* (dawn) and *tzais* (nightfall) according to some opinions.
 *
 * @see tzaisGeonim9Point75Degrees
 */
@property (readonly) double ZENITH_9_POINT_75 __attribute__((swift_name("ZENITH_9_POINT_75")));

/**
 * The zenith of 2.1 above [geometric zenith][AstronomicalCalendar.GEOMETRIC_ZENITH] (90). This calculation is used for
 * calculating the start of *bain hashmashos* (twilight) of 13.5 minutes before sunset converted to degrees
 * according to the Yereim. As is traditional with degrees below the horizon, this is calculated without refraction
 * and from the center of the sun. It would be 0.833 less without this.
 *
 * @see bainHashmashosYereim2Point1Degrees
 */
@property (readonly) double ZENITH_MINUS_2_POINT_1 __attribute__((swift_name("ZENITH_MINUS_2_POINT_1")));

/**
 * The zenith of 2.8 above [geometric zenith][AstronomicalCalendar.GEOMETRIC_ZENITH] (90). This calculation is used for
 * calculating the start of *bain hashmashos* (twilight) of 16.875 minutes before sunset converted to degrees
 * according to the Yereim. As is traditional with degrees below the horizon, this is calculated without refraction
 * and from the center of the sun. It would be 0.833 less without this.
 *
 * @see bainHashmashosYereim2Point8Degrees
 */
@property (readonly) double ZENITH_MINUS_2_POINT_8 __attribute__((swift_name("ZENITH_MINUS_2_POINT_8")));

/**
 * The zenith of 3.05 above [geometric zenith][AstronomicalCalendar.GEOMETRIC_ZENITH] (90). This calculation is used for
 * calculating the start of *bain hashmashos* (twilight) of 18 minutes before sunset converted to degrees
 * according to the Yereim. As is traditional with degrees below the horizon, this is calculated without refraction
 * and from the center of the sun. It would be 0.833 less without this.
 *
 * @see bainHashmashosYereim3Point05Degrees
 */
@property (readonly) double ZENITH_MINUS_3_POINT_05 __attribute__((swift_name("ZENITH_MINUS_3_POINT_05")));
@end

__attribute__((swift_name("KotlinComparable")))
@protocol STTKotlinComparable
@required
- (int32_t)compareToOther:(id _Nullable)other __attribute__((swift_name("compareTo(other:)")));
@end


/**
 * This class represents a halachic moment in time or duration of time.
 * Some zmanim, like [sha'os zmaniyos][ZmanType.SHAA_ZMANIS], don't have a moment when they occur. Rather, they carry a value.
 * Others, like [sunset][ZmanType.SHKIAH] happen at a specific moment in time.
 * @param T the type of value that this zman represents ([Instant], [Duration], etc.). This is the type of the [value] property.
 * */
__attribute__((swift_name("Zman")))
@interface STTZman<T> : STTBase <STTKotlinComparable>
- (NSString *)formattedTz:(STTKotlinx_datetimeTimeZone *)tz __attribute__((swift_name("formatted(tz:)")));
- (NSString *)formattedTz:(STTKotlinx_datetimeTimeZone *)tz inEnglish:(BOOL)inEnglish __attribute__((swift_name("formatted(tz:inEnglish:)")));
- (NSString *)formattedTz:(STTKotlinx_datetimeTimeZone *)tz opinion:(NSString *)opinion __attribute__((swift_name("formatted(tz:opinion:)")));

/**
 * @note This property has protected visibility in Kotlin source and is intended only for use by subclasses.
*/
@property (readonly) T _Nullable (^computeValue)(void) __attribute__((swift_name("computeValue")));
@property (readonly) STTZmanDefinition *definition __attribute__((swift_name("definition")));
@property (readonly) T _Nullable value __attribute__((swift_name("value")));
@end


/**
 * This class represents a zman that has a moment in which it occurs.
 * @param momentOfOccurrence null if zman never occurs or does not apply (e.g. time to say kiddush levana after time
 * has passed). Some zmanim can occasionally not occur (e.g. sunrise in the Arctic Circle) - see [AstronomicalCalendar] for more details.
 * */
__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("ZmanDateBased")))
@interface STTZmanDateBased : STTZman<STTKotlinx_datetimeInstant *>
- (instancetype)initWithDefinition:(STTZmanDefinition *)definition computeInstant:(STTKotlinx_datetimeInstant * _Nullable (^)(void))computeInstant __attribute__((swift_name("init(definition:computeInstant:)"))) __attribute__((objc_designated_initializer));
- (int32_t)compareToOther:(STTZman<STTKotlinx_datetimeInstant *> *)other __attribute__((swift_name("compareTo(other:)")));

/**
 * This class represents a zman that has a moment in which it occurs.
 * @param momentOfOccurrence null if zman never occurs or does not apply (e.g. time to say kiddush levana after time
 * has passed). Some zmanim can occasionally not occur (e.g. sunrise in the Arctic Circle) - see [AstronomicalCalendar] for more details.
 * */
- (STTZmanDateBased *)doCopyDefinition:(STTZmanDefinition *)definition computeInstant:(STTKotlinx_datetimeInstant * _Nullable (^)(void))computeInstant __attribute__((swift_name("doCopy(definition:computeInstant:)")));

/**
 * This class represents a zman that has a moment in which it occurs.
 * @param momentOfOccurrence null if zman never occurs or does not apply (e.g. time to say kiddush levana after time
 * has passed). Some zmanim can occasionally not occur (e.g. sunrise in the Arctic Circle) - see [AstronomicalCalendar] for more details.
 * */
- (BOOL)isEqual:(id _Nullable)other __attribute__((swift_name("isEqual(_:)")));

/**
 * This class represents a zman that has a moment in which it occurs.
 * @param momentOfOccurrence null if zman never occurs or does not apply (e.g. time to say kiddush levana after time
 * has passed). Some zmanim can occasionally not occur (e.g. sunrise in the Arctic Circle) - see [AstronomicalCalendar] for more details.
 * */
- (NSUInteger)hash __attribute__((swift_name("hash()")));

/**
 * This class represents a zman that has a moment in which it occurs.
 * @param momentOfOccurrence null if zman never occurs or does not apply (e.g. time to say kiddush levana after time
 * has passed). Some zmanim can occasionally not occur (e.g. sunrise in the Arctic Circle) - see [AstronomicalCalendar] for more details.
 * */
- (NSString *)description __attribute__((swift_name("description()")));
@property (readonly) STTZmanDefinition *definition __attribute__((swift_name("definition")));
@property (readonly) STTKotlinx_datetimeInstant * _Nullable momentOfOccurrence __attribute__((swift_name("momentOfOccurrence")));
@end


/**
 * This class represents a zman which simply carries a datetime-less value.
 *
 * The duration of the *zman* is a [temporal hour][com.kosherjava.zmanim.AstronomicalCalendar.temporalHour] (or the various
 * *shaah zmanis* base times such as [*shaah Zmanis GRA*][com.kosherjava.zmanim.ZmanimCalendar.shaahZmanisGra] or
 * [*shaah Zmanis 16.1˚*][com.kosherjava.zmanim.ComplexZmanimCalendar.shaahZmanis16Point1Degrees]).
 * */
__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("ZmanValueBased")))
@interface STTZmanValueBased : STTZman<id>
- (instancetype)initWithDefinition:(STTZmanDefinition *)definition computeDuration:(id (^)(void))computeDuration __attribute__((swift_name("init(definition:computeDuration:)"))) __attribute__((objc_designated_initializer));
- (int32_t)compareToOther:(STTZman<id> *)other __attribute__((swift_name("compareTo(other:)")));

/**
 * This class represents a zman which simply carries a datetime-less value.
 *
 * The duration of the *zman* is a [temporal hour][com.kosherjava.zmanim.AstronomicalCalendar.temporalHour] (or the various
 * *shaah zmanis* base times such as [*shaah Zmanis GRA*][com.kosherjava.zmanim.ZmanimCalendar.shaahZmanisGra] or
 * [*shaah Zmanis 16.1˚*][com.kosherjava.zmanim.ComplexZmanimCalendar.shaahZmanis16Point1Degrees]).
 * */
- (STTZmanValueBased *)doCopyDefinition:(STTZmanDefinition *)definition computeDuration:(id (^)(void))computeDuration __attribute__((swift_name("doCopy(definition:computeDuration:)")));

/**
 * This class represents a zman which simply carries a datetime-less value.
 *
 * The duration of the *zman* is a [temporal hour][com.kosherjava.zmanim.AstronomicalCalendar.temporalHour] (or the various
 * *shaah zmanis* base times such as [*shaah Zmanis GRA*][com.kosherjava.zmanim.ZmanimCalendar.shaahZmanisGra] or
 * [*shaah Zmanis 16.1˚*][com.kosherjava.zmanim.ComplexZmanimCalendar.shaahZmanis16Point1Degrees]).
 * */
- (BOOL)isEqual:(id _Nullable)other __attribute__((swift_name("isEqual(_:)")));

/**
 * This class represents a zman which simply carries a datetime-less value.
 *
 * The duration of the *zman* is a [temporal hour][com.kosherjava.zmanim.AstronomicalCalendar.temporalHour] (or the various
 * *shaah zmanis* base times such as [*shaah Zmanis GRA*][com.kosherjava.zmanim.ZmanimCalendar.shaahZmanisGra] or
 * [*shaah Zmanis 16.1˚*][com.kosherjava.zmanim.ComplexZmanimCalendar.shaahZmanis16Point1Degrees]).
 * */
- (NSUInteger)hash __attribute__((swift_name("hash()")));

/**
 * This class represents a zman which simply carries a datetime-less value.
 *
 * The duration of the *zman* is a [temporal hour][com.kosherjava.zmanim.AstronomicalCalendar.temporalHour] (or the various
 * *shaah zmanis* base times such as [*shaah Zmanis GRA*][com.kosherjava.zmanim.ZmanimCalendar.shaahZmanisGra] or
 * [*shaah Zmanis 16.1˚*][com.kosherjava.zmanim.ComplexZmanimCalendar.shaahZmanis16Point1Degrees]).
 * */
- (NSString *)description __attribute__((swift_name("description()")));
@property (readonly) STTZmanDefinition *definition __attribute__((swift_name("definition")));
@property (readonly) int64_t duration __attribute__((swift_name("duration")));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("ZmanDescriptionFormatter")))
@interface STTZmanDescriptionFormatter : STTBase
- (instancetype)init __attribute__((swift_name("init()"))) __attribute__((objc_designated_initializer));
+ (instancetype)new __attribute__((availability(swift, unavailable, message="use object initializers instead")));
@property (class, readonly, getter=companion) STTZmanDescriptionFormatterCompanion *companion __attribute__((swift_name("companion")));
- (NSString *)formatLongDescriptionZman:(STTZman<id> *)zman __attribute__((swift_name("formatLongDescription(zman:)")));
- (NSString *)formatLongDescriptionZman_:(STTZmanDefinition *)zman __attribute__((swift_name("formatLongDescription(zman_:)")));
- (NSString *)formatShortDescriptionZman:(STTZmanDefinition *)zman __attribute__((swift_name("formatShortDescription(zman:)")));
- (NSString *)formatShortDescriptionZman:(STTZman<id> *)zman includeElevationDescription:(BOOL)includeElevationDescription __attribute__((swift_name("formatShortDescription(zman:includeElevationDescription:)")));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("ZmanDescriptionFormatter.Companion")))
@interface STTZmanDescriptionFormatterCompanion : STTBase
+ (instancetype)alloc __attribute__((unavailable));
+ (instancetype)allocWithZone:(struct _NSZone *)zone __attribute__((unavailable));
+ (instancetype)companion __attribute__((swift_name("init()")));
@property (class, readonly, getter=shared) STTZmanDescriptionFormatterCompanion *shared __attribute__((swift_name("shared")));
- (NSString *)shortDescriptionAteretTorahMinuteOffset:(double)minuteOffset __attribute__((swift_name("shortDescriptionAteretTorah(minuteOffset:)")));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("ZmanimCalendar.Companion")))
@interface STTZmanimCalendarCompanion : STTBase
+ (instancetype)alloc __attribute__((unavailable));
+ (instancetype)allocWithZone:(struct _NSZone *)zone __attribute__((unavailable));
+ (instancetype)companion __attribute__((swift_name("init()")));
@property (class, readonly, getter=shared) STTZmanimCalendarCompanion *shared __attribute__((swift_name("shared")));

/**
 * The zenith of 16.1 below geometric zenith (90). This calculation is used for determining *alos*
 * (dawn) and *tzais* (nightfall) in some opinions. It is based on the calculation that the time between dawn
 * and sunrise (and sunset to nightfall) is 72 minutes, the time that is takes to walk 4 *mil* at 18 minutes
 * a mil (*[Rambam](https://en.wikipedia.org/wiki/Maimonides)* and others). The sun's position at
 * 72 minutes before [sunrise] in Jerusalem [around the equinox / equilux](https://kosherjava.com/2022/01/12/equinox-vs-equilux-zmanim-calculations/) is
 * 16.1 below [geometric zenith][AstronomicalCalendar.GEOMETRIC_ZENITH].
 *
 * @see alosHashachar
 * @see ComplexZmanimCalendar.getAlos16Point1Degrees
 * @see ComplexZmanimCalendar.getTzais16Point1Degrees
 * @see ComplexZmanimCalendar.getSofZmanShmaMGA16Point1Degrees
 * @see ComplexZmanimCalendar.getSofZmanTfilaMGA16Point1Degrees
 * @see ComplexZmanimCalendar.getMinchaGedola16Point1Degrees
 * @see ComplexZmanimCalendar.getMinchaKetana16Point1Degrees
 * @see ComplexZmanimCalendar.getPlagHamincha16Point1Degrees
 * @see ComplexZmanimCalendar.getPlagAlos16Point1ToTzaisGeonim7Point083Degrees
 * @see ComplexZmanimCalendar.getSofZmanShmaAlos16Point1ToSunset
 */
@property (readonly) double ZENITH_16_POINT_1 __attribute__((swift_name("ZENITH_16_POINT_1")));

/**
 * The zenith of 8.5 below geometric zenith (90). This calculation is used for calculating *alos*
 * (dawn) and *tzais* (nightfall) in some opinions. This calculation is based on the position of the sun 36
 * minutes after [sunset][sunset] in Jerusalem [around the equinox / equilux](https://kosherjava.com/2022/01/12/equinox-vs-equilux-zmanim-calculations/), which
 * is 8.5 below [geometric zenith][AstronomicalCalendar.GEOMETRIC_ZENITH]. The *[Ohr Meir](https://www.worldcat.org/oclc/29283612)* considers this the time that 3 small stars are visible,
 * which is later than the required 3 medium stars.
 *
 * @see tzais
 * @see ComplexZmanimCalendar.getTzaisGeonim8Point5Degrees
 */
@property (readonly) double ZENITH_8_POINT_5 __attribute__((swift_name("ZENITH_8_POINT_5")));
@end


/**
 * An Object representing a *daf* (page) in the [Daf Yomi](https://en.wikipedia.org/wiki/Daf_Yomi) cycle.
 *
 * @param masechtaNumber the *masechta* number in the order of the Daf Yomi to set as the current *masechta*.
 * @param daf the *daf* (page) number to set.
 *
 * @author  Eliyahu Hershfeld 2011 - 2023
 */
__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("Daf")))
@interface STTDaf : STTBase
- (instancetype)initWithMasechtaNumber:(int32_t)masechtaNumber daf:(int32_t)daf __attribute__((swift_name("init(masechtaNumber:daf:)"))) __attribute__((objc_designated_initializer));
@property (class, readonly, getter=companion) STTDafCompanion *companion __attribute__((swift_name("companion")));

/**
 * An Object representing a *daf* (page) in the [Daf Yomi](https://en.wikipedia.org/wiki/Daf_Yomi) cycle.
 *
 * @param masechtaNumber the *masechta* number in the order of the Daf Yomi to set as the current *masechta*.
 * @param daf the *daf* (page) number to set.
 *
 * @author  Eliyahu Hershfeld 2011 - 2023
 */
- (STTDaf *)doCopyMasechtaNumber:(int32_t)masechtaNumber daf:(int32_t)daf __attribute__((swift_name("doCopy(masechtaNumber:daf:)")));

/**
 * An Object representing a *daf* (page) in the [Daf Yomi](https://en.wikipedia.org/wiki/Daf_Yomi) cycle.
 *
 * @param masechtaNumber the *masechta* number in the order of the Daf Yomi to set as the current *masechta*.
 * @param daf the *daf* (page) number to set.
 *
 * @author  Eliyahu Hershfeld 2011 - 2023
 */
- (BOOL)isEqual:(id _Nullable)other __attribute__((swift_name("isEqual(_:)")));

/**
 * An Object representing a *daf* (page) in the [Daf Yomi](https://en.wikipedia.org/wiki/Daf_Yomi) cycle.
 *
 * @param masechtaNumber the *masechta* number in the order of the Daf Yomi to set as the current *masechta*.
 * @param daf the *daf* (page) number to set.
 *
 * @author  Eliyahu Hershfeld 2011 - 2023
 */
- (NSUInteger)hash __attribute__((swift_name("hash()")));

/**
 * An Object representing a *daf* (page) in the [Daf Yomi](https://en.wikipedia.org/wiki/Daf_Yomi) cycle.
 *
 * @param masechtaNumber the *masechta* number in the order of the Daf Yomi to set as the current *masechta*.
 * @param daf the *daf* (page) number to set.
 *
 * @author  Eliyahu Hershfeld 2011 - 2023
 */
- (NSString *)description __attribute__((swift_name("description()")));

/**
 * The *daf* (page) number of the Daf Yomi.
 */
@property int32_t daf __attribute__((swift_name("daf")));

/**
 * Returns the *masechta* (tractate) of the Daf Yomi in Hebrew. The list is in the following format<br></br>
 * `["ברכות",
 * "שבת", "עירובין",
 * "פסחים", "שקלים", "יומא",
 * "סוכה", "ביצה", "ראש השנה",
 * "תענית", "מגילה", "מועד
 * קטן", "חגיגה", "יבמות",
 * "כתובות", "נדרים","נזיר",
 * "סוטה", "גיטין", "קידושין",
 * "בבא קמא", "בבא מציעא",
 * "בבא בתרא", "סנהדרין",
 * "מכות", "שבועות", "עבודה
 * זרה", "הוריות", "זבחים",
 * "מנחות", "חולין", "בכורות",
 * "ערכין", "תמורה", "כריתות",
 * "מעילה", "קינים", "תמיד",
 * "מידות", "נדה"]`.
 *
 * @return the *masechta* (tractate) of the Daf Yomi in Hebrew. As an example, it will return
 * ברכות
 * "" for Berachos.
 */
@property (readonly) NSString *masechta __attribute__((swift_name("masechta")));

/**
 * The *masechta* number of the currently set *Daf*. The sequence is: Berachos, Shabbos, Eruvin,
 * Pesachim, Shekalim, Yoma, Sukkah, Beitzah, Rosh Hashana, Taanis, Megillah, Moed Katan, Chagigah, Yevamos, Kesubos,
 * Nedarim, Nazir, Sotah, Gitin, Kiddushin, Bava Kamma, Bava Metzia, Bava Basra, Sanhedrin, Makkos, Shevuos, Avodah
 * Zarah, Horiyos, Zevachim, Menachos, Chullin, Bechoros, Arachin, Temurah, Kerisos, Meilah, Kinnim, Tamid, Midos and
 * Niddah.
 */
@property int32_t masechtaNumber __attribute__((swift_name("masechtaNumber")));

/**
 * Returns the transliterated name of the *masechta* (tractate) of the Daf Yomi. The list of *mashechtos*
 * is: Berachos, Shabbos, Eruvin, Pesachim, Shekalim, Yoma, Sukkah, Beitzah, Rosh Hashana, Taanis, Megillah, Moed Katan,
 * Chagigah, Yevamos, Kesubos, Nedarim, Nazir, Sotah, Gitin, Kiddushin, Bava Kamma, Bava Metzia, Bava Basra, Sanhedrin,
 * Makkos, Shevuos, Avodah Zarah, Horiyos, Zevachim, Menachos, Chullin, Bechoros, Arachin, Temurah, Kerisos, Meilah,
 * Kinnim, Tamid, Midos and Niddah.
 *
 * @return the transliterated name of the *masechta* (tractate) of the Daf Yomi such as Berachos.
 * @see .setMasechtaTransliterated
 */
@property (readonly) NSString *masechtaTransliterated __attribute__((swift_name("masechtaTransliterated")));

/**
 * Returns the Yerushalmi *masechta* (tractate) of the Daf Yomi in Hebrew. As an example, it will return
 * &#x05D1;&#x05E8;&#x05DB;&#x05D5;&#x05EA; for Berachos.
 *
 * @return the Yerushalmi *masechta* (tractate) of the Daf Yomi in Hebrew. As an example, it will return
 * &#x05D1;&#x05E8;&#x05DB;&#x05D5;&#x05EA; for Berachos.
 */
@property (readonly) NSString *yerushalmiMasechta __attribute__((swift_name("yerushalmiMasechta")));

/**
 * Returns the transliterated name of the *masechta* (tractate) of the Daf Yomi in Yerushalmi. The list of
 * *mashechtos* is:
 * Berachos, Pe'ah, Demai, Kilayim, Shevi'is, Terumos, Ma'asros, Ma'aser Sheni, Chalah, Orlah, Bikurim,
 * Shabbos, Eruvin, Pesachim, Beitzah, Rosh Hashanah, Yoma, Sukah, Ta'anis, Shekalim, Megilah, Chagigah,
 * Moed Katan, Yevamos, Kesuvos, Sotah, Nedarim, Nazir, Gitin, Kidushin, Bava Kama, Bava Metzia,
 * Bava Basra, Shevuos, Makos, Sanhedrin, Avodah Zarah, Horayos, Nidah and No Daf Today.
 *
 * @return the transliterated name of the *masechta* (tractate) of the Daf Yomi such as Berachos.
 */
@property (readonly) NSString *yerushalmiMasechtaTransliterated __attribute__((swift_name("yerushalmiMasechtaTransliterated")));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("Daf.Companion")))
@interface STTDafCompanion : STTBase
+ (instancetype)alloc __attribute__((unavailable));
+ (instancetype)allocWithZone:(struct _NSZone *)zone __attribute__((unavailable));
+ (instancetype)companion __attribute__((swift_name("init()")));
@property (class, readonly, getter=shared) STTDafCompanion *shared __attribute__((swift_name("shared")));
@property NSString *ARACHIN __attribute__((swift_name("ARACHIN")));
@property NSString *AVODAH_ZARA __attribute__((swift_name("AVODAH_ZARA")));
@property NSString *BAVA_BASRA __attribute__((swift_name("BAVA_BASRA")));
@property NSString *BAVA_KAMMA __attribute__((swift_name("BAVA_KAMMA")));
@property NSString *BAVA_METZIA __attribute__((swift_name("BAVA_METZIA")));
@property NSString *BECHOROS __attribute__((swift_name("BECHOROS")));
@property NSString *BEITZAH __attribute__((swift_name("BEITZAH")));
@property NSString *BIKURIM __attribute__((swift_name("BIKURIM")));
@property NSString *BRACHOS __attribute__((swift_name("BRACHOS")));
@property NSString *CHAGIGAH __attribute__((swift_name("CHAGIGAH")));
@property NSString *CHALAH __attribute__((swift_name("CHALAH")));
@property NSString *CHULLIN __attribute__((swift_name("CHULLIN")));
@property NSString *DEMAI __attribute__((swift_name("DEMAI")));
@property NSString *ERUVIN __attribute__((swift_name("ERUVIN")));
@property NSString *GITIN __attribute__((swift_name("GITIN")));
@property NSString *HORIYOS __attribute__((swift_name("HORIYOS")));
@property NSString *KERISOS __attribute__((swift_name("KERISOS")));
@property NSString *KESUBOS __attribute__((swift_name("KESUBOS")));
@property NSString *KIDDUSHIN __attribute__((swift_name("KIDDUSHIN")));
@property NSString *KILAYIM __attribute__((swift_name("KILAYIM")));
@property NSString *KINNIM __attribute__((swift_name("KINNIM")));
@property NSString *MAASER_SHENI __attribute__((swift_name("MAASER_SHENI")));
@property NSString *MAASROS __attribute__((swift_name("MAASROS")));
@property NSString *MAKKOS __attribute__((swift_name("MAKKOS")));
@property NSString *MEGILLAH __attribute__((swift_name("MEGILLAH")));
@property NSString *MEILAH __attribute__((swift_name("MEILAH")));
@property NSString *MENACHOS __attribute__((swift_name("MENACHOS")));
@property NSString *MIDOS __attribute__((swift_name("MIDOS")));
@property NSString *MOED_KATAN __attribute__((swift_name("MOED_KATAN")));
@property NSString *NAZIR __attribute__((swift_name("NAZIR")));
@property NSString *NEDARIM __attribute__((swift_name("NEDARIM")));
@property NSString *NIDDAH __attribute__((swift_name("NIDDAH")));
@property NSString *ORLAH __attribute__((swift_name("ORLAH")));
@property NSString *PEAH __attribute__((swift_name("PEAH")));
@property NSString *PESACHIM __attribute__((swift_name("PESACHIM")));
@property NSString *ROSH_HASHANA __attribute__((swift_name("ROSH_HASHANA")));
@property NSString *SANHEDRIN __attribute__((swift_name("SANHEDRIN")));
@property NSString *SHABBOS __attribute__((swift_name("SHABBOS")));
@property NSString *SHAVUOS __attribute__((swift_name("SHAVUOS")));
@property NSString *SHEKALIM __attribute__((swift_name("SHEKALIM")));
@property NSString *SHEVIIS __attribute__((swift_name("SHEVIIS")));
@property NSString *SOTAH __attribute__((swift_name("SOTAH")));
@property NSString *SUKKAH __attribute__((swift_name("SUKKAH")));
@property NSString *TAANIS __attribute__((swift_name("TAANIS")));
@property NSString *TAMID __attribute__((swift_name("TAMID")));
@property NSString *TEMURAH __attribute__((swift_name("TEMURAH")));
@property NSString *TERUMOS __attribute__((swift_name("TERUMOS")));
@property NSString *YEVAMOS __attribute__((swift_name("YEVAMOS")));
@property NSString *YOMA __attribute__((swift_name("YOMA")));
@property NSString *ZEVACHIM __attribute__((swift_name("ZEVACHIM")));

/**
 * See [masechta].
 */
@property (readonly) STTKotlinArray<NSString *> *masechtosBavli __attribute__((swift_name("masechtosBavli")));
@property STTKotlinArray<NSString *> *masechtosBavliTransliterated __attribute__((swift_name("masechtosBavliTransliterated")));

/**
 * See [.getYerushalmiMasechta].
 */
@property (readonly) STTKotlinArray<NSString *> *yerushalmiMasechtos __attribute__((swift_name("yerushalmiMasechtos")));

/**
 * See [.getYerushalmiMasechtaTransliterated].
 */
@property STTKotlinArray<NSString *> *yerushalmiMasechtosTransliterated __attribute__((swift_name("yerushalmiMasechtosTransliterated")));
@end


/**
 * The HebrewDateFormatter class formats a [JewishDate].
 *
 * The class formats Jewish dates, numbers, *Daf Yomi* (*Bavli* and *Yerushalmi*), the *Omer*,
 * *Parshas Hashavua* (including the special *parshiyos* of *Shekalim*, *Zachor*, *Parah*
 * and *Hachodesh*), Yomim Tovim and the Molad (experimental) in Hebrew or Latin chars, and has various settings.
 * Sample full date output includes (using various options):
 *
 *  * 21 Shevat, 5729
 *  * כא שבט תשכט
 *  * כ״א שבט ה׳תשכ״ט
 *  * כ״א שבט תש״פ or
 * כ״א שבט תש״ף
 *  * כ׳ שבט ו׳ אלפים
 *
 *
 * @see JewishDate
 *
 * @see JewishCalendar
 *
 *
 * @author  Eliyahu Hershfeld 2011 - 2023
 */
__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("HebrewDateFormatter")))
@interface STTHebrewDateFormatter : STTBase

/**
 * The HebrewDateFormatter class formats a [JewishDate].
 *
 * The class formats Jewish dates, numbers, *Daf Yomi* (*Bavli* and *Yerushalmi*), the *Omer*,
 * *Parshas Hashavua* (including the special *parshiyos* of *Shekalim*, *Zachor*, *Parah*
 * and *Hachodesh*), Yomim Tovim and the Molad (experimental) in Hebrew or Latin chars, and has various settings.
 * Sample full date output includes (using various options):
 *
 *  * 21 Shevat, 5729
 *  * כא שבט תשכט
 *  * כ״א שבט ה׳תשכ״ט
 *  * כ״א שבט תש״פ or
 * כ״א שבט תש״ף
 *  * כ׳ שבט ו׳ אלפים
 *
 *
 * @see JewishDate
 *
 * @see JewishCalendar
 *
 *
 * @author  Eliyahu Hershfeld 2011 - 2023
 */
- (instancetype)init __attribute__((swift_name("init()"))) __attribute__((objc_designated_initializer));

/**
 * The HebrewDateFormatter class formats a [JewishDate].
 *
 * The class formats Jewish dates, numbers, *Daf Yomi* (*Bavli* and *Yerushalmi*), the *Omer*,
 * *Parshas Hashavua* (including the special *parshiyos* of *Shekalim*, *Zachor*, *Parah*
 * and *Hachodesh*), Yomim Tovim and the Molad (experimental) in Hebrew or Latin chars, and has various settings.
 * Sample full date output includes (using various options):
 *
 *  * 21 Shevat, 5729
 *  * כא שבט תשכט
 *  * כ״א שבט ה׳תשכ״ט
 *  * כ״א שבט תש״פ or
 * כ״א שבט תש״ף
 *  * כ׳ שבט ו׳ אלפים
 *
 *
 * @see JewishDate
 *
 * @see JewishCalendar
 *
 *
 * @author  Eliyahu Hershfeld 2011 - 2023
 */
+ (instancetype)new __attribute__((availability(swift, unavailable, message="use object initializers instead")));
@property (class, readonly, getter=companion) STTHebrewDateFormatterCompanion *companion __attribute__((swift_name("companion")));

/**
 * Formats the Jewish date. If the formatter is set to Hebrew, it will format in the form, "day Month year" for
 * example כ״א שבט תשכ״ט, and the format
 * "21 Shevat, 5729" if not.
 *
 * @param jewishDate
 * the JewishDate to be formatted
 * @return the formatted date. If the formatter is set to Hebrew, it will format in the form, "day Month year" for
 * example כ״א שבט תשכ״ט, and the format
 * "21 Shevat, 5729" if not.
 */
- (NSString *)formatJewishDate:(STTJewishDate *)jewishDate __attribute__((swift_name("format(jewishDate:)")));

/**
 * Formats the [Daf Yomi](https://en.wikipedia.org/wiki/Daf_Yomi) Bavli in the format of
 * "עירובין נ״ב" in [Hebrew][isHebrewFormat],
 * or the transliterated format of "Eruvin 52".
 * @param daf the Daf to be formatted.
 * @return the formatted daf.
 */
- (NSString *)formatDafYomiBavliDaf:(STTDaf *)daf __attribute__((swift_name("formatDafYomiBavli(daf:)")));

/**
 * Formats the [Daf Yomi Yerushalmi](https://en.wikipedia.org/wiki/Jerusalem_Talmud#Daf_Yomi_Yerushalmi) in the format
 * of "עירובין נ״ב" in [Hebrew][isHebrewFormat], or
 * the transliterated format of "Eruvin 52".
 *
 * @param daf the Daf to be formatted.
 * @return the formatted daf.
 */
- (NSString *)formatDafYomiYerushalmiDaf:(STTDaf * _Nullable)daf __attribute__((swift_name("formatDafYomiYerushalmi(daf:)")));

/**
 * Formats the day of week. If [Hebrew formatting][.isHebrewFormat] is set, it will display in the format
 * ראשון etc. If Hebrew formatting is not in use it will return it in the format
 * of Sunday etc. There are various formatting options that will affect the output.
 *
 * @param jewishDate the JewishDate Object
 * @return the formatted day of week
 * @see .isHebrewFormat
 * @see .isLongWeekFormat
 */
- (NSString *)formatDayOfWeekJewishDate:(STTJewishDate *)jewishDate __attribute__((swift_name("formatDayOfWeek(jewishDate:)")));

/**
 * Returns a Hebrew formatted string of a number. The method can calculate from 0 - 9999.
 *
 *  * Single digit numbers such as 3, 30 and 100 will be returned with a ׳ ([Geresh](http://en.wikipedia.org/wiki/Geresh)) appended as at the end. For example ג׳,
 * ל׳ and ק׳
 *  * multi digit numbers such as 21 and 769 will be returned with a ״ ([Gershayim](http://en.wikipedia.org/wiki/Gershayim)) between the second to last and last letters. For
 * example כ״א, תשכ״ט
 *  * 15 and 16 will be returned as ט״ו and ט״ז
 *  * Single digit numbers (years assumed) such as 6000 (%1000=0) will be returned as ו׳
 * אלפים
 *  * 0 will return אפס
 *
 *
 * @param number
 * the number to be formatted. It will trow an IllegalArgumentException if the number is < 0 or > 9999.
 * @return the Hebrew formatted number such as תשכ״ט
 * @see isUseFinalFormLetters
 * @see isUseGershGershayim
 * @see isHebrewFormat
 */
- (NSString *)formatHebrewNumberNumber:(int32_t)number __attribute__((swift_name("formatHebrewNumber(number:)")));
- (NSString *)formatHebrewNumberNumber_:(int64_t)number __attribute__((swift_name("formatHebrewNumber(number_:)")));

/**
 * Returns a string of the current Hebrew month such as "Tishrei". Returns a string of the current Hebrew month such
 * as "אדר ב׳".
 *
 * @param jewishDate
 * the JewishDate to format
 * @return the formatted month name
 * @see isHebrewFormat
 * @see transliteratedMonthList
 */
- (NSString *)formatMonthJewishDate:(STTJewishDate *)jewishDate __attribute__((swift_name("formatMonth(jewishDate:)")));

/**
 * Returns a String of the Omer day in the form ל״ג בעומר if
 * Hebrew Format is set, or "Omer X" or "Lag B'Omer" if not. An empty string if there is no Omer this day.
 *
 * @param jewishCalendar
 * the JewishCalendar to be formatted
 *
 * @return a String of the Omer day in the form or an empty string if there is no Omer this day. The default
 * formatting has a ב׳ prefix that would output בעומר, but this
 * can be set via the [hebrewOmerPrefix] method to use a ל and output
 * ל״ג לעומר.
 * @see isHebrewFormat
 * @see hebrewOmerPrefix
 */
- (NSString *)formatOmerJewishCalendar:(STTJewishCalendar *)jewishCalendar __attribute__((swift_name("formatOmer(jewishCalendar:)")));

/**
 * Returns a String with the name of the current parsha(ios). If the formatter is set to format in Hebrew, returns
 * a string of the current parsha(ios) in Hebrew for example בראשית or
 * נצבים וילך or an empty string if there
 * are none. If not set to Hebrew, it returns a string of the parsha(ios) transliterated into Latin chars. The
 * default uses Ashkenazi pronunciation in typical American English spelling, for example Bereshis or
 * Nitzavim Vayeilech or an empty string if there are none.
 *
 * @param jewishCalendar the JewishCalendar Object
 * @return today's parsha(ios) in Hebrew for example, if the formatter is set to format in Hebrew, returns a string
 * of the current parsha(ios) in Hebrew for example בראשית or
 * נצבים וילך or an empty string if
 * there are none. If not set to Hebrew, it returns a string of the parsha(ios) transliterated into Latin
 * chars. The default uses Ashkenazi pronunciation in typical American English spelling, for example
 * Bereshis or Nitzavim Vayeilech or an empty string if there are none.
 */
- (NSString * _Nullable)formatParshaJewishCalendar:(STTJewishCalendar *)jewishCalendar __attribute__((swift_name("formatParsha(jewishCalendar:)")));

/**
 * Formats a day as Rosh Chodesh in the format of in the format of ראש
 * חודש שבט or Rosh Chodesh Shevat. If it
 * is not Rosh Chodesh, an empty `String` will be returned.
 * @param jewishCalendar the JewishCalendar
 * @return The formatted `String` in the format of ראש
 * חודש שבט or Rosh Chodesh Shevat. If it
 * is not Rosh Chodesh, an empty `String` will be returned.
 */
- (NSString *)formatRoshChodeshJewishCalendar:(STTJewishCalendar *)jewishCalendar __attribute__((swift_name("formatRoshChodesh(jewishCalendar:)")));

/**
 * Returns a String with the name of the current special parsha of Shekalim, Zachor, Parah or Hachodesh or an
 * empty String for a non-special parsha. If the formatter is set to format in Hebrew, it returns a string of
 * the current special parsha in Hebrew, for example שקלים,
 * זכור, פרה or החדש. An empty
 * string if the date is not a special parsha. If not set to Hebrew, it returns a string of the special parsha
 * transliterated into Latin chars. The default uses Ashkenazi pronunciation in typical American English spelling
 * Shekalim, Zachor, Parah or Hachodesh.
 *
 * @param jewishCalendar the JewishCalendar Object
 * @return today's special parsha. If the formatter is set to format in Hebrew, returns a string
 * of the current special parsha  in Hebrew for in the format of שקלים,
 * זכור, פרה or החדש or an empty
 * string if there are none. If not set to Hebrew, it returns a string of the special parsha transliterated
 * into Latin chars. The default uses Ashkenazi pronunciation in typical American English spelling of Shekalim,
 * Zachor, Parah or Hachodesh. An empty string if there are none.
 */
- (NSString * _Nullable)formatSpecialParshaJewishCalendar:(STTJewishCalendar *)jewishCalendar __attribute__((swift_name("formatSpecialParsha(jewishCalendar:)")));

/**
 * Formats the Yom Tov (holiday) in Hebrew or transliterated Latin characters.
 *
 * @param jewishCalendar the JewishCalendar
 * @return the formatted holiday or an empty String if the day is not a holiday.
 * @see isHebrewFormat
 */
- (NSString *)formatYomTovJewishCalendar:(STTJewishCalendar *)jewishCalendar __attribute__((swift_name("formatYomTov(jewishCalendar:)")));

/**
 * Returns the kviah in the traditional 3 letter Hebrew format where the first letter represents the day of week of
 * Rosh Hashana, the second letter represents the lengths of Cheshvan and Kislev ([Shelaimim][JewishDate.SHELAIMIM] , [Kesidran][JewishDate.KESIDRAN] or [Chaserim][JewishDate.CHASEIRIM]) and the 3rd letter
 * represents the day of week of Pesach. For example 5729 (1969) would return בשה (Rosh Hashana on
 * Monday, Shelaimim, and Pesach on Thursday), while 5771 (2011) would return השג (Rosh Hashana on
 * Thursday, Shelaimim, and Pesach on Tuesday).
 *
 * @param jewishYear
 * the Jewish year
 * @return the Hebrew String such as בשה for 5729 (1969) and השג for 5771
 * (2011).
 */
- (NSString *)getFormattedKviahJewishYear:(int32_t)jewishYear __attribute__((swift_name("getFormattedKviah(jewishYear:)")));
- (NSString *)getFormattedKviahJewishYear_:(int64_t)jewishYear __attribute__((swift_name("getFormattedKviah(jewishYear_:)")));

/**
 * The Hebrew omer prefix character. It defaults to ב producing בעומר,
 * but can be set to ל to produce לעומר (or any other prefix).
 */
@property NSString *hebrewOmerPrefix __attribute__((swift_name("hebrewOmerPrefix")));

/**
 * Returns if the formatter is set to use Hebrew formatting in the various formatting methods.
 *
 * @return the hebrewFormat
 * @see format
 * @see formatDayOfWeek
 * @see formatMonth
 * @see formatOmer
 * @see formatYomTov
 */
@property BOOL isHebrewFormat __attribute__((swift_name("isHebrewFormat")));

/**
 * Setting to control if the [formatDayOfWeek] will use the long format such as
 * ראשון or short such as א when formatting the day of week in
 * [Hebrew][isHebrewFormat].
 *
 */
@property BOOL isLongWeekFormat __attribute__((swift_name("isLongWeekFormat")));

/**
 * When formatting a Hebrew Year, traditionally years ending in 20, 40, 50, 80 and 90 are formatted using non-final
 * form letters for example תש״פ for the year 5780. Setting this to true (the default
 * is false) will use the final form letters for מנצפ״ך and will format
 * the year 5780 as תש״ף.
 *
 * Set this to true to use final form letters when formatting Hebrew years.
 */
@property BOOL isUseFinalFormLetters __attribute__((swift_name("isUseFinalFormLetters")));

/**
 * Sets whether to use the Geresh ׳ and Gershayim ״ in formatting Hebrew dates and numbers. The default
 * value is true and output would look like כ״א שבט תש״כ
 * (or כ״א שבט תש״ך). When set to false, this output would
 * display as כא שבט תשכ (or
 * כא שבט תשך). Single digit days or month or years such as כ׳
 * שבט ו׳ אלפים show the use of the Geresh.
 *
 * Set to false to omit the Geresh ׳ and Gershayim ״ in formatting
 */
@property BOOL isUseGershGershayim __attribute__((swift_name("isUseGershGershayim")));

/**
 * Returns whether the class is set to use the thousand's digit when formatting: true if set to use the thousand's
 * digit when formatting Hebrew dates and numbers.
 *
 * When formatting a Hebrew Year, traditionally the thousands digit is omitted and output for a year such as 5729
 * (1969 Gregorian) would be calculated for 729 and format as &#x5EA;&#x5E9;&#x5DB;&#x5F4;&#x5D8;.
 * When set to true the long format year such as &#x5D4;&#x5F3; &#x5EA;&#x5E9;&#x5DB;&#x5F4;&#x5D8; for 5729/1969 is returned.
 */
@property BOOL isUseLongHebrewYears __attribute__((swift_name("isUseLongHebrewYears")));

/**
 * Returns the list of holidays transliterated into Latin chars. This is used by the
 * [formatYomTov] when formatting the Yom Tov String. The default list of months uses
 * Ashkenazi pronunciation in typical American English spelling.
 *
 * When setting, ensure that the sequence exactly matches the list returned by the
 * default
 *
 * @return the list of transliterated holidays. The default list is currently ["Erev Pesach", "Pesach",
 * "Chol Hamoed Pesach", "Pesach Sheni", "Erev Shavuos", "Shavuos", "Seventeenth of Tammuz", "Tishah B'Av",
 * "Tu B'Av", "Erev Rosh Hashana", "Rosh Hashana", "Fast of Gedalyah", "Erev Yom Kippur", "Yom Kippur",
 * "Erev Succos", "Succos", "Chol Hamoed Succos", "Hoshana Rabbah", "Shemini Atzeres", "Simchas Torah",
 * "Erev Chanukah", "Chanukah", "Tenth of Teves", "Tu B'Shvat", "Fast of Esther", "Purim", "Shushan Purim",
 * "Purim Katan", "Rosh Chodesh", "Yom HaShoah", "Yom Hazikaron", "Yom Ha'atzmaut", "Yom Yerushalayim",
 * "Lag B'Omer","Shushan Purim Katan","Isru Chag"].
 *
 * @see transliteratedMonthList
 * @see formatYomTov
 * @see isHebrewFormat
 */
@property STTKotlinArray<NSString *> *transliteratedHolidayList __attribute__((swift_name("transliteratedHolidayList")));

/**
 * Returns the list of months transliterated into Latin chars. The default list of months uses Ashkenazi
 * pronunciation in typical American English spelling. This list has a length of 14 with 3 variations for Adar -
 * "Adar", "Adar II", "Adar I"
 *
 * @return the list of months beginning in Nissan and ending in in "Adar", "Adar II", "Adar I". The default list is
 * currently ["Nissan", "Iyar", "Sivan", "Tammuz", "Av", "Elul", "Tishrei", "Cheshvan", "Kislev", "Teves",
 * "Shevat", "Adar", "Adar II", "Adar I"].
 */
@property STTKotlinArray<NSString *> *transliteratedMonthList __attribute__((swift_name("transliteratedMonthList")));

/**
 * List of transliterated parshiyos using the default *Ashkenazi* pronunciation.&nbsp; The formatParsha method
 * uses this for transliterated *parsha* formatting.&nbsp; This list can be overridden (for *Sephardi*
 * English transliteration for example) by setting the [transliteratedParshiosList].&nbsp; The list
 * includes double and special *parshiyos* is set as "*Bereshis, Noach, Lech Lecha, Vayera, Chayei Sara,
 * Toldos, Vayetzei, Vayishlach, Vayeshev, Miketz, Vayigash, Vayechi, Shemos, Vaera, Bo, Beshalach, Yisro, Mishpatim,
 * Terumah, Tetzaveh, Ki Sisa, Vayakhel, Pekudei, Vayikra, Tzav, Shmini, Tazria, Metzora, Achrei Mos, Kedoshim, Emor,
 * Behar, Bechukosai, Bamidbar, Nasso, Beha'aloscha, Sh'lach, Korach, Chukas, Balak, Pinchas, Matos, Masei, Devarim,
 * Vaeschanan, Eikev, Re'eh, Shoftim, Ki Seitzei, Ki Savo, Nitzavim, Vayeilech, Ha'Azinu, Vezos Habracha,
 * Vayakhel Pekudei, Tazria Metzora, Achrei Mos Kedoshim, Behar Bechukosai, Chukas Balak, Matos Masei, Nitzavim Vayeilech,
 * Shekalim, Zachor, Parah, Hachodesh,Shuva, Shira, Hagadol, Chazon, Nachamu*".
 *
 * @see .formatParsha
 */
@property NSDictionary<STTJewishCalendarParsha *, NSString *> *transliteratedParshiosList __attribute__((swift_name("transliteratedParshiosList")));

/**
 * Returns the day of Shabbos transliterated into Latin chars. The default uses Ashkenazi pronunciation "Shabbos".
 * This can be overwritten using the [transliteratedShabbosDayOfWeek] to alternate spellings such as "Shabbat" used by
 * the [formatDayOfWeek]
 *
 * @return the transliteratedShabbos. The default list of months uses Ashkenazi pronunciation "Shabbos".
 * @see formatDayOfWeek
 */
@property NSString *transliteratedShabbosDayOfWeek __attribute__((swift_name("transliteratedShabbosDayOfWeek")));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("HebrewDateFormatter.Companion")))
@interface STTHebrewDateFormatterCompanion : STTBase
+ (instancetype)alloc __attribute__((unavailable));
+ (instancetype)allocWithZone:(struct _NSZone *)zone __attribute__((unavailable));
+ (instancetype)companion __attribute__((swift_name("init()")));
@property (class, readonly, getter=shared) STTHebrewDateFormatterCompanion *shared __attribute__((swift_name("shared")));
@property (readonly) int32_t DAY_CHALAKIM __attribute__((swift_name("DAY_CHALAKIM")));
@property (readonly) int32_t HOUR_CHALAKIM __attribute__((swift_name("HOUR_CHALAKIM")));
@property (readonly) int32_t MINUTE_CHALAKIM __attribute__((swift_name("MINUTE_CHALAKIM")));
@end


/**
 * A class representing a Hebrew local date. Hebrew analog to [java.time.LocalDate] or [kotlinx.datetime.LocalDate]
 * Although the Hebrew year actually starts in [HebrewMonth.TISHREI], the choice was made to assign [HebrewMonth.NISSAN]
 * with a value of 1. This may be because the year is colloquially said to start in Nissan (in accordance with the
 * opinion Maseches Rosh Hashana (TODO include source) that the world was created in Nissan).
 * **Note:** this class considers the Gregorian calendar to start at year 0, in accordance with ISO-8601.
 * @param year the Hebrew year Ano Mundi, e.g. 5783 (2023 Gregorian)
 * @param dayOfMonth the day of the month. This is a value between 1 and 30. Leap years can change the upper-bound of this number.
 * @param month the Hebrew month. This is a value between 1 and 13. The value of 13 represents Adar II on a leap year.
 * */
__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("HebrewLocalDate")))
@interface STTHebrewLocalDate : STTBase <STTKotlinComparable>
- (instancetype)initWithYear:(int32_t)year month:(STTHebrewMonth *)month dayOfMonth:(int32_t)dayOfMonth __attribute__((swift_name("init(year:month:dayOfMonth:)"))) __attribute__((objc_designated_initializer));
- (instancetype)initWithYear:(int64_t)year month:(STTHebrewMonth *)month dayOfMonth_:(int32_t)dayOfMonth __attribute__((swift_name("init(year:month:dayOfMonth_:)"))) __attribute__((objc_designated_initializer));
@property (class, readonly, getter=companion) STTHebrewLocalDateCompanion *companion __attribute__((swift_name("companion")));

/**
 * Compares this date to another date.
 *
 *
 * The comparison is primarily based on the date, from earliest to latest.
 * It is "consistent with equals", as defined by [Comparable].
 *
 * @param other  the other date to compare to
 * @return the comparator value, negative if less, positive if greater
 */
- (int32_t)compareToOther:(STTHebrewLocalDate *)other __attribute__((swift_name("compareTo(other:)")));

/**
 * A class representing a Hebrew local date. Hebrew analog to [java.time.LocalDate] or [kotlinx.datetime.LocalDate]
 * Although the Hebrew year actually starts in [HebrewMonth.TISHREI], the choice was made to assign [HebrewMonth.NISSAN]
 * with a value of 1. This may be because the year is colloquially said to start in Nissan (in accordance with the
 * opinion Maseches Rosh Hashana (TODO include source) that the world was created in Nissan).
 * **Note:** this class considers the Gregorian calendar to start at year 0, in accordance with ISO-8601.
 * @param year the Hebrew year Ano Mundi, e.g. 5783 (2023 Gregorian)
 * @param dayOfMonth the day of the month. This is a value between 1 and 30. Leap years can change the upper-bound of this number.
 * @param month the Hebrew month. This is a value between 1 and 13. The value of 13 represents Adar II on a leap year.
 * */
- (STTHebrewLocalDate *)doCopyYear:(int64_t)year month:(STTHebrewMonth *)month dayOfMonth:(int32_t)dayOfMonth __attribute__((swift_name("doCopy(year:month:dayOfMonth:)")));

/**
 * A class representing a Hebrew local date. Hebrew analog to [java.time.LocalDate] or [kotlinx.datetime.LocalDate]
 * Although the Hebrew year actually starts in [HebrewMonth.TISHREI], the choice was made to assign [HebrewMonth.NISSAN]
 * with a value of 1. This may be because the year is colloquially said to start in Nissan (in accordance with the
 * opinion Maseches Rosh Hashana (TODO include source) that the world was created in Nissan).
 * **Note:** this class considers the Gregorian calendar to start at year 0, in accordance with ISO-8601.
 * @param year the Hebrew year Ano Mundi, e.g. 5783 (2023 Gregorian)
 * @param dayOfMonth the day of the month. This is a value between 1 and 30. Leap years can change the upper-bound of this number.
 * @param month the Hebrew month. This is a value between 1 and 13. The value of 13 represents Adar II on a leap year.
 * */
- (BOOL)isEqual:(id _Nullable)other __attribute__((swift_name("isEqual(_:)")));

/**
 * A class representing a Hebrew local date. Hebrew analog to [java.time.LocalDate] or [kotlinx.datetime.LocalDate]
 * Although the Hebrew year actually starts in [HebrewMonth.TISHREI], the choice was made to assign [HebrewMonth.NISSAN]
 * with a value of 1. This may be because the year is colloquially said to start in Nissan (in accordance with the
 * opinion Maseches Rosh Hashana (TODO include source) that the world was created in Nissan).
 * **Note:** this class considers the Gregorian calendar to start at year 0, in accordance with ISO-8601.
 * @param year the Hebrew year Ano Mundi, e.g. 5783 (2023 Gregorian)
 * @param dayOfMonth the day of the month. This is a value between 1 and 30. Leap years can change the upper-bound of this number.
 * @param month the Hebrew month. This is a value between 1 and 13. The value of 13 represents Adar II on a leap year.
 * */
- (NSUInteger)hash __attribute__((swift_name("hash()")));

/**
 * Returns a copy of this [HebrewLocalDate] with the specified number of days added.
 *
 *
 * This method adds the specified amount to the days field incrementing the
 * month and year fields as necessary to ensure the result remains valid.
 * The result is only invalid if the maximum/minimum year is exceeded.
 *
 *
 * For example, 2008-12-31 plus one day would result in 2009-01-01.
 *
 *
 * This instance is immutable and unaffected by this method call.
 *
 * @param daysToAdd  the days to add, may be negative
 * @return a [HebrewLocalDate] based on this date with the days added, not null
 * @throws DateTimeException if the result exceeds the supported date range //TODO
 */
- (STTHebrewLocalDate *)plusDaysDays:(int64_t)days __attribute__((swift_name("plusDays(days:)")));

/**
 * Returns the absolute date of Jewish date. ND+ER
 *
 * @param year
 * the Jewish year. The year can't be negative
 * @param month
 * the Jewish month starting with Nisan. Nisan expects a value of 1 etc till Adar with a value of 12. For
 * a leap year, 13 will be the expected value for Adar II. Use the constants [HebrewMonth.NISSAN]
 * etc.
 * @param dayOfMonth
 * the Jewish day of month. valid values are 1-30. If the day of month is set to 30 for a month that only
 * has 29 days, the day will be set as 29.
 * @return the absolute date of the Jewish date.
 */
- (int64_t)toJewishEpochDays __attribute__((swift_name("toJewishEpochDays()")));

/**
 * Computes the Gregorian [LocalDate] of a given [HebrewLocalDate].
 * **Note:** this class considers the Gregorian calendar to start at year 0, in accordance with ISO-8601.
 */
- (STTKotlinx_datetimeLocalDate *)toLocalDateGregorian __attribute__((swift_name("toLocalDateGregorian()")));

/**
 * A class representing a Hebrew local date. Hebrew analog to [java.time.LocalDate] or [kotlinx.datetime.LocalDate]
 * Although the Hebrew year actually starts in [HebrewMonth.TISHREI], the choice was made to assign [HebrewMonth.NISSAN]
 * with a value of 1. This may be because the year is colloquially said to start in Nissan (in accordance with the
 * opinion Maseches Rosh Hashana (TODO include source) that the world was created in Nissan).
 * **Note:** this class considers the Gregorian calendar to start at year 0, in accordance with ISO-8601.
 * @param year the Hebrew year Ano Mundi, e.g. 5783 (2023 Gregorian)
 * @param dayOfMonth the day of the month. This is a value between 1 and 30. Leap years can change the upper-bound of this number.
 * @param month the Hebrew month. This is a value between 1 and 13. The value of 13 represents Adar II on a leap year.
 * */
- (NSString *)description __attribute__((swift_name("description()")));

/**
 * Returns this object with the [dayOfMonth] set to the given [newDayOfMonth].
 *
 * **Note:** This method does not change the month or year (e.g. passing in a value of 32 does not increment the month).
 * */
- (STTHebrewLocalDate *)withDayOfMonthNewDayOfMonth:(int32_t)newDayOfMonth __attribute__((swift_name("withDayOfMonth(newDayOfMonth:)")));

/**
 * Returns this object with the [month] set to the given [newMonth].
 *
 * **Note:** This method does not change the day or year (e.g. if the [dayOfMonth] is 30 and [newMonth] only has 29 days, [dayOfMonth] will remain 30).
 * */
- (STTHebrewLocalDate *)withMonthNewMonth:(STTHebrewMonth *)newMonth __attribute__((swift_name("withMonth(newMonth:)")));
- (STTHebrewLocalDate *)withYearNewYear:(int32_t)newYear __attribute__((swift_name("withYear(newYear:)")));

/**
 *
 * Returns this object with the [year] set to the given [newYear].
 *
 * **Note:** This method does not change the day or month (e.g. if the [month] was the leap month [HebrewMonth.ADAR_II], and [newYear] is not a leap year, the month will remain [HebrewMonth.ADAR_II]).
 * */
- (STTHebrewLocalDate *)withYearNewYear_:(int64_t)newYear __attribute__((swift_name("withYear(newYear_:)")));
@property (readonly) int32_t dayOfMonth __attribute__((swift_name("dayOfMonth")));
@property (readonly) BOOL isJewishLeapYear __attribute__((swift_name("isJewishLeapYear")));
@property (readonly) STTHebrewMonth *month __attribute__((swift_name("month")));
@property (readonly) int64_t year __attribute__((swift_name("year")));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("HebrewLocalDate.Companion")))
@interface STTHebrewLocalDateCompanion : STTBase
+ (instancetype)alloc __attribute__((unavailable));
+ (instancetype)allocWithZone:(struct _NSZone *)zone __attribute__((unavailable));
+ (instancetype)companion __attribute__((swift_name("init()")));
@property (class, readonly, getter=shared) STTHebrewLocalDateCompanion *shared __attribute__((swift_name("shared")));
- (int32_t)getNumDaysInHebrewMonthMonth:(STTHebrewMonth *)month year:(int64_t)year __attribute__((swift_name("getNumDaysInHebrewMonth(month:year:)")));
- (int32_t)getNumDaysInHebrewYearYear:(int64_t)year __attribute__((swift_name("getNumDaysInHebrewYear(year:)")));
- (STTHebrewLocalDate *)toHebrewDate:(STTKotlinx_datetimeLocalDate *)receiver __attribute__((swift_name("toHebrewDate(_:)")));
- (STTKotlinx_datetimeLocalDate *)withDayOfMonth:(STTKotlinx_datetimeLocalDate *)receiver dayOfMonth:(int32_t)dayOfMonth __attribute__((swift_name("withDayOfMonth(_:dayOfMonth:)")));
- (STTKotlinx_datetimeLocalDate *)withMonth:(STTKotlinx_datetimeLocalDate *)receiver month:(STTKotlinx_datetimeMonth *)month __attribute__((swift_name("withMonth(_:month:)")));

/**
 * Computes the [HebrewLocalDate] of a given Gregorian date.
 * @param this the gregorian date to convert to a [HebrewLocalDate]
 */
- (STTKotlinx_datetimeLocalDate *)withYear:(STTKotlinx_datetimeLocalDate *)receiver year:(int32_t)year __attribute__((swift_name("withYear(_:year:)")));

/**
 * the Jewish epoch using the RD (Rata Die/Fixed Date or Reingold Dershowitz) day used in Calendrical Calculations.
 * Day 1 is January 1, 0001 Gregorian
 */
@property (readonly) int32_t JEWISH_EPOCH __attribute__((swift_name("JEWISH_EPOCH")));
@end

__attribute__((swift_name("KotlinEnum")))
@interface STTKotlinEnum<E> : STTBase <STTKotlinComparable>
- (instancetype)initWithName:(NSString *)name ordinal:(int32_t)ordinal __attribute__((swift_name("init(name:ordinal:)"))) __attribute__((objc_designated_initializer));
@property (class, readonly, getter=companion) STTKotlinEnumCompanion *companion __attribute__((swift_name("companion")));
- (int32_t)compareToOther:(E)other __attribute__((swift_name("compareTo(other:)")));
- (BOOL)isEqual:(id _Nullable)other __attribute__((swift_name("isEqual(_:)")));
- (NSUInteger)hash __attribute__((swift_name("hash()")));
- (NSString *)description __attribute__((swift_name("description()")));
@property (readonly) NSString *name __attribute__((swift_name("name")));
@property (readonly) int32_t ordinal __attribute__((swift_name("ordinal")));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("HebrewMonth")))
@interface STTHebrewMonth : STTKotlinEnum<STTHebrewMonth *> <STTKotlinComparable>
+ (instancetype)alloc __attribute__((unavailable));
+ (instancetype)allocWithZone:(struct _NSZone *)zone __attribute__((unavailable));
- (instancetype)initWithName:(NSString *)name ordinal:(int32_t)ordinal __attribute__((swift_name("init(name:ordinal:)"))) __attribute__((objc_designated_initializer)) __attribute__((unavailable));
@property (class, readonly, getter=companion) STTHebrewMonthCompanion *companion __attribute__((swift_name("companion")));
@property (class, readonly) STTHebrewMonth *nissan __attribute__((swift_name("nissan")));
@property (class, readonly) STTHebrewMonth *iyar __attribute__((swift_name("iyar")));
@property (class, readonly) STTHebrewMonth *sivan __attribute__((swift_name("sivan")));
@property (class, readonly) STTHebrewMonth *tammuz __attribute__((swift_name("tammuz")));
@property (class, readonly) STTHebrewMonth *av __attribute__((swift_name("av")));
@property (class, readonly) STTHebrewMonth *elul __attribute__((swift_name("elul")));
@property (class, readonly) STTHebrewMonth *tishrei __attribute__((swift_name("tishrei")));
@property (class, readonly) STTHebrewMonth *cheshvan __attribute__((swift_name("cheshvan")));
@property (class, readonly) STTHebrewMonth *kislev __attribute__((swift_name("kislev")));
@property (class, readonly) STTHebrewMonth *teves __attribute__((swift_name("teves")));
@property (class, readonly) STTHebrewMonth *shevat __attribute__((swift_name("shevat")));
@property (class, readonly) STTHebrewMonth *adar __attribute__((swift_name("adar")));
@property (class, readonly) STTHebrewMonth *adarIi __attribute__((swift_name("adarIi")));
+ (STTKotlinArray<STTHebrewMonth *> *)values __attribute__((swift_name("values()")));
@property (class, readonly) NSArray<STTHebrewMonth *> *entries __attribute__((swift_name("entries")));

/**
 * Returns the next month in the [jewishYear] (with [TISHREI] being the first if [tishreiBased] is true,
 * otherwise [NISSAN]), or null if [this] is the last month of the year.
 * This method will not return [ADAR_II] if [jewishYear] is not a leap year.
 * @return next jewish month, or null if [this] is the last jewish month of [jewishYear]
 * */
- (STTHebrewMonth * _Nullable)getNextMonthInYearJewishYear:(int64_t)jewishYear tishreiBased:(BOOL)tishreiBased __attribute__((swift_name("getNextMonthInYear(jewishYear:tishreiBased:)")));

/**
 * Returns the number of days in this month for the given [jewishYear].
 * */
- (int32_t)getNumDaysInMonthForYearJewishYear:(int64_t)jewishYear __attribute__((swift_name("getNumDaysInMonthForYear(jewishYear:)")));

/**
 * Returns the previous month in the [jewishYear] (with [TISHREI] being the first if [tishreiBased] is true,
 * otherwise [NISSAN]), or null if [this] is the first month of the year.
 * This method will not return [ADAR_II] if [jewishYear] is not a leap year.
 * @return next jewish month, or null if [this] is the first jewish month of the year.
 * */
- (STTHebrewMonth * _Nullable)getPreviousMonthInYearTishreiBased:(BOOL)tishreiBased __attribute__((swift_name("getPreviousMonthInYear(tishreiBased:)")));
- (int32_t)getTishreiBasedValueInYearJewishYear:(int64_t)jewishYear __attribute__((swift_name("getTishreiBasedValueInYear(jewishYear:)")));
- (BOOL)isFirstMonthInYearTishreiBased:(BOOL)tishreiBased __attribute__((swift_name("isFirstMonthInYear(tishreiBased:)")));
- (BOOL)isLastMonthInYearJewishYear:(int64_t)jewishYear tishreiBased:(BOOL)tishreiBased __attribute__((swift_name("isLastMonthInYear(jewishYear:tishreiBased:)")));
- (STTHebrewMonthHebrewMonthRange *)rangeToOther:(STTHebrewMonth *)other __attribute__((swift_name("rangeTo(other:)")));
- (STTHebrewMonth *)toTishreiBasedMonthInYearJewishYear:(int32_t)jewishYear __attribute__((swift_name("toTishreiBasedMonthInYear(jewishYear:)")));
- (STTHebrewMonthHebrewMonthRange *)untilOther:(STTHebrewMonth *)other __attribute__((swift_name("until(other:)")));

/**
 * Returns the [HebrewMonth] which follows [this] month, with the first being [NISSAN] and last being [ADAR_II].
 * If [this] is the last month, this will wrap around and return the first month (which would actually be part of the next year).
 * **Note:** this does not account for leap years and the presence of [ADAR_II] - it blindly gets the next month.
 * In order to properly determine the next month accounting for leap years and without wrapping, use [getNextMonthInYear].
 * */
@property (readonly) STTHebrewMonth *nextMonth __attribute__((swift_name("nextMonth")));

/**
 * Returns the [HebrewMonth] which came before [this] month, with the first being [NISSAN] and last being [ADAR_II].
 * If [this] is the first month, this will wrap around and return the last month (which would actually be part of the previous year).
 * **Note:** this does not account for leap years and the presence of [ADAR_II] - it blindly gets the next month.
 * In order to properly determine the previous month accounting for leap years and without wrapping, use [getPreviousMonthInYear].
 * */
@property (readonly) STTHebrewMonth *previousMonth __attribute__((swift_name("previousMonth")));
@property (readonly) int32_t value __attribute__((swift_name("value")));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("HebrewMonth.Companion")))
@interface STTHebrewMonthCompanion : STTBase
+ (instancetype)alloc __attribute__((unavailable));
+ (instancetype)allocWithZone:(struct _NSZone *)zone __attribute__((unavailable));
+ (instancetype)companion __attribute__((swift_name("init()")));
@property (class, readonly, getter=shared) STTHebrewMonthCompanion *shared __attribute__((swift_name("shared")));

/**
 * Returns the HebrewMonth for the given value, with 1 being [NISSAN] and 13 being [ADAR_II].
 * @param value from 1 to 13. Values outside this range will be wrapped.
 * */
- (STTHebrewMonth *)getMonthForValueValue:(int32_t)value __attribute__((swift_name("getMonthForValue(value:)")));

/**
 * Interpolates this [month]
 * */
- (STTHebrewMonth *)getTishreiBasedMonthMonth:(STTHebrewMonth *)month jewishYear:(int32_t)jewishYear __attribute__((swift_name("getTishreiBasedMonth(month:jewishYear:)")));
- (STTHebrewMonth *)getTishreiBasedMonthMonth:(STTHebrewMonth *)month jewishYear_:(int64_t)jewishYear __attribute__((swift_name("getTishreiBasedMonth(month:jewishYear_:)")));

/**
 * Converts the [NISSAN] based constants used by this class to numeric month starting from
 * [TISHREI]. This is required for Molad claculations.
 *
 * @param jewishYear
 * The Jewish year
 * @param this@toTishreiBasedMonthValue
 * The Jewish Month
 * @return the Jewish month of the year starting with Tishrei
 */
- (int32_t)getTishreiBasedValueNissanBasedValue:(int32_t)nissanBasedValue jewishYear:(int32_t)jewishYear __attribute__((swift_name("getTishreiBasedValue(nissanBasedValue:jewishYear:)")));
- (int32_t)getTishreiBasedValueNissanBasedValue:(int32_t)nissanBasedValue jewishYear_:(int64_t)jewishYear __attribute__((swift_name("getTishreiBasedValue(nissanBasedValue:jewishYear_:)")));
@end

__attribute__((swift_name("KotlinClosedRange")))
@protocol STTKotlinClosedRange
@required
- (BOOL)containsValue:(id)value __attribute__((swift_name("contains(value:)")));
- (BOOL)isEmpty __attribute__((swift_name("isEmpty()")));
@property (readonly) id endInclusive __attribute__((swift_name("endInclusive")));
@property (readonly) id start __attribute__((swift_name("start")));
@end

__attribute__((swift_name("KotlinIterable")))
@protocol STTKotlinIterable
@required
- (id<STTKotlinIterator>)iterator __attribute__((swift_name("iterator()")));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("HebrewMonth.HebrewMonthRange")))
@interface STTHebrewMonthHebrewMonthRange : STTBase <STTKotlinClosedRange, STTKotlinIterable>
- (instancetype)initWithStart:(STTHebrewMonth *)start endInclusive:(STTHebrewMonth *)endInclusive __attribute__((swift_name("init(start:endInclusive:)"))) __attribute__((objc_designated_initializer));
- (id<STTKotlinIterator>)iterator __attribute__((swift_name("iterator()")));
@property (readonly) STTHebrewMonth *endInclusive __attribute__((swift_name("endInclusive")));
@property (readonly) STTHebrewMonth *start __attribute__((swift_name("start")));
@end


/**
 * The JewishDate is the base calendar class, that supports maintenance of a [LocalDateTime]
 * instance along with the corresponding Jewish date. This class can use the standard Java (TODO change for kotlin) Date and Calendar
 * classes for setting and maintaining the dates, but it does not subclass these classes or use them internally
 * in any calculations. This class also does not have a concept of a time (which the Date class does). Please
 * note that the calendar does not currently support dates prior to 1/1/1 Gregorian. Also keep in mind that the
 * Gregorian calendar started on October 15, 1582, so any calculations prior to that are suspect (at least from
 * a Gregorian perspective). While 1/1/1 Gregorian and forward are technically supported, any calculations prior to [Hillel II's (Hakatan's](http://en.wikipedia.org/wiki/Hillel_II)) calendar (4119 in the Jewish Calendar / 359
 * CE Julian as recorded by [Rav Hai Gaon](http://en.wikipedia.org/wiki/Hai_Gaon)) would be just an
 * approximation.
 *
 * This open source Java code was written by [Avrom Finkelstien](http://www.facebook.com/avromf) from his C++
 * code. It was refactored to fit the KosherJava Zmanim API with simplification of the code, enhancements and some bug
 * fixing.
 *
 * Some of Avrom's original C++ code was translated from
 * [C/C++ code](https://web.archive.org/web/20120124134148/http://emr.cs.uiuc.edu/~reingold/calendar.C) in
 * [Calendrical Calculations](http://www.calendarists.com) by Nachum Dershowitz and Edward M.
 * Reingold, Software-- Practice &amp; Experience, vol. 20, no. 9 (September, 1990), pp. 899- 928. Any method with the mark
 * "ND+ER" indicates that the method was taken from this source with minor modifications.
 *
 * If you are looking for a class that implements a Jewish calendar version of the Calendar class, one is available from
 * the [ICU (International Components for Unicode)](http://site.icu-project.org/) project, formerly part of
 * IBM's DeveloperWorks.
 *
 * @see JewishCalendar
 *
 * @see HebrewDateFormatter
 *
 * @see Date
 *
 * @see java.util.Calendar
 *
 * @author Avrom Finkelstien 2002
 * @author Eliyahu Hershfeld 2011 - 2021
 */
__attribute__((swift_name("JewishDate")))
@interface STTJewishDate : STTBase <STTKotlinComparable>

/**
 * Default constructor will set a default date to the current system date.
 */
- (instancetype)init __attribute__((swift_name("init()"))) __attribute__((objc_designated_initializer));

/**
 * Default constructor will set a default date to the current system date.
 */
+ (instancetype)new __attribute__((availability(swift, unavailable, message="use object initializers instead")));

/**
 * Constructor that creates a JewishDate based on a molad passed in. The molad would be the number of chalakim/parts
 * starting at the beginning of Sunday prior to the molad Tohu BeHaRaD (Be = Monday, Ha= 5 hours and Rad =204
 * chalakim/parts) - prior to the start of the Jewish calendar. BeHaRaD is 23:11:20 on Sunday night(5 hours 204/1080
 * chalakim after sunset on Sunday evening).
 *
 * @param molad the number of chalakim since the beginning of Sunday prior to BaHaRaD
 */
- (instancetype)initWithMolad:(int64_t)molad __attribute__((swift_name("init(molad:)"))) __attribute__((objc_designated_initializer));
- (instancetype)initWithLocalDate:(STTKotlinx_datetimeLocalDate *)localDate __attribute__((swift_name("init(localDate:)"))) __attribute__((objc_designated_initializer));
- (instancetype)initWithHebrewLocalDate:(STTHebrewLocalDate *)hebrewLocalDate __attribute__((swift_name("init(hebrewLocalDate:)"))) __attribute__((objc_designated_initializer));
- (instancetype)initWithHebrewYear:(int32_t)hebrewYear hebrewMonth:(int32_t)hebrewMonth hebrewDayOfMonth:(int32_t)hebrewDayOfMonth __attribute__((swift_name("init(hebrewYear:hebrewMonth:hebrewDayOfMonth:)"))) __attribute__((objc_designated_initializer));

/**
 * Creates a Jewish date based on a Jewish year, month and day of month.
 *
 * @param hebrewYear
 * the Jewish year
 * @param jewishMonth
 * the Jewish month. The method expects a 1 for Nissan ... 12 for Adar and 13 for Adar II. Use the
 * constants [NISSAN] ... [ADAR] (or [ADAR_II] for a leap year Adar II) to avoid any
 * confusion.
 * @param hebrewDayOfMonth
 * the Jewish day of month. If 30 is passed in for a month with only 29 days (for example [IYAR],
 * or [KISLEV] in a year that [isKislevShort]), the 29th (last valid date of the month)
 * will be set
 * @throws IllegalArgumentException
 * if the day of month is < 1 or > 30, or a year of < 0 is passed in.
 */
- (instancetype)initWithHebrewYear:(int32_t)hebrewYear hebrewMonth:(STTHebrewMonth *)hebrewMonth hebrewDayOfMonth_:(int32_t)hebrewDayOfMonth __attribute__((swift_name("init(hebrewYear:hebrewMonth:hebrewDayOfMonth_:)"))) __attribute__((objc_designated_initializer));
- (instancetype)initWithHebrewYear:(int64_t)hebrewYear hebrewMonth:(STTHebrewMonth *)hebrewMonth hebrewDayOfMonth__:(int32_t)hebrewDayOfMonth __attribute__((swift_name("init(hebrewYear:hebrewMonth:hebrewDayOfMonth__:)"))) __attribute__((objc_designated_initializer));
@property (class, readonly, getter=companion) STTJewishDateCompanion *companion __attribute__((swift_name("companion")));
- (int32_t)lastDayOfGregorianMonth:(int32_t)receiver __attribute__((swift_name("lastDayOfGregorianMonth(_:)")));

/**
 * Rolls the date back by 1 day. It modifies both the Gregorian and Jewish dates accordingly. The API does not
 * currently offer the ability to forward more than one day at a time, or to forward by month or year. If such
 * manipulation is required use the [java.util.Calendar] class [java.util.Calendar.add] or
 * [java.util.Calendar.roll] methods in the following manner.
 *
 * <pre>
 * `
 * Calendar cal = jewishDate.getTime(); // get a java.util.Calendar representation of the JewishDate
 * cal.add(Calendar.MONTH, -3); // subtract 3 Gregorian months
 * jewishDate.setDate(cal); // set the updated calendar back to this class
` *
</pre> *
 *
 * @see back
 * @see java.util.Calendar.add
 * @see java.util.Calendar.roll
 */
- (STTJewishDate *)back __attribute__((swift_name("back()")));

/**
 * Compares two dates as per the compareTo() method in the Comparable interface. Returns a value less than 0 if this
 * date is "less than" (before) the date, greater than 0 if this date is "greater than" (after) the date, or 0 if
 * they are equal.
 */
- (int32_t)compareToOther:(STTJewishDate *)other __attribute__((swift_name("compareTo(other:)")));

/**
 * A method that creates a [deep copy](http://en.wikipedia.org/wiki/Object_copy#Deep_copy) of the object.
 *
 * @see Object.clone
 */
- (STTJewishDate *)doCopyHebrewYear:(int64_t)hebrewYear month:(STTHebrewMonth *)month hebrewDayOfMonth:(int32_t)hebrewDayOfMonth __attribute__((swift_name("doCopy(hebrewYear:month:hebrewDayOfMonth:)")));

/**
 * Indicates whether some other object is "equal to" this one.
 * @see Object.equals
 */
- (BOOL)isEqual:(id _Nullable)other __attribute__((swift_name("isEqual(_:)")));

/**
 * Rolls the date, month or year forward by the amount passed in. It modifies both the Gregorian and Jewish dates accordingly.
 * If manipulation beyond the fields supported here is required, use the [Calendar] class [Calendar.add]
 * or [Calendar.roll] methods in the following manner.
 *
 * <pre>
 * `
 * Calendar cal = jewishDate.getTime(); // get a java.util.Calendar representation of the JewishDate
 * cal.add(Calendar.MONTH, 3); // add 3 Gregorian months
 * jewishDate.setDate(cal); // set the updated calendar back to this class
` *
</pre> *
 *
 * @param field the calendar field to be forwarded. The must be [Calendar.DATE], [Calendar.MONTH] or [Calendar.YEAR]
 * @param amount the positive amount to move forward
 * @throws IllegalArgumentException if the field is anything besides [Calendar.DATE], [Calendar.MONTH] or [Calendar.YEAR]
 * or if the amount is less than 1
 *
 * @see back
 * @see Calendar.add
 * @see Calendar.roll
 */
- (STTJewishDate *)forwardField:(STTKotlinx_datetimeDateTimeUnit *)field amount:(int32_t)amount __attribute__((swift_name("forward(field:amount:)")));
- (STTKotlinx_datetimeLocalDate *)getGregorianDate __attribute__((swift_name("getGregorianDate()")));

/**
 * Overrides [Object.hashCode].
 * @see Object.hashCode
 */
- (NSUInteger)hash __attribute__((swift_name("hash()")));

/**
 * Resets this date to the current system date.
 */
- (STTJewishDate *)resetDate __attribute__((swift_name("resetDate()")));

/**
 * Sets the date based on a [LocalDateTime] object. Modifies the Jewish date as well.
 *
 * @param dateTime
 * the `LocalDateTime` to set the LocalDate to
 */
- (STTJewishDate *)setDateDate:(STTKotlinx_datetimeLocalDate *)date __attribute__((swift_name("setDate(date:)")));

/**
 * Sets the Gregorian Date, and updates the Jewish date accordingly. Like the Java Calendar A value of 0 is expected
 * for January.
 *
 * @param year
 * the Gregorian year
 * @param month
 * the Gregorian month. Between 1 and 12.
 * @param dayOfMonth
 * the Gregorian day of month - 1 for January, 12 for December. If this is > the number of days in the month/year, the last valid date of
 * the month will be set
 * @throws IllegalArgumentException
 * if a year of < 1, a month < 0 or > 11 or a day of month < 1 is passed in.
 *
 * **Note:** This setter will correct the [dayOfMonth] if passed in an invalid number given the [year] and [month]
 * (e.g. February 29 in a leap year)
 */
- (STTJewishDate *)setGregorianDateYear:(int32_t)year month:(int32_t)month dayOfMonth:(int32_t)dayOfMonth __attribute__((swift_name("setGregorianDate(year:month:dayOfMonth:)")));

/**
 * Sets the Jewish Date and updates the Gregorian date accordingly.
 *
 * @param year
 * the Jewish year. The year can't be negative
 * @param month
 * the Jewish month starting with Nisan. A value of 1 is expected for Nissan ... 12 for Adar and 13 for
 * Adar II. Use the constants [NISSAN] ... [ADAR] (or [ADAR_II] for a leap year Adar
 * II) to avoid any confusion.
 * @param dayOfMonth
 * the Jewish day of month. valid values are 1-30. If the day of month is set to 30 for a month that only
 * has 29 days, the day will be set as 29.
 * @throws IllegalArgumentException
 * if a A Jewish date earlier than 18 Teves, 3761 (1/1/1 Gregorian), a month < 1 or > 12 (or 13 on a
 * leap year) or the day of month is < 1 or > 30 is passed in
 */
- (STTJewishDate *)setJewishDateHebrewLocalDate:(STTHebrewLocalDate *)hebrewLocalDate __attribute__((swift_name("setJewishDate(hebrewLocalDate:)")));
- (STTJewishDate *)setJewishDateYear:(int64_t)year month:(STTHebrewMonth *)month dayOfMonth:(int32_t)dayOfMonth __attribute__((swift_name("setJewishDate(year:month:dayOfMonth:)")));

/**
 * Sets the Jewish Date and updates the Gregorian date accordingly.
 *
 * @param year
 * the Jewish year. The year can't be negative
 * @param month
 * the Jewish month starting with Nisan. A value of 1 is expected for Nissan ... 12 for Adar and 13 for
 * Adar II. Use the constants [NISSAN] ... [ADAR] (or [ADAR_II] for a leap year Adar
 * II) to avoid any confusion.
 * @param dayOfMonth
 * the Jewish day of month. valid values are 1-30. If the day of month is set to 30 for a month that only
 * has 29 days, the day will be set as 29.
 *
 * @param hours
 * the hour of the day. Used for Molad calculations
 * @param minutes
 * the minutes. Used for Molad calculations
 * @param chalakim
 * the chalakim/parts. Used for Molad calculations. The chalakim should not exceed 17. Minutes should be
 * used for larger numbers.
 *
 * @throws IllegalArgumentException
 * if a A Jewish date earlier than 18 Teves, 3761 (1/1/1 Gregorian), a month < 1 or > 12 (or 13 on a
 * leap year), the day of month is < 1 or > 30, an hour < 0 or > 23, a minute < 0 > 59 or chalakim < 0 >
 * 17. For larger a larger number of chalakim such as 793 (TaShTzaG) break the chalakim into minutes (18
 * chalakim per minutes, so it would be 44 minutes and 1 chelek in the case of 793 (TaShTzaG).
 */
- (STTJewishDate *)setJewishDateYear:(int64_t)year month:(STTHebrewMonth *)month dayOfMonth:(int32_t)dayOfMonth hours:(int32_t)hours minutes:(int32_t)minutes chalakim:(int32_t)chalakim __attribute__((swift_name("setJewishDate(year:month:dayOfMonth:hours:minutes:chalakim:)")));

/**
 * sets the Jewish month.
 *
 * @param month
 * the Jewish month from 1 to 12 (or 13 years in a leap year). The month count starts with 1 for Nisan
 * and goes to 13 for Adar II
 * @throws IllegalArgumentException
 * if a month < 1 or > 12 (or 13 on a leap year) is passed in
 */
- (STTJewishDate *)setJewishMonthMonth:(STTHebrewMonth *)month __attribute__((swift_name("setJewishMonth(month:)")));

/**
 * Returns a string containing the Jewish date in the form, "day Month, year" e.g. "21 Shevat, 5729". For more
 * complex formatting, use the formatter classes.
 *
 * @return the Jewish date in the form "day Month, year" e.g. "21 Shevat, 5729"
 * @see HebrewDateFormatter.format
 */
- (NSString *)description __attribute__((swift_name("description()")));

/**
 * Returns the number of chalakim (parts - 1080 to the hour) from the original hypothetical Molad Tohu to the Jewish
 * year and month that this Object is set to.
 *
 * @return the number of chalakim (parts - 1080 to the hour) from the original hypothetical Molad Tohu
 */
@property (readonly) int64_t chalakimSinceMoladTohu __attribute__((swift_name("chalakimSinceMoladTohu")));

/**
 * Returns the Cheshvan and Kislev kviah (whether a Jewish year is short, regular or long). It will return
 * [SHELAIMIM] if both cheshvan and kislev are 30 days, [KESIDRAN] if Cheshvan is 29 days and Kislev
 * is 30 days and [CHASERIM] if both are 29 days.
 *
 * @return [SHELAIMIM] if both cheshvan and kislev are 30 days, [KESIDRAN] if Cheshvan is 29 days and
 * Kislev is 30 days and [CHASERIM] if both are 29 days.
 * @see isCheshvanLong
 * @see isKislevShort
 */
@property (readonly) int32_t cheshvanKislevKviah __attribute__((swift_name("cheshvanKislevKviah")));

/**
 * Returns the number of days of the Jewish month that the calendar is currently set to.
 *
 * @return the number of days for the Jewish month that the calendar is currently set to.
 */
@property (readonly) int32_t daysInJewishMonth __attribute__((swift_name("daysInJewishMonth")));

/**
 * Returns the number of days for the current year that the calendar is set to.
 *
 * @return the number of days for the Object's current Jewish year.
 * @see isCheshvanLong
 * @see isKislevShort
 * @see isJewishLeapYear
 */
@property (readonly) int32_t daysInJewishYear __attribute__((swift_name("daysInJewishYear")));

/**
 * returns the number of days from Rosh Hashana of the date passed in, to the full date passed in.
 *
 * @return the number of days
 */
@property (readonly) int32_t daysSinceStartOfJewishYear __attribute__((swift_name("daysSinceStartOfJewishYear")));
@property int32_t gregorianDayOfMonth __attribute__((swift_name("gregorianDayOfMonth")));
@property STTKotlinx_datetimeLocalDate *gregorianLocalDate __attribute__((swift_name("gregorianLocalDate")));
@property int32_t gregorianMonth __attribute__((swift_name("gregorianMonth")));
@property int32_t gregorianYear __attribute__((swift_name("gregorianYear")));

/**
 * Returns this object's date as a [LocalDate] object.
 *
 * @return The [LocalDate]
 */
@property STTHebrewLocalDate *hebrewLocalDate __attribute__((swift_name("hebrewLocalDate")));

/**
 * Returns if Cheshvan is long (30 days VS 29 days) for the current year that the calendar is set to. The method
 * name isLong is done since in a Kesidran (ordered) year Cheshvan is short.
 *
 * @return true if Cheshvan is long for the current year that the calendar is set to
 * @see isCheshvanLong
 */
@property (readonly) BOOL isCheshvanLong __attribute__((swift_name("isCheshvanLong")));

/**
 * Returns if the year the calendar is set to is a Jewish leap year. Years 3, 6, 8, 11, 14, 17 and 19 in the 19 year
 * cycle are leap years.
 *
 * @return true if it is a leap year
 * @see isJewishLeapYear
 */
@property (readonly) BOOL isJewishLeapYear __attribute__((swift_name("isJewishLeapYear")));

/**
 * Returns if the Kislev is short for the year that this class is set to. The method name isShort is done since in a
 * Kesidran (ordered) year Kislev is long.
 *
 * @return true if Kislev is short for the year that this class is set to
 */
@property (readonly) BOOL isKislevShort __attribute__((swift_name("isKislevShort")));

/**
 * The Jewish day of month.
 */
@property int32_t jewishDayOfMonth __attribute__((swift_name("jewishDayOfMonth")));
@property STTHebrewMonth *jewishMonth __attribute__((swift_name("jewishMonth")));
@property int64_t jewishYear __attribute__((swift_name("jewishYear")));

/**
 * Returns the molad for a given year and month. Returns a JewishDate [Object] set to the date of the molad
 * with the [hours][moladHours], [minutes][moladMinutes] and [chalakim][moladChalakim] set.
 * In the current implementation, it sets the molad time based on a midnight date rollover. This
 * means that Rosh Chodesh Adar II, 5771 with a molad of 7 chalakim past midnight on Shabbos 29 Adar I / March 5,
 * 2011 12:00 AM and 7 chalakim, will have the following values: hours: 0, minutes: 0, Chalakim: 7.
 *
 * @return a JewishDate [Object] set to the date of the molad with the [hours][moladHours],
 * [minutes][moladMinutes] and [chalakim][moladChalakim] set.
 */
@property (readonly) STTJewishDate *molad __attribute__((swift_name("molad")));

/**
 * the internal count of *molad* *chalakim* / parts. Only an object populated with [molad],
 * [setJewishDate] or [moladChalakim] will have these fields
 * populated. A regular JewishDate object will have this field set to 0.
 *
 * When setting the molad chalakim, the expectation is that the traditional minute-less chalakim will be broken out to
 * [minutes][moladMinutes] and chalakim, so 793 (TaShTZaG) parts would have the minutes set to 44 and
 * chalakim to 1.
 * */
@property int32_t moladChalakim __attribute__((swift_name("moladChalakim")));

/**
 * The molad hours. Only a JewishDate object populated with [molad],
 * [setJewishDate] or [moladHours] will have this field
 * populated. A regular JewishDate object will have this field set to 0.
 *
 * @see molad
 * @see setJewishDate
 */
@property int32_t moladHours __attribute__((swift_name("moladHours")));

/**
 * The molad minutes. Only an object populated with [molad],
 * [setJewishDate] or [moladMinutes] will have these fields
 * populated. A regular JewishDate object will have this field set to 0.
 *
 * When setting the molad minutes, the expectation is that the traditional minute-less chalakim will be broken out to
 * minutes and [chalakim/parts][moladChalakim] , so 793 (TaShTZaG) parts would have the minutes set to
 * 44 and chalakim to 1.
 * @see moladMinutes
 * @see moladChalakim
 * @see setJewishDate
 */
@property int32_t moladMinutes __attribute__((swift_name("moladMinutes")));
@end


/**
 * The JewishCalendar extends the JewishDate class and adds calendar methods.
 *
 * This open source Java code was originally ported by [Avrom Finkelstien](http://www.facebook.com/avromf)
 * from his C++ code. It was refactored to fit the KosherJava Zmanim API with simplification of the code, enhancements
 * and some bug fixing. The class allows setting whether the holiday and *parsha* scheme follows the Israel scheme
 * or outside Israel scheme. The default is the outside Israel scheme.
 * The parsha code was ported by Y. Paritcher from his [libzmanim](https://github.com/yparitcher/libzmanim) code.
 *
 * @todo Some do not belong in this class, but here is a partial list of what should still be implemented in some form:
 *
 *  1. Mishna yomis etc
 *
 *
 * @see Date
 *
 * @see java.util.Calendar
 *
 * @author Y. Paritcher 2019 - 2022
 * @author Avrom Finkelstien 2002
 * @author Eliyahu Hershfeld 2011 - 2023
 */
__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("JewishCalendar")))
@interface STTJewishCalendar : STTJewishDate

/**
 * Default constructor will set a default date to the current system date.
 */
- (instancetype)init __attribute__((swift_name("init()"))) __attribute__((objc_designated_initializer));

/**
 * Default constructor will set a default date to the current system date.
 */
+ (instancetype)new __attribute__((availability(swift, unavailable, message="use object initializers instead")));

/**
 * A constructor that initializes the date to the [date] parameter.
 *
 * @param date
 * the `LocalDate` to set the [gregorianLocalDate] to
 */
- (instancetype)initWithDate:(STTKotlinx_datetimeLocalDate *)date __attribute__((swift_name("init(date:)"))) __attribute__((objc_designated_initializer));

/**
 * A constructor that initializes the hebrew date to the [date] parameter.
 *
 * @param date
 * the `LocalDate` to set the [gregorianLocalDate] to
 */
- (instancetype)initWithDate_:(STTHebrewLocalDate *)date __attribute__((swift_name("init(date_:)"))) __attribute__((objc_designated_initializer));

/**
 * A constructor that initializes the date to the [Date] parameter.
 *
 * @param date
 * the `Date` to set the calendar to
 */
- (instancetype)initWithDate:(STTKotlinx_datetimeInstant *)date tz:(STTKotlinx_datetimeTimeZone *)tz __attribute__((swift_name("init(date:tz:)"))) __attribute__((objc_designated_initializer));

/**
 * A constructor that initializes the date to the [date] parameter.
 *
 * @param date
 * the `LocalDate` to set the [gregorianLocalDate] to
 * @param isInIsrael whether this class should calculate religious events with the rules of someone in israel
 */
- (instancetype)initWithDate:(STTKotlinx_datetimeLocalDate *)date isInIsrael:(BOOL)isInIsrael __attribute__((swift_name("init(date:isInIsrael:)"))) __attribute__((objc_designated_initializer));

/**
 * A constructor that initializes the hebrew date to the [date] parameter.
 *
 * @param date
 * the `LocalDate` to set the [gregorianLocalDate] to
 * @param isInIsrael whether this class should calculate religious events with the rules of someone in israel
 */
- (instancetype)initWithDate:(STTHebrewLocalDate *)date isInIsrael_:(BOOL)isInIsrael __attribute__((swift_name("init(date:isInIsrael_:)"))) __attribute__((objc_designated_initializer));

/**
 * Creates a Jewish date based on a Jewish year, month and day of month.
 *
 * @param jewishYear
 * the Jewish year
 * @param jewishMonth
 * the Jewish month. The method expects a 1 for Nissan ... 12 for Adar and 13 for Adar II. Use the
 * constants [.NISSAN] ... [.ADAR] (or [.ADAR_II] for a leap year Adar II) to avoid any
 * confusion.
 * @param jewishDayOfMonth
 * the Jewish day of month. If 30 is passed in for a month with only 29 days (for example [.IYAR],
 * or [.KISLEV] in a year that [.isKislevShort]), the 29th (last valid date of the month)
 * will be set
 * @throws IllegalArgumentException
 * if the day of month is < 1 or > 30, or a year of < 0 is passed in.
 */
- (instancetype)initWithJewishYear:(int32_t)jewishYear jewishMonth:(int32_t)jewishMonth jewishDayOfMonth:(int32_t)jewishDayOfMonth __attribute__((swift_name("init(jewishYear:jewishMonth:jewishDayOfMonth:)"))) __attribute__((objc_designated_initializer));
- (instancetype)initWithHebrewYear:(int32_t)hebrewYear hebrewMonth:(STTHebrewMonth *)hebrewMonth hebrewDayOfMonth:(int32_t)hebrewDayOfMonth __attribute__((swift_name("init(hebrewYear:hebrewMonth:hebrewDayOfMonth:)"))) __attribute__((objc_designated_initializer));
- (instancetype)initWithJewishYear:(int64_t)jewishYear jewishMonth:(int32_t)jewishMonth jewishDayOfMonth_:(int32_t)jewishDayOfMonth __attribute__((swift_name("init(jewishYear:jewishMonth:jewishDayOfMonth_:)"))) __attribute__((objc_designated_initializer));
- (instancetype)initWithHebrewYear:(int64_t)hebrewYear hebrewMonth:(STTHebrewMonth *)hebrewMonth hebrewDayOfMonth_:(int32_t)hebrewDayOfMonth __attribute__((swift_name("init(hebrewYear:hebrewMonth:hebrewDayOfMonth_:)"))) __attribute__((objc_designated_initializer));

/**
 * A constructor that initializes the date to the [date] parameter.
 *
 * @param date
 * the `LocalDate` to set the [gregorianLocalDate] to
 * @param isInIsrael whether this class should calculate religious events with the rules of someone in israel
 */
- (instancetype)initWithDate:(STTKotlinx_datetimeLocalDate *)date isInIsrael:(BOOL)isInIsrael shouldUseModernHolidays:(BOOL)shouldUseModernHolidays __attribute__((swift_name("init(date:isInIsrael:shouldUseModernHolidays:)"))) __attribute__((objc_designated_initializer));

/**
 * A constructor that initializes the heberew date to the [date] parameter.
 *
 * @param date
 * the `LocalDate` to set the [gregorianLocalDate] to
 * @param isInIsrael whether this class should calculate religious events with the rules of someone in israel
 */
- (instancetype)initWithDate:(STTHebrewLocalDate *)date isInIsrael:(BOOL)isInIsrael shouldUseModernHolidays_:(BOOL)shouldUseModernHolidays __attribute__((swift_name("init(date:isInIsrael:shouldUseModernHolidays_:)"))) __attribute__((objc_designated_initializer));

/**
 * Creates a Jewish date based on a Jewish date and whether in Israel
 *
 * @param jewishYear
 * the Jewish year
 * @param jewishMonth
 * the Jewish month. The method expects a 1 for *Nissan* ... 12 for *Adar* and 13 for
 * *Adar II*. Use the constants [.NISSAN] ... [.ADAR] (or [.ADAR_II] for a
 * leap year Adar II) to avoid any confusion.
 * @param jewishDayOfMonth
 * the Jewish day of month. If 30 is passed in for a month with only 29 days (for example [.IYAR],
 * or [.KISLEV] in a year that [.isKislevShort]), the 29th (last valid date of the month)
 * will be set.
 * @param inIsrael
 * whether in Israel. This affects *Yom Tov* calculations
 */
- (instancetype)initWithJewishYear:(int32_t)jewishYear jewishMonth:(int32_t)jewishMonth jewishDayOfMonth:(int32_t)jewishDayOfMonth inIsrael:(BOOL)inIsrael __attribute__((swift_name("init(jewishYear:jewishMonth:jewishDayOfMonth:inIsrael:)"))) __attribute__((objc_designated_initializer));

/**
 * Creates a Jewish date based on a Jewish date and whether in Israel
 *
 * @param jewishYear
 * the Jewish year
 * @param jewishMonth
 * the Jewish month. The method expects a 1 for *Nissan* ... 12 for *Adar* and 13 for
 * *Adar II*. Use the constants [.NISSAN] ... [.ADAR] (or [.ADAR_II] for a
 * leap year Adar II) to avoid any confusion.
 * @param jewishDayOfMonth
 * the Jewish day of month. If 30 is passed in for a month with only 29 days (for example [.IYAR],
 * or [.KISLEV] in a year that [.isKislevShort]), the 29th (last valid date of the month)
 * will be set.
 * @param inIsrael
 * whether in Israel. This affects *Yom Tov* calculations
 */
- (instancetype)initWithJewishYear:(int32_t)jewishYear jewishMonth:(STTHebrewMonth *)jewishMonth jewishDayOfMonth:(int32_t)jewishDayOfMonth inIsrael_:(BOOL)inIsrael __attribute__((swift_name("init(jewishYear:jewishMonth:jewishDayOfMonth:inIsrael_:)"))) __attribute__((objc_designated_initializer));
- (instancetype)initWithJewishYear:(int64_t)jewishYear jewishMonth:(int32_t)jewishMonth jewishDayOfMonth:(int32_t)jewishDayOfMonth inIsrael__:(BOOL)inIsrael __attribute__((swift_name("init(jewishYear:jewishMonth:jewishDayOfMonth:inIsrael__:)"))) __attribute__((objc_designated_initializer));
- (instancetype)initWithJewishYear:(int64_t)jewishYear jewishMonth:(STTHebrewMonth *)jewishMonth jewishDayOfMonth:(int32_t)jewishDayOfMonth inIsrael___:(BOOL)inIsrael __attribute__((swift_name("init(jewishYear:jewishMonth:jewishDayOfMonth:inIsrael___:)"))) __attribute__((objc_designated_initializer));

/**
 * Constructor that creates a JewishDate based on a molad passed in. The molad would be the number of chalakim/parts
 * starting at the beginning of Sunday prior to the molad Tohu BeHaRaD (Be = Monday, Ha= 5 hours and Rad =204
 * chalakim/parts) - prior to the start of the Jewish calendar. BeHaRaD is 23:11:20 on Sunday night(5 hours 204/1080
 * chalakim after sunset on Sunday evening).
 *
 * @param molad the number of chalakim since the beginning of Sunday prior to BaHaRaD
 */
- (instancetype)initWithMolad:(int64_t)molad __attribute__((swift_name("init(molad:)"))) __attribute__((objc_designated_initializer)) __attribute__((unavailable));
- (instancetype)initWithLocalDate:(STTKotlinx_datetimeLocalDate *)localDate __attribute__((swift_name("init(localDate:)"))) __attribute__((objc_designated_initializer)) __attribute__((unavailable));
- (instancetype)initWithHebrewLocalDate:(STTHebrewLocalDate *)hebrewLocalDate __attribute__((swift_name("init(hebrewLocalDate:)"))) __attribute__((objc_designated_initializer)) __attribute__((unavailable));
- (instancetype)initWithHebrewYear:(int64_t)hebrewYear hebrewMonth:(STTHebrewMonth *)hebrewMonth hebrewDayOfMonth__:(int32_t)hebrewDayOfMonth __attribute__((swift_name("init(hebrewYear:hebrewMonth:hebrewDayOfMonth__:)"))) __attribute__((objc_designated_initializer)) __attribute__((unavailable));
@property (class, readonly, getter=companion) STTJewishCalendarCompanion *companion __attribute__((swift_name("companion")));
- (STTJewishCalendar *)doCopyJewishYear:(int64_t)jewishYear jewishMonth:(int32_t)jewishMonth jewishDayOfMonth:(int32_t)jewishDayOfMonth inIsrael:(BOOL)inIsrael __attribute__((swift_name("doCopy(jewishYear:jewishMonth:jewishDayOfMonth:inIsrael:)")));
- (STTJewishCalendar *)doCopyJewishYear:(int64_t)jewishYear jewishMonth:(STTHebrewMonth *)jewishMonth jewishDayOfMonth:(int32_t)jewishDayOfMonth inIsrael_:(BOOL)inIsrael __attribute__((swift_name("doCopy(jewishYear:jewishMonth:jewishDayOfMonth:inIsrael_:)")));

/**
 * Indicates whether some other object is "equal to" this one.
 * @see Object.equals
 */
- (BOOL)isEqual:(id _Nullable)other __attribute__((swift_name("isEqual(_:)")));

/**
 * Overrides [Object.hashCode].
 * @see Object.hashCode
 */
- (NSUInteger)hash __attribute__((swift_name("hash()")));

/**
 * Returns the *Daf Yomi (Bavli)* for the date that the LocalDate is set to. See the
 * [HebrewDateFormatter.formatDafYomiBavli] for the ability to format the *daf* in
 * Hebrew or transliterated *masechta* names.
 *
 * @return the daf as a [Daf]
 */
@property (readonly) STTDaf * _Nullable dafYomiBavli __attribute__((swift_name("dafYomiBavli")));

/**
 * Returns the *Daf Yomi (Yerushalmi)* for the date that the LocalDate is set to. See the
 * [HebrewDateFormatter.formatDafYomiYerushalmi] for the ability to format the *daf*
 * in Hebrew or transliterated *masechta* names.
 *
 * @return the daf as a [Daf] or null if the date is on Tisha B'Av or Yom Kippur.
 */
@property (readonly) STTDaf * _Nullable dafYomiYerushalmi __attribute__((swift_name("dafYomiYerushalmi")));

/**
 * Returns the day of *Chanukah* or -1 if it is not *Chanukah*.
 *
 * @return the day of *Chanukah* or -1 if it is not *Chanukah*.
 * @see isChanukah
 */
@property (readonly) int32_t dayOfChanukah __attribute__((swift_name("dayOfChanukah")));

/**
 * Returns the int value of the *Omer* day or -1 if the day is not in the *Omer*.
 *
 * @return The *Omer* count as an int or -1 if it is not a day of the *Omer*.
 */
@property (readonly) int32_t dayOfOmer __attribute__((swift_name("dayOfOmer")));

/**
 * Returns true if the day has candle lighting. This will return true on *Erev Shabbos*, *Erev Yom Tov*, the
 * first day of *Rosh Hashana* and the first days of *Yom Tov* out of Israel. It is identical
 * to calling [isTomorrowShabbosOrYomTov].
 *
 * @return if the day has candle lighting.
 *
 * @see isTomorrowShabbosOrYomTov
 */
@property (readonly) BOOL hasCandleLighting __attribute__((swift_name("hasCandleLighting")));

/**
 * Is the calendar set to Israel, where some holidays have different rules.
 * @see .getInIsrael
 * @see .setInIsrael
 */
@property BOOL inIsrael __attribute__((swift_name("inIsrael")));

/**
 * Returns true if the current day is *Aseres Yemei Teshuva*.
 *
 * @return if the current day is *Aseres Yemei Teshuvah*
 */
@property (readonly) BOOL isAseresYemeiTeshuva __attribute__((swift_name("isAseresYemeiTeshuva")));

/**
 * Returns true if it is *Shabbos* or if it is a *Yom Tov* day that has a *melacha* (work)  prohibition.
 *
 * @return if the day is a *Yom Tov* that is *assur bemlacha* or *Shabbos*
 */
@property (readonly) BOOL isAssurBemelacha __attribute__((swift_name("isAssurBemelacha")));

/**
 * The Monday, Thursday and Monday after the first *Shabbos* after [*Rosh Chodesh*][isRoshChodesh]
 * [*Cheshvan*][HebrewMonth.CHESHVAN] and [*Iyar*][HebrewMonth.IYAR] are [*BeHaB*](https://outorah.org/p/41334/) days.
 * If the last Monday of Iyar's BeHaB coincides with [PESACH_SHENI], the method currently considers it both *Pesach Sheni* and *BeHaB*.
 * As seen in an Ohr Sameach  article on the subject [The unknown Days: BeHaB Vs. Pesach Sheini?](https://ohr.edu/this_week/insights_into_halacha/9340)
 * there are some customs that delay the day to various points in the future.
 * @return true if the day is *BeHaB*.
 */
@property (readonly) BOOL isBeHaB __attribute__((swift_name("isBeHaB")));

/**
 * [Birkas Hachamah](https://en.wikipedia.org/wiki/Birkat_Hachama) is recited every 28 years based on
 * *Tekufas Shmuel* (Julian years) that a year is 365.25 days. The [Rambam](https://en.wikipedia.org/wiki/Maimonides) in [&amp;&amp;Hilchos Kiddush Hachodesh 9:3](http://hebrewbooks.org/pdfpager.aspx?req=14278&amp;st=&amp;pgnum=323)
 * states that *tekufas Nissan* of year 1 was 7 days + 9 hours before *molad Nissan*. This is calculated as every
 * 10,227 days (28 * 365.25).
 * @return true for a day that *Birkas Hachamah* is recited.
 */
@property (readonly) BOOL isBirkasHachamah __attribute__((swift_name("isBirkasHachamah")));

/**
 * Returns true if the current day is one of the 8 days of *Chanukah*.
 *
 * @return if the current day is one of the 8 days of *Chanukah*.
 *
 * @see dayOfChanukah
 */
@property (readonly) BOOL isChanukah __attribute__((swift_name("isChanukah")));

/**
 * Returns true if the current day is *Chol Hamoed* of *Pesach* or *Succos*.
 *
 * @return true if the current day is *Chol Hamoed* of *Pesach* or *Succos*
 * @see isYomTov
 * @see CHOL_HAMOED_PESACH
 *
 * @see CHOL_HAMOED_SUCCOS
 */
@property (readonly) BOOL isCholHamoed __attribute__((swift_name("isCholHamoed")));

/**
 * Returns true if the current day is *Chol Hamoed* of *Pesach*.
 *
 * @return true if the current day is *Chol Hamoed* of *Pesach*
 * @see isYomTov
 * @see isPesach
 * @see CHOL_HAMOED_PESACH
 */
@property (readonly) BOOL isCholHamoedPesach __attribute__((swift_name("isCholHamoedPesach")));

/**
 * Returns true if the current day is *Chol Hamoed* of *Succos*.
 *
 * @return true if the current day is *Chol Hamoed* of *Succos*
 * @see isYomTov
 * @see CHOL_HAMOED_SUCCOS
 */
@property (readonly) BOOL isCholHamoedSuccos __attribute__((swift_name("isCholHamoedSuccos")));
@property (readonly) BOOL isErevPesach __attribute__((swift_name("isErevPesach")));

/**
 * Returns true if the current day is *Erev Rosh Chodesh*. Returns false for *Erev Rosh Hashana*.
 *
 * @return true if the current day is *Erev Rosh Chodesh*. Returns false for *Erev Rosh Hashana*.
 * @see isRoshChodesh
 */
@property (readonly) BOOL isErevRoshChodesh __attribute__((swift_name("isErevRoshChodesh")));
@property (readonly) BOOL isErevRoshHashana __attribute__((swift_name("isErevRoshHashana")));
@property (readonly) BOOL isErevShavuos __attribute__((swift_name("isErevShavuos")));
@property (readonly) BOOL isErevSheminiAtzeres __attribute__((swift_name("isErevSheminiAtzeres")));
@property (readonly) BOOL isErevSuccos __attribute__((swift_name("isErevSuccos")));
@property (readonly) BOOL isErevYomKippur __attribute__((swift_name("isErevYomKippur")));

/**
 * Returns true if the current day is *Erev Yom Tov*. The method returns true for *Erev* - *Pesach*
 * (first and last days), *Shavuos*, *Rosh Hashana*, *Yom Kippur*, *Succos* and *Hoshana
 * Rabba*.
 *
 * @return true if the current day is *Erev* - *Pesach*, *Shavuos*, *Rosh Hashana*, *Yom
 * Kippur*, *Succos* and *Hoshana Rabba*.
 * @see isYomTov
 * @see isErevYomTovSheni
 */
@property (readonly) BOOL isErevYomTov __attribute__((swift_name("isErevYomTov")));

/**
 * Returns true if the day is the second day of *Yom Tov*. This impacts the second day of *Rosh Hashana* everywhere and
 * the second days of Yom Tov in *chutz laaretz* (out of Israel).
 *
 * @return if the day is the second day of *Yom Tov*.
 */
@property (readonly) BOOL isErevYomTovSheni __attribute__((swift_name("isErevYomTovSheni")));

/**
 * Returns true if the current day is *Hoshana Rabba*.
 *
 * @return true true if the current day is *Hoshana Rabba*.
 * @see isYomTov
 * @see HOSHANA_RABBA
 */
@property (readonly) BOOL isHoshanaRabba __attribute__((swift_name("isHoshanaRabba")));

/**
 * Returns true if the current day is *Isru Chag*. The method returns true for the day following *Pesach*
 * *Shavuos* and *Succos*. It utilizes {@see #inIsrael} to return the proper date.
 *
 * @return true if the current day is *Isru Chag*. The method returns true for the day following *Pesach*
 * *Shavuos* and *Succos*. It utilizes {@see #inIsrael} to return the proper date.
 */
@property (readonly) BOOL isIsruChag __attribute__((swift_name("isIsruChag")));

/**
 * Returns if the day is *Shabbos* and Sunday is *Rosh Chodesh* and the *haftorah* of Machar Chodesh is read.
 *
 * @return true if it is *Shabbos* and Sunday is *Rosh Chodesh* and the *haftorah* of Machar Chodesh is read.
 * @todo There is more to tweak in this method (it does not cover all cases and opinions), and it may be removed.
 */
@property (readonly) BOOL isMacharChodesh __attribute__((swift_name("isMacharChodesh")));

/**
 * Is the calendar set to have Purim *demukafim*, where Purim is celebrated on Shushan Purim.
 * @see .getIsMukafChoma
 * @see .setIsMukafChoma
 */
@property BOOL isMukafChoma __attribute__((swift_name("isMukafChoma")));

/**
 * Returns true if the current day is *Pesach* (either  the *Yom Tov* of *Pesach* or*Chol Hamoed Pesach*).
 *
 * @return true if the current day is *Pesach* (either  the *Yom Tov* of *Pesach* or*Chol Hamoed Pesach*).
 * @see isYomTov
 * @see isCholHamoedPesach
 * @see PESACH
 *
 * @see CHOL_HAMOED_PESACH
 */
@property (readonly) BOOL isPesach __attribute__((swift_name("isPesach")));

/**
 * Returns if the day is Purim ([Shushan Purim](https://en.wikipedia.org/wiki/Purim#Shushan_Purim)
 * in a mukaf choma and regular Purim in a non-mukaf choma).
 * @return if the day is Purim (Shushan Purim in a mukaf choma and regular Purin in a non-mukaf choma)
 *
 * @see isMukafChoma
 */
@property (readonly) BOOL isPurim __attribute__((swift_name("isPurim")));

/**
 * Returns if the day is Rosh Chodesh. Rosh Hashana will return false
 *
 * @return true if it is Rosh Chodesh. Rosh Hashana will return false
 */
@property (readonly) BOOL isRoshChodesh __attribute__((swift_name("isRoshChodesh")));

/**
 * Returns true if the current day is *Rosh Hashana*.
 *
 * @return true if the current day is *Rosh Hashana*.
 * @see isYomTov
 * @see ROSH_HASHANA
 */
@property (readonly) BOOL isRoshHashana __attribute__((swift_name("isRoshHashana")));

/**
 * Returns if the day is *Shabbos Mevorchim*.
 *
 * @return true if it is *Shabbos Mevorchim*.
 */
@property (readonly) BOOL isShabbosMevorchim __attribute__((swift_name("isShabbosMevorchim")));

/**
 * Returns true if the current day is *Shavuos*.
 *
 * @return true if the current day is *Shavuos*.
 * @see isYomTov
 * @see SHAVUOS
 */
@property (readonly) BOOL isShavuos __attribute__((swift_name("isShavuos")));

/**
 * Returns true if the current day is *Shmini Atzeres*.
 *
 * @return true if the current day is *Shmini Atzeres*.
 * @see isYomTov
 * @see SHEMINI_ATZERES
 */
@property (readonly) BOOL isShminiAtzeres __attribute__((swift_name("isShminiAtzeres")));

/**
 * Returns true if the current day is *Simchas Torah*. This will always return false if [in Israel][.getInIsrael]
 *
 * @return true if the current day is *Shmini Atzeres*.
 * @see isYomTov
 * @see SIMCHAS_TORAH
 */
@property (readonly) BOOL isSimchasTorah __attribute__((swift_name("isSimchasTorah")));

/**
 * Returns true if the current day is *Succos* (either  the *Yom Tov* of *Succos* or*Chol Hamoed Succos*).
 * It will return false for [Shmini Atzeres][isShminiAtzeres] and [Simchas Torah][isSimchasTorah].
 *
 * @return true if the current day is *Succos* (either  the *Yom Tov* of *Succos* or*Chol Hamoed Succos*.
 * @see isYomTov
 * @see isCholHamoedSuccos
 * @see isHoshanaRabba
 * @see SUCCOS
 *
 * @see CHOL_HAMOED_SUCCOS
 *
 * @see HOSHANA_RABBA
 */
@property (readonly) BOOL isSuccos __attribute__((swift_name("isSuccos")));

/**
 * Return true if the day is a Taanis (fast day). Return true for *17 of Tammuz*, *Tisha B'Av*,
 * *Yom Kippur*, *Fast of Gedalyah*, *10 of Teves* and the *Fast of Esther*.
 *
 * @return true if today is a fast day
 */
@property (readonly) BOOL isTaanis __attribute__((swift_name("isTaanis")));

/**
 * Return true if the day is *Taanis Bechoros* (on *Erev Pesach*). It will return true for the 14th
 * of *Nissan* if it is not on *Shabbos*, or if the 12th of *Nissan* occurs on a Thursday.
 *
 * @return true if today is *Taanis Bechoros*.
 */
@property (readonly) BOOL isTaanisBechoros __attribute__((swift_name("isTaanisBechoros")));

/**
 * Returns if the day is Tisha Be'Av (the 9th of Av).
 * @return if the day is Tisha Be'Av (the 9th of Av).
 */
@property (readonly) BOOL isTishaBav __attribute__((swift_name("isTishaBav")));

/**
 * Returns true if tomorrow is *Shabbos* or *Yom Tov*. This will return true on *Erev Shabbos*,
 * *Erev Yom Tov*, the first day of *Rosh Hashana* and *erev* the first days of *Yom Tov*
 * out of Israel. It is identical to calling [hasCandleLighting].
 *
 * @return will return if the next day is *Shabbos* or *Yom Tov*.
 *
 * @see hasCandleLighting
 */
@property (readonly) BOOL isTomorrowShabbosOrYomTov __attribute__((swift_name("isTomorrowShabbosOrYomTov")));

/**
 * Is the calendar set to use modern Israeli holidays such as Yom Haatzmaut.
 * @see .isUseModernHolidays
 * @see .setUseModernHolidays
 */
@property BOOL isUseModernHolidays __attribute__((swift_name("isUseModernHolidays")));

/**
 * Returns true if the current day is *Yom Kippur*.
 *
 * @return true if the current day is *Yom Kippur*.
 * @see isYomTov
 * @see YOM_KIPPUR
 */
@property (readonly) BOOL isYomKippur __attribute__((swift_name("isYomKippur")));

/**
 * Returns true if the current day is *Yom Kippur Katan*. Returns false for *Erev Rosh Hashana*,
 * *Erev Rosh Chodesh Cheshvan*, *Teves* and *Iyyar*. If *Erev Rosh Chodesh* occurs
 * on a Friday or *Shabbos*, *Yom Kippur Katan* is moved back to Thursday.
 *
 * @return true if the current day is *Erev Rosh Chodesh*. Returns false for *Erev Rosh Hashana*.
 * @see isRoshChodesh
 */
@property (readonly) BOOL isYomKippurKatan __attribute__((swift_name("isYomKippurKatan")));

/**
 * Returns true if the current day is *Yom Tov*. The method returns true even for holidays such as [CHANUKAH]
 * and minor ones such as [TU_BEAV] and [PESACH_SHENI]. *Erev Yom Tov* (with the exception of
 * [HOSHANA_RABBA], *erev* the second days of [PESACH]) returns false, as do [fast][isTaanis] besides [YOM_KIPPUR].
 * Use [isAssurBemelacha] to find the days that have a prohibition of work.
 *
 * @return true if the current day is a Yom Tov
 *
 * @see yomTovIndex
 * @see isErevYomTov
 * @see isErevYomTovSheni
 * @see isTaanis
 * @see isAssurBemelacha
 * @see isCholHamoed
 */
@property (readonly) BOOL isYomTov __attribute__((swift_name("isYomTov")));

/**
 * Returns true if the *Yom Tov* day has a *melacha* (work)  prohibition. This method will return false for a
 * non-*Yom Tov* day, even if it is *Shabbos*.
 *
 * @return if the *Yom Tov* day has a *melacha* (work)  prohibition.
 */
@property (readonly) BOOL isYomTovAssurBemelacha __attribute__((swift_name("isYomTovAssurBemelacha")));

/**
 * Returns the *molad* in Standard Time in Yerushalayim as a Date. The traditional calculation uses local time.
 * This method subtracts 20.94 minutes (20 minutes and 56.496 seconds) from the local time (of *Har Habayis*
 * with a longitude of 35.2354 is 5.2354 away from the %15 timezone longitude) to get to standard time. This
 * method intentionally uses standard time and not daylight savings time. Java (TODO correct for Kotlin) will implicitly format the time to the
 * default (or set) Timezone.
 *
 * @return the Date representing the moment of the *molad* in Yerushalayim standard time (GMT + 2)
 */
@property (readonly) STTKotlinx_datetimeInstant *moladAsInstant __attribute__((swift_name("moladAsInstant")));

/**
 * Returns this week's [*Parsha*][Parsha] if it is *Shabbos*. It returns [Parsha.NONE] if the date
 * is a weekday or if there is no *parsha* that week (for example *Yom Tov* that falls on a *Shabbos*).
 *
 * @return the current *parsha*.
 */
@property (readonly) STTJewishCalendarParsha *parshah __attribute__((swift_name("parshah")));

/**
 * Returns the latest time of *Kiddush Levana* calculated as 15 days after the *molad.* This is the
 * opinion brought down in the Shulchan Aruch (Orach Chaim 426). It should be noted that some opinions hold that
 * the [Rema](http://en.wikipedia.org/wiki/Moses_Isserles) who brings down the the [Maharil's](http://en.wikipedia.org/wiki/Yaakov_ben_Moshe_Levi_Moelin) opinion of calculating it as
 * [half way between *molad* and *molad*][sofZmanKidushLevanaBetweenMoldos] is of the
 * opinion of the Mechaber as well. Also see the Aruch Hashulchan. For additional details on the subject, See Rabbi
 * Dovid Heber's very detailed writeup in Siman Daled (chapter 4) of [Shaarei Zmanim](http://www.worldcat.org/oclc/461326125). This method returns the time even if it is during
 * the day when *Kiddush Levana* can't be said. Callers of this method should consider displaying *alos*
 * before this time if the *zman* is between *alos* and *tzais*.
 *
 * @return the Date representing the moment 15 days after the *molad*.
 * @see sofZmanKidushLevanaBetweenMoldos
 * @see com.kosherjava.zmanim.ComplexZmanimCalendar.getSofZmanKidushLevana15Days
 * @see com.kosherjava.zmanim.ComplexZmanimCalendar.getSofZmanKidushLevana15Days
 */
@property (readonly) STTKotlinx_datetimeInstant *sofZmanKidushLevana15Days __attribute__((swift_name("sofZmanKidushLevana15Days")));

/**
 * Returns the latest time of Kiddush Levana according to the [Maharil's](http://en.wikipedia.org/wiki/Yaakov_ben_Moshe_Levi_Moelin) opinion that it is calculated as
 * halfway between *molad* and *molad*. This adds half the 29 days, 12 hours and 793 *chalakim*
 * time between *molad* and *molad* (14 days, 18 hours, 22 minutes and 666 milliseconds) to the month's
 * *molad*. This method returns the time even if it is during the day when *Kiddush Levana* can't be
 * recited. Callers of this method should consider displaying *alos* before this time if the *zman* is
 * between *alos* and *tzais*.
 *
 * @return the Date representing the moment halfway between *molad* and *molad*.
 *
 * @see sofZmanKidushLevana15Days
 * @see com.kosherjava.zmanim.ComplexZmanimCalendar.getSofZmanKidushLevanaBetweenMoldos
 * @see com.kosherjava.zmanim.ComplexZmanimCalendar.getSofZmanKidushLevanaBetweenMoldos
 */
@property (readonly) STTKotlinx_datetimeInstant *sofZmanKidushLevanaBetweenMoldos __attribute__((swift_name("sofZmanKidushLevanaBetweenMoldos")));

/**
 * Returns a [*Parsha*][Parsha] enum if the *Shabbos* is one of the four *parshiyos* of [Parsha.SHKALIM], [*Zachor*][Parsha.ZACHOR], [*Para*][Parsha.PARA], [Parsha.HACHODESH] or [Parsha.NONE] for a regular *Shabbos* (or any weekday).
 *
 * @return one of the four *parshiyos* of [*Shkalim*][Parsha.SHKALIM] [*Zachor*][Parsha.ZACHOR], [*Para*][Parsha.PARA], [*Hachdesh*][Parsha.HACHODESH] or [Parsha.NONE].
 */
@property (readonly) STTJewishCalendarParsha *specialShabbos __attribute__((swift_name("specialShabbos")));

/**
 * Returns the earliest time of *Kiddush Levana* calculated as 3 days after the molad. This method returns the time
 * even if it is during the day when *Kiddush Levana* can't be said. Callers of this method should consider
 * displaying the next *tzais* if the *zman* is between *alos* and *tzais*.
 *
 * @return the Date representing the moment 3 days after the molad.
 *
 * @see com.kosherjava.zmanim.ComplexZmanimCalendar.getTchilasZmanKidushLevana3Days
 * @see com.kosherjava.zmanim.ComplexZmanimCalendar.getTchilasZmanKidushLevana3Days
 */
@property (readonly) STTKotlinx_datetimeInstant *tchilasZmanKidushLevana3Days __attribute__((swift_name("tchilasZmanKidushLevana3Days")));

/**
 * Returns the earliest time of *Kiddush Levana* calculated as 7 days after the *molad* as mentioned
 * by the [Mechaber](http://en.wikipedia.org/wiki/Yosef_Karo). See the [Bach's](http://en.wikipedia.org/wiki/Yoel_Sirkis) opinion on this time. This method returns the time
 * even if it is during the day when *Kiddush Levana* can't be said. Callers of this method should consider
 * displaying the next *tzais* if the *zman* is between *alos* and *tzais*.
 *
 * @return the Date representing the moment 7 days after the molad.
 *
 * @see com.kosherjava.zmanim.ComplexZmanimCalendar.getTchilasZmanKidushLevana7Days
 * @see com.kosherjava.zmanim.ComplexZmanimCalendar.getTchilasZmanKidushLevana7Days
 */
@property (readonly) STTKotlinx_datetimeInstant *tchilasZmanKidushLevana7Days __attribute__((swift_name("tchilasZmanKidushLevana7Days")));

/**
 * Returns the elapsed days since *Tekufas Tishrei*. This uses *Tekufas Shmuel* (identical to the [Julian Year](https://en.wikipedia.org/wiki/Julian_year_(astronomy)) with a solar year length of 365.25 days).
 * The notation used below is D = days, H = hours and C = chalakim. *[Molad](https://en.wikipedia.org/wiki/Molad) BaHaRad* was 2D,5H,204C or 5H,204C from the start of *Rosh Hashana* year 1. For *molad
 * Nissan* add 177D, 4H and 438C (6 * 29D, 12H and 793C), or 177D,9H,642C after *Rosh Hashana* year 1.
 * *Tekufas Nissan* was 7D, 9H and 642C before *molad Nissan* according to the Rambam, or 170D, 0H and
 * 0C after *Rosh Hashana* year 1. *Tekufas Tishrei* was 182D and 3H (365.25 / 2) before *tekufas
 * Nissan*, or 12D and 15H before *Rosh Hashana* of year 1. Outside of Israel we start reciting *Tal
 * Umatar* in *Birkas Hashanim* from 60 days after *tekufas Tishrei*. The 60 days include the day of
 * the *tekufah* and the day we start reciting *Tal Umatar*. 60 days from the tekufah == 47D and 9H
 * from *Rosh Hashana* year 1.
 *
 * @return the number of elapsed days since *tekufas Tishrei*.
 *
 * @see isVeseinTalUmatarStartDate
 * @see isVeseinTalUmatarStartingTonight
 * @see isVeseinTalUmatarRecited
 */
@property (readonly) int32_t tekufasTishreiElapsedDays __attribute__((swift_name("tekufasTishreiElapsedDays")));

/**
 * Returns the upcoming [*Parsha*][Parsha] regardless of if it is the weekday or *Shabbos* (where next
 * Shabbos's *Parsha* will be returned. This is unlike [.getParshah] that returns [Parsha.NONE] if
 * the date is not *Shabbos*. If the upcoming Shabbos is a *Yom Tov* and has no *Parsha*, the
 * following week's *Parsha* will be returned.
 *
 * @return the upcoming *parsha*.
 */
@property (readonly) STTJewishCalendarParsha *upcomingParshah __attribute__((swift_name("upcomingParshah")));

/**
 * Returns an index of the Jewish holiday or fast day for the current day, or a -1 if there is no holiday for this day.
 * There are constants in this class representing each *Yom Tov*. Formatting of the *Yomim tovim* is done
 * in the [HebrewDateFormatter.formatYomTov].
 *
 * @todo Consider using enums instead of the constant ints.
 *
 * @return the index of the holiday such as the constant [.LAG_BAOMER] or [.YOM_KIPPUR] or a -1 if it is not a holiday.
 *
 * @see HebrewDateFormatter.formatYomTov
 */
@property (readonly) int32_t yomTovIndex __attribute__((swift_name("yomTovIndex")));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("JewishCalendar.Companion")))
@interface STTJewishCalendarCompanion : STTBase
+ (instancetype)alloc __attribute__((unavailable));
+ (instancetype)allocWithZone:(struct _NSZone *)zone __attribute__((unavailable));
+ (instancetype)companion __attribute__((swift_name("init()")));
@property (class, readonly, getter=shared) STTJewishCalendarCompanion *shared __attribute__((swift_name("shared")));

/**
 * [kotlinx.datetime.DayOfWeek] is ordered according to ISO-8601, where Monday is 1 and Sunday is 7.
 * [java.util.Calendar]'s day of week constants are ordered with Sunday is 1 and Saturday is 7.
 * This function converts between the two.
 * It is called [toJewishDayOfWeek] because the Torah describes Saturday as the 7th day.
 * **Note:** The caller should prefer to compare [DayOfWeek]s directly, instead of converting
 * to day numbers. This is to improve readability and possible future-proofing.
 * */
- (int32_t)toJewishDayOfWeek:(STTKotlinx_datetimeDayOfWeek *)receiver __attribute__((swift_name("toJewishDayOfWeek(_:)")));

/**
 * The Monday, Thursday and Monday after the first *Shabbos* after *Rosh Chodesh Cheshvan* and *Iyar*) are BeHab
 * days. This constant is not actively in use.
 * @see .isBeHaB
 */
@property (readonly) int32_t BEHAB __attribute__((swift_name("BEHAB")));

/** The holiday of Chanukah. 8 days starting on the 25th day Kislev. */
@property (readonly) int32_t CHANUKAH __attribute__((swift_name("CHANUKAH")));

/** Chol Hamoed (interim days) of Pesach (Passover) */
@property (readonly) int32_t CHOL_HAMOED_PESACH __attribute__((swift_name("CHOL_HAMOED_PESACH")));

/** Chol Hamoed (interim days) of Succos/Sukkos (Tabernacles) */
@property (readonly) int32_t CHOL_HAMOED_SUCCOS __attribute__((swift_name("CHOL_HAMOED_SUCCOS")));

/** The 14th day of Nissan, the day before of Pesach (Passover). */
@property (readonly) int32_t EREV_PESACH __attribute__((swift_name("EREV_PESACH")));

/**Erev Rosh Hashana (the day before Rosh Hashana), the 29th of Elul */
@property (readonly) int32_t EREV_ROSH_HASHANA __attribute__((swift_name("EREV_ROSH_HASHANA")));

/**Erev Shavuos (the day before Shavuos), the 5th of Sivan */
@property (readonly) int32_t EREV_SHAVUOS __attribute__((swift_name("EREV_SHAVUOS")));

/** The 14th day of Tishrei, the day before of Succos/Sukkos (Tabernacles). */
@property (readonly) int32_t EREV_SUCCOS __attribute__((swift_name("EREV_SUCCOS")));

/** The 9th day of Tishrei, the day before of Yom Kippur. */
@property (readonly) int32_t EREV_YOM_KIPPUR __attribute__((swift_name("EREV_YOM_KIPPUR")));

/** The fast of Esther, usually on the 13th day of Adar (or Adar II on leap years). It is earlier on some years. */
@property (readonly) int32_t FAST_OF_ESTHER __attribute__((swift_name("FAST_OF_ESTHER")));

/** The fast of Gedalyah, the 3rd of Tishrei. */
@property (readonly) int32_t FAST_OF_GEDALYAH __attribute__((swift_name("FAST_OF_GEDALYAH")));

/**
 * Value of the [.DAY_OF_WEEK] field indicating
 * Friday.
 */
@property (readonly) int32_t FRIDAY __attribute__((swift_name("FRIDAY")));

/** Hoshana Rabba, the 7th day of Succos/Sukkos that occurs on the 21st of Tishrei.  */
@property (readonly) int32_t HOSHANA_RABBA __attribute__((swift_name("HOSHANA_RABBA")));

/** The day following the last day of Pesach, Shavuos and Sukkos. */
@property (readonly) int32_t ISRU_CHAG __attribute__((swift_name("ISRU_CHAG")));

/** The 33rd day of the Omer, the 18th of Iyar, a minor holiday. */
@property (readonly) int32_t LAG_BAOMER __attribute__((swift_name("LAG_BAOMER")));

/**
 * Value of the [.DAY_OF_WEEK] field indicating
 * Monday.
 */
@property (readonly) int32_t MONDAY __attribute__((swift_name("MONDAY")));

/** value returned by [yomTovIndex] to indicate no holiday. */
@property (readonly) int32_t NO_HOLIDAY __attribute__((swift_name("NO_HOLIDAY")));

/** The holiday of Pesach (Passover) on the 15th (and 16th out of Israel) day of Nissan. */
@property (readonly) int32_t PESACH __attribute__((swift_name("PESACH")));

/**Pesach Sheni, the 14th day of Iyar, a minor holiday. */
@property (readonly) int32_t PESACH_SHENI __attribute__((swift_name("PESACH_SHENI")));

/** The holiday of Purim on the 14th day of Adar (or Adar II on leap years). */
@property (readonly) int32_t PURIM __attribute__((swift_name("PURIM")));

/** The holiday of Purim Katan on the 14th day of Adar I on a leap year when Purim is on Adar II, a minor holiday. */
@property (readonly) int32_t PURIM_KATAN __attribute__((swift_name("PURIM_KATAN")));

/**
 * Rosh Chodesh, the new moon on the first day of the Jewish month, and the 30th day of the previous month in the
 * case of a month with 30 days.
 */
@property (readonly) int32_t ROSH_CHODESH __attribute__((swift_name("ROSH_CHODESH")));

/** Rosh Hashana, the first of Tishrei. */
@property (readonly) int32_t ROSH_HASHANA __attribute__((swift_name("ROSH_HASHANA")));

/**
 * Value of the [.DAY_OF_WEEK] field indicating
 * Saturday.
 */
@property (readonly) int32_t SATURDAY __attribute__((swift_name("SATURDAY")));

/** The fast of the 17th day of Tamuz */
@property (readonly) int32_t SEVENTEEN_OF_TAMMUZ __attribute__((swift_name("SEVENTEEN_OF_TAMMUZ")));

/**Shavuos (Pentecost), the 6th of Sivan */
@property (readonly) int32_t SHAVUOS __attribute__((swift_name("SHAVUOS")));

/** Shmini Atzeres, the 8th day of Succos/Sukkos is an independent holiday that occurs on the 22nd of Tishrei.  */
@property (readonly) int32_t SHEMINI_ATZERES __attribute__((swift_name("SHEMINI_ATZERES")));

/** The holiday of Shushan Purim on the 15th day of Adar (or Adar II on leap years). */
@property (readonly) int32_t SHUSHAN_PURIM __attribute__((swift_name("SHUSHAN_PURIM")));

/** The holiday of Purim Katan on the 15th day of Adar I on a leap year when Purim is on Adar II, a minor holiday. */
@property (readonly) int32_t SHUSHAN_PURIM_KATAN __attribute__((swift_name("SHUSHAN_PURIM_KATAN")));

/** Simchas Torah, the 9th day of Succos/Sukkos, or the second day of Shmini Atzeres that is celebrated
 * [out of Israel][.getInIsrael] on the 23rd of Tishrei.
 */
@property (readonly) int32_t SIMCHAS_TORAH __attribute__((swift_name("SIMCHAS_TORAH")));

/** The holiday of Succos/Sukkos (Tabernacles), the 15th (and 16th out of Israel) day of Tishrei  */
@property (readonly) int32_t SUCCOS __attribute__((swift_name("SUCCOS")));

/**
 * Value of the [.DAY_OF_WEEK] field indicating
 * Sunday.
 */
@property (readonly) int32_t SUNDAY __attribute__((swift_name("SUNDAY")));

/** The fast of the 10th day of Teves. */
@property (readonly) int32_t TENTH_OF_TEVES __attribute__((swift_name("TENTH_OF_TEVES")));

/**
 * Value of the [.DAY_OF_WEEK] field indicating
 * Thursday.
 */
@property (readonly) int32_t THURSDAY __attribute__((swift_name("THURSDAY")));

/** The fast of the 9th of Av */
@property (readonly) int32_t TISHA_BEAV __attribute__((swift_name("TISHA_BEAV")));

/**
 * Value of the [.DAY_OF_WEEK] field indicating
 * Tuesday.
 */
@property (readonly) int32_t TUESDAY __attribute__((swift_name("TUESDAY")));

/** The 15th day of Av, a minor holiday */
@property (readonly) int32_t TU_BEAV __attribute__((swift_name("TU_BEAV")));

/** Tu Bishvat on the 15th day of Shevat, a minor holiday. */
@property (readonly) int32_t TU_BESHVAT __attribute__((swift_name("TU_BESHVAT")));

/**
 * Value of the [.DAY_OF_WEEK] field indicating
 * Wednesday.
 */
@property (readonly) int32_t WEDNESDAY __attribute__((swift_name("WEDNESDAY")));

/** Yom Ha'atzmaut, Israel Independence Day, the 5th of Iyar, but if it occurs on a Friday or Saturday, the holiday is
 * moved back to Thursday, the 3rd of 4th of Iyar, and if it falls on a Monday, it is moved forward to Tuesday the
 * 6th of Iyar.  A [modern holiday][.isUseModernHolidays]. */
@property (readonly) int32_t YOM_HAATZMAUT __attribute__((swift_name("YOM_HAATZMAUT")));

/** Yom HaShoah, Holocaust Remembrance Day, usually held on the 27th of Nissan. If it falls on a Friday, it is moved
 * to the 26th, and if it falls on a Sunday it is moved to the 28th. A [modern holiday][.isUseModernHolidays].
 */
@property (readonly) int32_t YOM_HASHOAH __attribute__((swift_name("YOM_HASHOAH")));

/**
 * Yom HaZikaron, Israeli Memorial Day, held a day before Yom Ha'atzmaut.  A [modern holiday][.isUseModernHolidays].
 */
@property (readonly) int32_t YOM_HAZIKARON __attribute__((swift_name("YOM_HAZIKARON")));

/** The holiday of Yom Kippur, the 10th day of Tishrei */
@property (readonly) int32_t YOM_KIPPUR __attribute__((swift_name("YOM_KIPPUR")));

/**
 * The day before *Rosh Chodesh* (moved to Thursday if *Rosh Chodesh* is on a Friday or *Shabbos*) in most months.
 * This constant is not actively in use.
 * @see .isYomKippurKatan
 */
@property (readonly) int32_t YOM_KIPPUR_KATAN __attribute__((swift_name("YOM_KIPPUR_KATAN")));

/**
 * Yom Yerushalayim or Jerusalem Day, on 28 Iyar. A [modern holiday][.isUseModernHolidays].
 */
@property (readonly) int32_t YOM_YERUSHALAYIM __attribute__((swift_name("YOM_YERUSHALAYIM")));

/**
 * An array of *parshiyos* in the 17 possible combinations.
 */
@property (readonly) STTKotlinArray<STTKotlinArray<STTJewishCalendarParsha *> *> *parshalist __attribute__((swift_name("parshalist")));
@end


/**
 * List of *parshiyos* or special *Shabasos*. [NONE] indicates a week without a *parsha*, while the enum for
 * the *parsha* of [.VZOS_HABERACHA] exists for consistency, but is not currently used. The special *Shabasos* of
 * Shekalim, Zachor, Para, Hachodesh, as well as Shabbos Shuva, Shira, Hagadol, Chazon and Nachamu are also represented in this collection
 * of *parshiyos*.
 * @see specialShabbos
 * @see parshah
 */
__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("JewishCalendar.Parsha")))
@interface STTJewishCalendarParsha : STTKotlinEnum<STTJewishCalendarParsha *>
+ (instancetype)alloc __attribute__((unavailable));

/**
 * List of *parshiyos* or special *Shabasos*. [NONE] indicates a week without a *parsha*, while the enum for
 * the *parsha* of [.VZOS_HABERACHA] exists for consistency, but is not currently used. The special *Shabasos* of
 * Shekalim, Zachor, Para, Hachodesh, as well as Shabbos Shuva, Shira, Hagadol, Chazon and Nachamu are also represented in this collection
 * of *parshiyos*.
 * @see specialShabbos
 * @see parshah
 */
+ (instancetype)allocWithZone:(struct _NSZone *)zone __attribute__((unavailable));
- (instancetype)initWithName:(NSString *)name ordinal:(int32_t)ordinal __attribute__((swift_name("init(name:ordinal:)"))) __attribute__((objc_designated_initializer)) __attribute__((unavailable));
@property (class, readonly) STTJewishCalendarParsha *none __attribute__((swift_name("none")));
@property (class, readonly) STTJewishCalendarParsha *bereshis __attribute__((swift_name("bereshis")));
@property (class, readonly) STTJewishCalendarParsha *noach __attribute__((swift_name("noach")));
@property (class, readonly) STTJewishCalendarParsha *lechLecha __attribute__((swift_name("lechLecha")));
@property (class, readonly) STTJewishCalendarParsha *vayera __attribute__((swift_name("vayera")));
@property (class, readonly) STTJewishCalendarParsha *chayeiSara __attribute__((swift_name("chayeiSara")));
@property (class, readonly) STTJewishCalendarParsha *toldos __attribute__((swift_name("toldos")));
@property (class, readonly) STTJewishCalendarParsha *vayetzei __attribute__((swift_name("vayetzei")));
@property (class, readonly) STTJewishCalendarParsha *vayishlach __attribute__((swift_name("vayishlach")));
@property (class, readonly) STTJewishCalendarParsha *vayeshev __attribute__((swift_name("vayeshev")));
@property (class, readonly) STTJewishCalendarParsha *miketz __attribute__((swift_name("miketz")));
@property (class, readonly) STTJewishCalendarParsha *vayigash __attribute__((swift_name("vayigash")));
@property (class, readonly) STTJewishCalendarParsha *vayechi __attribute__((swift_name("vayechi")));
@property (class, readonly) STTJewishCalendarParsha *shemos __attribute__((swift_name("shemos")));
@property (class, readonly) STTJewishCalendarParsha *vaera __attribute__((swift_name("vaera")));
@property (class, readonly) STTJewishCalendarParsha *bo __attribute__((swift_name("bo")));
@property (class, readonly) STTJewishCalendarParsha *beshalach __attribute__((swift_name("beshalach")));
@property (class, readonly) STTJewishCalendarParsha *yisro __attribute__((swift_name("yisro")));
@property (class, readonly) STTJewishCalendarParsha *mishpatim __attribute__((swift_name("mishpatim")));
@property (class, readonly) STTJewishCalendarParsha *terumah __attribute__((swift_name("terumah")));
@property (class, readonly) STTJewishCalendarParsha *tetzaveh __attribute__((swift_name("tetzaveh")));
@property (class, readonly) STTJewishCalendarParsha *kiSisa __attribute__((swift_name("kiSisa")));
@property (class, readonly) STTJewishCalendarParsha *vayakhel __attribute__((swift_name("vayakhel")));
@property (class, readonly) STTJewishCalendarParsha *pekudei __attribute__((swift_name("pekudei")));
@property (class, readonly) STTJewishCalendarParsha *vayikra __attribute__((swift_name("vayikra")));
@property (class, readonly) STTJewishCalendarParsha *tzav __attribute__((swift_name("tzav")));
@property (class, readonly) STTJewishCalendarParsha *shmini __attribute__((swift_name("shmini")));
@property (class, readonly) STTJewishCalendarParsha *tazria __attribute__((swift_name("tazria")));
@property (class, readonly) STTJewishCalendarParsha *metzora __attribute__((swift_name("metzora")));
@property (class, readonly) STTJewishCalendarParsha *achreiMos __attribute__((swift_name("achreiMos")));
@property (class, readonly) STTJewishCalendarParsha *kedoshim __attribute__((swift_name("kedoshim")));
@property (class, readonly) STTJewishCalendarParsha *emor __attribute__((swift_name("emor")));
@property (class, readonly) STTJewishCalendarParsha *behar __attribute__((swift_name("behar")));
@property (class, readonly) STTJewishCalendarParsha *bechukosai __attribute__((swift_name("bechukosai")));
@property (class, readonly) STTJewishCalendarParsha *bamidbar __attribute__((swift_name("bamidbar")));
@property (class, readonly) STTJewishCalendarParsha *nasso __attribute__((swift_name("nasso")));
@property (class, readonly) STTJewishCalendarParsha *behaaloscha __attribute__((swift_name("behaaloscha")));
@property (class, readonly) STTJewishCalendarParsha *shlach __attribute__((swift_name("shlach")));
@property (class, readonly) STTJewishCalendarParsha *korach __attribute__((swift_name("korach")));
@property (class, readonly) STTJewishCalendarParsha *chukas __attribute__((swift_name("chukas")));
@property (class, readonly) STTJewishCalendarParsha *balak __attribute__((swift_name("balak")));
@property (class, readonly) STTJewishCalendarParsha *pinchas __attribute__((swift_name("pinchas")));
@property (class, readonly) STTJewishCalendarParsha *matos __attribute__((swift_name("matos")));
@property (class, readonly) STTJewishCalendarParsha *masei __attribute__((swift_name("masei")));
@property (class, readonly) STTJewishCalendarParsha *devarim __attribute__((swift_name("devarim")));
@property (class, readonly) STTJewishCalendarParsha *vaeschanan __attribute__((swift_name("vaeschanan")));
@property (class, readonly) STTJewishCalendarParsha *eikev __attribute__((swift_name("eikev")));
@property (class, readonly) STTJewishCalendarParsha *reeh __attribute__((swift_name("reeh")));
@property (class, readonly) STTJewishCalendarParsha *shoftim __attribute__((swift_name("shoftim")));
@property (class, readonly) STTJewishCalendarParsha *kiSeitzei __attribute__((swift_name("kiSeitzei")));
@property (class, readonly) STTJewishCalendarParsha *kiSavo __attribute__((swift_name("kiSavo")));
@property (class, readonly) STTJewishCalendarParsha *nitzavim __attribute__((swift_name("nitzavim")));
@property (class, readonly) STTJewishCalendarParsha *vayeilech __attribute__((swift_name("vayeilech")));
@property (class, readonly) STTJewishCalendarParsha *haazinu __attribute__((swift_name("haazinu")));
@property (class, readonly) STTJewishCalendarParsha *vzosHaberacha __attribute__((swift_name("vzosHaberacha")));
@property (class, readonly) STTJewishCalendarParsha *vayakhelPekudei __attribute__((swift_name("vayakhelPekudei")));
@property (class, readonly) STTJewishCalendarParsha *tazriaMetzora __attribute__((swift_name("tazriaMetzora")));
@property (class, readonly) STTJewishCalendarParsha *achreiMosKedoshim __attribute__((swift_name("achreiMosKedoshim")));
@property (class, readonly) STTJewishCalendarParsha *beharBechukosai __attribute__((swift_name("beharBechukosai")));
@property (class, readonly) STTJewishCalendarParsha *chukasBalak __attribute__((swift_name("chukasBalak")));
@property (class, readonly) STTJewishCalendarParsha *matosMasei __attribute__((swift_name("matosMasei")));
@property (class, readonly) STTJewishCalendarParsha *nitzavimVayeilech __attribute__((swift_name("nitzavimVayeilech")));
@property (class, readonly) STTJewishCalendarParsha *shkalim __attribute__((swift_name("shkalim")));
@property (class, readonly) STTJewishCalendarParsha *zachor __attribute__((swift_name("zachor")));
@property (class, readonly) STTJewishCalendarParsha *para __attribute__((swift_name("para")));
@property (class, readonly) STTJewishCalendarParsha *hachodesh __attribute__((swift_name("hachodesh")));
@property (class, readonly) STTJewishCalendarParsha *shuva __attribute__((swift_name("shuva")));
@property (class, readonly) STTJewishCalendarParsha *shira __attribute__((swift_name("shira")));
@property (class, readonly) STTJewishCalendarParsha *hagadol __attribute__((swift_name("hagadol")));
@property (class, readonly) STTJewishCalendarParsha *chazon __attribute__((swift_name("chazon")));
@property (class, readonly) STTJewishCalendarParsha *nachamu __attribute__((swift_name("nachamu")));
+ (STTKotlinArray<STTJewishCalendarParsha *> *)values __attribute__((swift_name("values()")));
@property (class, readonly) NSArray<STTJewishCalendarParsha *> *entries __attribute__((swift_name("entries")));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("JewishDate.Companion")))
@interface STTJewishDateCompanion : STTBase
+ (instancetype)alloc __attribute__((unavailable));
+ (instancetype)allocWithZone:(struct _NSZone *)zone __attribute__((unavailable));
+ (instancetype)companion __attribute__((swift_name("init()")));
@property (class, readonly, getter=shared) STTJewishDateCompanion *shared __attribute__((swift_name("shared")));
- (int32_t)daysInJewishYear:(int32_t)receiver __attribute__((swift_name("daysInJewishYear(_:)")));
- (int32_t)daysInJewishYear_:(int64_t)receiver __attribute__((swift_name("daysInJewishYear(__:)")));
- (BOOL)isCheshvanLong:(int32_t)receiver __attribute__((swift_name("isCheshvanLong(_:)")));
- (BOOL)isCheshvanLong_:(int64_t)receiver __attribute__((swift_name("isCheshvanLong(__:)")));
- (BOOL)isJewishLeapYear:(int32_t)receiver __attribute__((swift_name("isJewishLeapYear(_:)")));
- (BOOL)isJewishLeapYear_:(int64_t)receiver __attribute__((swift_name("isJewishLeapYear(__:)")));
- (BOOL)isKislevShort:(int32_t)receiver __attribute__((swift_name("isKislevShort(_:)")));
- (BOOL)isKislevShort_:(int64_t)receiver __attribute__((swift_name("isKislevShort(__:)")));

/**
 * returns the number of days from Rosh Hashana of the date passed in, to the full date passed in.
 *
 * @param year
 * the Jewish year
 * @param month
 * the Jewish month
 * @param dayOfMonth
 * the day in the Jewish month
 * @return the number of days
 */
- (int32_t)getDaysSinceStartOfJewishYearYear:(int64_t)year month:(STTHebrewMonth *)month dayOfMonth:(int32_t)dayOfMonth __attribute__((swift_name("getDaysSinceStartOfJewishYear(year:month:dayOfMonth:)")));

/**
 * Returns the number of days elapsed from the Sunday prior to the start of the Jewish Calendar to the mean
 * conjunction of Tishri of the Jewish year.
 *
 * @param year
 * the Jewish year
 * @return the number of days elapsed from prior to the molad Tohu BaHaRaD (Be = Monday, Ha= 5 hours and Rad =204
 * chalakim/parts) prior to the start of the Jewish calendar, to the mean conjunction of Tishri of the
 * Jewish year. BeHaRaD is 23:11:20 on Sunday night(5 hours 204/1080 chalakim after sunset on Sunday
 * evening).
 */
- (int32_t)getJewishCalendarElapsedDaysYear:(int32_t)year __attribute__((swift_name("getJewishCalendarElapsedDays(year:)")));
- (int64_t)getJewishCalendarElapsedDaysYear_:(int64_t)year __attribute__((swift_name("getJewishCalendarElapsedDays(year_:)")));

/**
 * A short year where both [CHESHVAN] and [KISLEV] are 29 days.
 *
 * @see cheshvanKislevKviah
 * @see HebrewDateFormatter.getFormattedKviah
 */
@property (readonly) int32_t CHASERIM __attribute__((swift_name("CHASERIM")));

/**
 * An ordered year where [CHESHVAN] is 29 days and [.KISLEV] is 30 days.
 *
 * @see cheshvanKislevKviah
 * @see HebrewDateFormatter.getFormattedKviah
 */
@property (readonly) int32_t KESIDRAN __attribute__((swift_name("KESIDRAN")));

/**
 * A long year where both [CHESHVAN] and [KISLEV] are 30 days.
 *
 * @see cheshvanKislevKviah
 * @see HebrewDateFormatter.getFormattedKviah
 */
@property (readonly) int32_t SHELAIMIM __attribute__((swift_name("SHELAIMIM")));
@end


/**
 * Tefila Rules is a utility class that covers the various *halachos* and *minhagim* regarding
 * changes to daily *tefila* / prayers, based on the Jewish calendar. This is mostly useful for use in
 * developing *siddur* type applications, but it is also valuable for *shul* calendars that set
 * *tefila* times based on if [*tachanun*](https://en.wikipedia.org/wiki/Tachanun) is
 * recited that day. There are many settings in this class to cover the vast majority of *minhagim*, but
 * there are likely some not covered here. The source for many of the *chasidishe minhagim* can be found
 * in the [Minhag Yisrael Torah](https://www.nli.org.il/he/books/NNL_ALEPH001141272/NLI) on Orach
 * Chaim 131.
 * Dates used in specific communities such as specific *yahrzeits* or a holidays like Purim Mezhbizh
 * (Medzhybizh) celebrated on 11 [*Teves*][HebrewMonth.TEVES] or [Purim Saragossa](https://en.wikipedia.org/wiki/Second_Purim#Purim_Saragossa_(18_Shevat)) celebrated on
 * the (17th or) 18th of [*Shevat*][HebrewMonth.SHEVAT] are not (and likely will not be) supported by
 * this class.
 *
 * Sample code:
 * <pre style="background: #FEF0C9; display: inline-block;">
 * TefilaRules tr = new TefilaRules();
 * JewishCalendar jewishCalendar = new JewishCalendar();
 * HebrewDateFormatter hdf = new HebrewDateFormatter();
 * jewishCalendar.setJewishDate(5783, HebrewMonth.TISHREI, 1); // Rosh Hashana
 * System.out.println(hdf.format(jewishCalendar) + ": " + tr.isTachanunRecitedShacharis(jd));
 * jewishCalendar.setJewishDate(5783, HebrewMonth.ADAR, 17);
 * System.out.println(hdf.format(jewishCalendar) + ": " + tr.isTachanunRecitedShacharis(jewishCalendar));
 * tr.setTachanunRecitedWeekOfPurim(false);
 * System.out.println(hdf.format(jewishCalendar) + ": " + tr.isTachanunRecitedShacharis(jewishCalendar));</pre>
 *
 * @author  Y. Paritcher 2019 - 2021
 * @author  Eliyahu Hershfeld 2019 - 2022
 *
 * @todo The following items may be added at a future date.
 *
 *  1. *Lamnatzaiach*
 *  1. *Mizmor Lesoda*
 *  1. *Behab*
 *  1. *Selichos*
 *  1. ...
 *
 */
__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("TefilaRules")))
@interface STTTefilaRules : STTBase

/**
 * Tefila Rules is a utility class that covers the various *halachos* and *minhagim* regarding
 * changes to daily *tefila* / prayers, based on the Jewish calendar. This is mostly useful for use in
 * developing *siddur* type applications, but it is also valuable for *shul* calendars that set
 * *tefila* times based on if [*tachanun*](https://en.wikipedia.org/wiki/Tachanun) is
 * recited that day. There are many settings in this class to cover the vast majority of *minhagim*, but
 * there are likely some not covered here. The source for many of the *chasidishe minhagim* can be found
 * in the [Minhag Yisrael Torah](https://www.nli.org.il/he/books/NNL_ALEPH001141272/NLI) on Orach
 * Chaim 131.
 * Dates used in specific communities such as specific *yahrzeits* or a holidays like Purim Mezhbizh
 * (Medzhybizh) celebrated on 11 [*Teves*][HebrewMonth.TEVES] or [Purim Saragossa](https://en.wikipedia.org/wiki/Second_Purim#Purim_Saragossa_(18_Shevat)) celebrated on
 * the (17th or) 18th of [*Shevat*][HebrewMonth.SHEVAT] are not (and likely will not be) supported by
 * this class.
 *
 * Sample code:
 * <pre style="background: #FEF0C9; display: inline-block;">
 * TefilaRules tr = new TefilaRules();
 * JewishCalendar jewishCalendar = new JewishCalendar();
 * HebrewDateFormatter hdf = new HebrewDateFormatter();
 * jewishCalendar.setJewishDate(5783, HebrewMonth.TISHREI, 1); // Rosh Hashana
 * System.out.println(hdf.format(jewishCalendar) + ": " + tr.isTachanunRecitedShacharis(jd));
 * jewishCalendar.setJewishDate(5783, HebrewMonth.ADAR, 17);
 * System.out.println(hdf.format(jewishCalendar) + ": " + tr.isTachanunRecitedShacharis(jewishCalendar));
 * tr.setTachanunRecitedWeekOfPurim(false);
 * System.out.println(hdf.format(jewishCalendar) + ": " + tr.isTachanunRecitedShacharis(jewishCalendar));</pre>
 *
 * @author  Y. Paritcher 2019 - 2021
 * @author  Eliyahu Hershfeld 2019 - 2022
 *
 * @todo The following items may be added at a future date.
 *
 *  1. *Lamnatzaiach*
 *  1. *Mizmor Lesoda*
 *  1. *Behab*
 *  1. *Selichos*
 *  1. ...
 *
 */
- (instancetype)init __attribute__((swift_name("init()"))) __attribute__((objc_designated_initializer));

/**
 * Tefila Rules is a utility class that covers the various *halachos* and *minhagim* regarding
 * changes to daily *tefila* / prayers, based on the Jewish calendar. This is mostly useful for use in
 * developing *siddur* type applications, but it is also valuable for *shul* calendars that set
 * *tefila* times based on if [*tachanun*](https://en.wikipedia.org/wiki/Tachanun) is
 * recited that day. There are many settings in this class to cover the vast majority of *minhagim*, but
 * there are likely some not covered here. The source for many of the *chasidishe minhagim* can be found
 * in the [Minhag Yisrael Torah](https://www.nli.org.il/he/books/NNL_ALEPH001141272/NLI) on Orach
 * Chaim 131.
 * Dates used in specific communities such as specific *yahrzeits* or a holidays like Purim Mezhbizh
 * (Medzhybizh) celebrated on 11 [*Teves*][HebrewMonth.TEVES] or [Purim Saragossa](https://en.wikipedia.org/wiki/Second_Purim#Purim_Saragossa_(18_Shevat)) celebrated on
 * the (17th or) 18th of [*Shevat*][HebrewMonth.SHEVAT] are not (and likely will not be) supported by
 * this class.
 *
 * Sample code:
 * <pre style="background: #FEF0C9; display: inline-block;">
 * TefilaRules tr = new TefilaRules();
 * JewishCalendar jewishCalendar = new JewishCalendar();
 * HebrewDateFormatter hdf = new HebrewDateFormatter();
 * jewishCalendar.setJewishDate(5783, HebrewMonth.TISHREI, 1); // Rosh Hashana
 * System.out.println(hdf.format(jewishCalendar) + ": " + tr.isTachanunRecitedShacharis(jd));
 * jewishCalendar.setJewishDate(5783, HebrewMonth.ADAR, 17);
 * System.out.println(hdf.format(jewishCalendar) + ": " + tr.isTachanunRecitedShacharis(jewishCalendar));
 * tr.setTachanunRecitedWeekOfPurim(false);
 * System.out.println(hdf.format(jewishCalendar) + ": " + tr.isTachanunRecitedShacharis(jewishCalendar));</pre>
 *
 * @author  Y. Paritcher 2019 - 2021
 * @author  Eliyahu Hershfeld 2019 - 2022
 *
 * @todo The following items may be added at a future date.
 *
 *  1. *Lamnatzaiach*
 *  1. *Mizmor Lesoda*
 *  1. *Behab*
 *  1. *Selichos*
 *  1. ...
 *
 */
+ (instancetype)new __attribute__((availability(swift, unavailable, message="use object initializers instead")));

/**
 * Returns if [*Al HaNissim*](https://en.wikipedia.org/wiki/Al_HaNissim) is recited on the day in question.
 *
 * @param jewishCalendar the Jewish calendar day.
 * @return if *al hanissim* is recited.
 * @see JewishCalendar.isChanukah
 * @see JewishCalendar.isPurim
 * @see JewishCalendar.getIsMukafChoma
 */
- (BOOL)isAlHanissimRecitedJewishCalendar:(STTJewishCalendar *)jewishCalendar __attribute__((swift_name("isAlHanissimRecited(jewishCalendar:)")));
- (BOOL)isBetween:(STTJewishCalendar *)receiver startDate:(STTJewishDate *)startDate endDate:(STTJewishDate *)endDate __attribute__((swift_name("isBetween(_:startDate:endDate:)")));

/**
 * Returns if *Hallel* is recited on the day in question. This will return true for both *Hallel shalem*
 * and *Chatzi Hallel*. See [.isHallelShalemRecited] to know if the complete *Hallel*
 * is recited.
 *
 * @param jewishCalendar the Jewish calendar day.
 * @return if *Hallel* is recited.
 * @see isHallelShalemRecited
 */
- (BOOL)isHallelRecitedJewishCalendar:(STTJewishCalendar *)jewishCalendar __attribute__((swift_name("isHallelRecited(jewishCalendar:)")));

/**
 * Returns if *hallel shalem* is recited on the day in question. This will always return false if [isHallelRecited] returns false.
 *
 * @param jewishCalendar the Jewish calendar day.
 * @return if *hallel shalem* is recited.
 * @see .isHallelRecited
 */
- (BOOL)isHallelShalemRecitedJewishCalendar:(STTJewishCalendar *)jewishCalendar __attribute__((swift_name("isHallelShalemRecited(jewishCalendar:)")));

/**
 * Returns if the date is the end date for reciting *Mashiv Haruach Umorid Hageshem*. The date is 15
 * [*Nissan*][HebrewMonth.NISSAN].
 *
 * @param jewishCalendar the Jewish calendar day.
 * @return true if the date is the end date for reciting *Mashiv Haruach Umorid Hageshem*.
 * @see isMashivHaruachStartDate
 * @see isMashivHaruachRecited
 */
- (BOOL)isMashivHaruachEndDateJewishCalendar:(STTJewishCalendar *)jewishCalendar __attribute__((swift_name("isMashivHaruachEndDate(jewishCalendar:)")));

/**
 * Returns if *Mashiv Haruach Umorid Hageshem* is recited. This period starts on 22 [HebrewMonth.TISHREI] and ends on the 15th day of [*Nissan*][HebrewMonth.NISSAN].
 *
 * @param jewishCalendar the Jewish calendar day.
 * @return true if *Mashiv Haruach Umorid Hageshem* is recited.
 * @see .isMashivHaruachStartDate
 * @see .isMashivHaruachEndDate
 */
- (BOOL)isMashivHaruachRecitedJewishCalendar:(STTJewishCalendar *)jewishCalendar __attribute__((swift_name("isMashivHaruachRecited(jewishCalendar:)")));

/**
 * Returns if the date is the start date for reciting *Mashiv Haruach Umorid Hageshem*. The date is 22
 * [*Tishrei*][HebrewMonth.TISHREI].
 *
 * @param jewishCalendar the Jewish calendar day.
 * @return true if the date is the start date for reciting *Mashiv Haruach Umorid Hageshem*.
 * @see .isMashivHaruachEndDate
 * @see .isMashivHaruachRecited
 */
- (BOOL)isMashivHaruachStartDateJewishCalendar:(STTJewishCalendar *)jewishCalendar __attribute__((swift_name("isMashivHaruachStartDate(jewishCalendar:)")));

/**
 * Returns if *Morid Hatal* (or the lack of reciting *Mashiv Haruach* following *nussach Ashkenaz*) is
 * recited. This period starts on the 15th day of [*Nissan*][HebrewMonth.NISSAN] and ends on 22 [HebrewMonth.TISHREI].
 *
 * @param jewishCalendar the Jewish calendar day.
 *
 * @return true if *Morid Hatal* (or the lack of reciting *Mashiv Haruach* following *nussach Ashkenaz*) is recited.
 */
- (BOOL)isMoridHatalRecitedJewishCalendar:(STTJewishCalendar *)jewishCalendar __attribute__((swift_name("isMoridHatalRecited(jewishCalendar:)")));

/**
 * Returns if *tachanun* is recited during *mincha* on the day in question.
 *
 * @param jewishCalendar the Jewish LocalDate day.
 * @return if *tachanun* is recited during *mincha*.
 * @see .isTachanunRecitedShacharis
 */
- (BOOL)isTachanunRecitedMinchaJewishCalendar:(STTJewishCalendar *)jewishCalendar __attribute__((swift_name("isTachanunRecitedMincha(jewishCalendar:)")));

/**
 * Returns if *tachanun* is recited during *shacharis* on the day in question. See the many
 * *minhag* based settings that are available in this class.
 *
 * @param jewishCalendar the Jewish calendar day.
 * @return if *tachanun* is recited during *shacharis*.
 * @see .isTachanunRecitedMincha
 */
- (BOOL)isTachanunRecitedShacharisJewishCalendar:(STTJewishCalendar *)jewishCalendar __attribute__((swift_name("isTachanunRecitedShacharis(jewishCalendar:)")));

/**
 * Returns if *Vesein Beracha* is recited. It is recited from 15 [*Nissan*][HebrewMonth.NISSAN] to the
 * point that [*vesein tal umatar* is recited][.isVeseinTalUmatarRecited].
 *
 * @param jewishCalendar the Jewish calendar day.
 * @return true if *Vesein Beracha* is recited.
 * @see .isVeseinTalUmatarRecited
 */
- (BOOL)isVeseinBerachaRecitedJewishCalendar:(STTJewishCalendar *)jewishCalendar __attribute__((swift_name("isVeseinBerachaRecited(jewishCalendar:)")));

/**
 * Returns if *Vesein Tal Umatar Livracha* (*Sheailas Geshamim*) is recited. This will return
 * true for the entire season, even on *Shabbos* when it is not recited.
 *
 * @param jewishCalendar the Jewish calendar day.
 *
 * @return true if *Vesein Tal Umatar Livracha* (*Sheailas Geshamim*) is recited.
 *
 * @see .isVeseinTalUmatarStartDate
 * @see .isVeseinTalUmatarStartingTonight
 */
- (BOOL)isVeseinTalUmatarRecitedJewishCalendar:(STTJewishCalendar *)jewishCalendar __attribute__((swift_name("isVeseinTalUmatarRecited(jewishCalendar:)")));

/**
 * Returns if it is the Jewish day (starting the evening before) to start reciting *Vesein Tal Umatar Livracha*
 * (*Sheailas Geshamim*). In Israel this is the 7th day of [*Marcheshvan*][HebrewMonth.CHESHVAN].
 * Outside Israel recitation starts on the evening of December 4th (or 5th if it is the year before a civil leap year)
 * in the 21st century and shifts a day forward every century not evenly divisible by 400. This method will return true
 * if *vesein tal umatar* on the current Jewish date that starts on the previous night, so Dec 5/6 will be
 * returned by this method in the 21st century. *vesein tal umatar* is not recited on *Shabbos* and the
 * start date will be delayed a day when the start day is on a *Shabbos* (this can only occur out of Israel).
 *
 * @param jewishCalendar the Jewish calendar day.
 *
 * @return true if it is the first Jewish day (starting the prior evening of reciting *Vesein Tal Umatar Livracha*
 * (*Sheailas Geshamim*).
 *
 * @see .isVeseinTalUmatarStartingTonight
 * @see .isVeseinTalUmatarRecited
 */
- (BOOL)isVeseinTalUmatarStartDateJewishCalendar:(STTJewishCalendar *)jewishCalendar __attribute__((swift_name("isVeseinTalUmatarStartDate(jewishCalendar:)")));

/**
 * Returns if true if tonight is the first night to start reciting *Vesein Tal Umatar Livracha* (
 * *Sheailas Geshamim*). In Israel this is the 7th day of [*Marcheshvan*][HebrewMonth.CHESHVAN] (so the 6th will return true). Outside Israel recitation starts on the evening
 * of December 4th (or 5th if it is the year before a civil leap year) in the 21st century and shifts a
 * day forward every century not evenly divisible by 400. *Vesein tal umatar* is not recited on
 * *Shabbos* and the start date will be delayed a day when the start day is on a *Shabbos*
 * (this can only occur out of Israel).
 *
 * @param jewishCalendar the Jewish calendar day.
 *
 * @return true if it is the first Jewish day (starting the prior evening of reciting *Vesein Tal Umatar
 * Livracha* (*Sheailas Geshamim*).
 *
 * @see isVeseinTalUmatarStartDate TODO seems like these can be dried up
 * @see isVeseinTalUmatarRecited
 */
- (BOOL)isVeseinTalUmatarStartingTonightJewishCalendar:(STTJewishCalendar *)jewishCalendar __attribute__((swift_name("isVeseinTalUmatarStartingTonight(jewishCalendar:)")));

/**
 * Returns if *Yaaleh Veyavo* is recited on the day in question.
 *
 * @param jewishCalendar the Jewish calendar day.
 * @return if *Yaaleh Veyavo* is recited.
 * @see JewishCalendar.isPesach
 * @see JewishCalendar.isShavuos
 * @see JewishCalendar.isRoshHashana
 * @see JewishCalendar.isYomKippur
 * @see JewishCalendar.isSuccos
 * @see JewishCalendar.isShminiAtzeres
 * @see JewishCalendar.isSimchasTorah
 * @see JewishCalendar.isRoshChodesh
 */
- (BOOL)isYaalehVeyavoRecitedJewishCalendar:(STTJewishCalendar *)jewishCalendar __attribute__((swift_name("isYaalehVeyavoRecited(jewishCalendar:)")));

/**
 * Is *tachanun* is recited on the 13th of [*Sivan*][HebrewMonth.SIVAN] ([*Yom Tov Sheni shel Galuyos*](https://en.wikipedia.org/wiki/Yom_tov_sheni_shel_galuyot) of the 7th
 * day) outside Israel. This is brought down by the Shaarie Teshuva 131:19 quoting the [Sheyarei Kneses Hagedola 131:12](https://hebrewbooks.org/pdfpager.aspx?req=41295&st=&pgnum=39)that
 * *tachanun* should not be recited on this day. Rav Shlomo Zalman Orbach in Halichos Shlomo on
 * Shavuos 12:16:25 is of the opinion that even in *chutz laaretz* it should be recited since the *yemei
 * Tashlumin* are counted based on Israel since that is where the *karbanos* are brought. Both
 * [isTachanunRecitedShacharis] and [isTachanunRecitedMincha]
 * only return false if the location is not set to [Israel][JewishCalendar.getInIsrael] and both
 * [isTachanunRecitedWeekAfterShavuos] and [isTachanunRecited13SivanOutOfIsrael] are set to false.
 *
 * @return If *tachanun* is set to be recited on the 13th of [*Sivan*][HebrewMonth.SIVAN] out of Israel.
 * @see isTachanunRecited13SivanOutOfIsrael
 * @see isTachanunRecitedWeekAfterShavuos
 */
@property BOOL isTachanunRecited13SivanOutOfIsrael __attribute__((swift_name("isTachanunRecited13SivanOutOfIsrael")));

/**
 * Is *tachanun* recited on 15 [*Iyar*][HebrewMonth.IYAR] (*sfaika deyoma* of [*Pesach Sheni*][JewishCalendar.PESACH_SHENI]) out of Israel. If [isTachanunRecitedPesachSheni] is `true` this will be
 * ignored even if `false`.
 *
 * @return if *tachanun* is recited on 15 [*Iyar*][HebrewMonth.IYAR]  (*sfaika deyoma* of [*Pesach Sheni*][JewishCalendar.PESACH_SHENI] out of Israel. If [isTachanunRecitedPesachSheni]
 * is `true` this will be ignored even if `false`.
 * @see isTachanunRecited15IyarOutOfIsrael
 * @see isTachanunRecitedPesachSheni
 * @see isTachanunRecitedPesachSheni
 */
@property BOOL isTachanunRecited15IyarOutOfIsrael __attribute__((swift_name("isTachanunRecited15IyarOutOfIsrael")));

/**
 * Is *tachanun* recited at the end Of [*Tishrei*][HebrewMonth.TISHREI].The Magen Avraham 669:1 and the Pri
 * Chadash 131:7 state that some places to not recite *tachanun* during this period. The Sh"UT Chasam Sofer on Choshen
 * Mishpat 77 writes that this is the *minhag* in Ashkenaz. The Shaarei Teshuva 131:19 quotes the Sheyarie Kneses
 * Hagdola who also states that it should not be recited. The Aderes wanted to institute saying *tachanun* during this
 * period, but was dissuaded from this by Rav Shmuel Salant who did not want to change the *minhag* in Yerushalayim.
 * The Aruch Hashulchan is of the opinion that that this *minhag* is incorrect, and it should be recited, and The Chazon
 * Ish also recited *tachanun* during this period. See the Dirshu edition of the Mishna Berurah for details.
 * @return If *tachanun* is set to be recited at the end of [*Tishrei*][HebrewMonth.TISHREI].
 */
@property BOOL isTachanunRecitedEndOfTishrei __attribute__((swift_name("isTachanunRecitedEndOfTishrei")));

/**
 * The default value is `true`.
 * @see .isTachanunRecitedFridays
 * @see .setTachanunRecitedFridays
 */
@property BOOL isTachanunRecitedFridays __attribute__((swift_name("isTachanunRecitedFridays")));

/**
 * The default value is `true`.
 * @see .isTachanunRecitedMinchaAllYear
 * @see .setTachanunRecitedMinchaAllYear
 */
@property BOOL isTachanunRecitedMinchaAllYear __attribute__((swift_name("isTachanunRecitedMinchaAllYear")));

/**
 * Is *tachanun* recited on *mincha* on *erev [Lag Baomer][JewishCalendar.LAG_BAOMER]*.
 * @return if *tachanun* is recited in *mincha* on *erev*
 * [*Lag Baomer*][JewishCalendar.LAG_BAOMER].
 * @see setTachanunRecitedMinchaErevLagBaomer
 */
@property BOOL isTachanunRecitedMinchaErevLagBaomer __attribute__((swift_name("isTachanunRecitedMinchaErevLagBaomer")));

/**
 * Is *tachanun* recited on [*Pesach Sheni*][JewishCalendar.PESACH_SHENI]. The Pri Chadash 131:7 states
 * that *tachanun* should not be recited. The Aruch Hashulchan states that this is the minhag of the *sephardim*.
 * the Shaarei Efraim 10:27 also mentions that it is not recited, as does the Siddur Yaavetz (Shaar Hayesod, Chodesh Iyar).
 * The Pri Megadim (Mishbetzes Hazahav 131:15) and the Chazon Ish (Erev Pesahc Shchal Beshabos, page 203 in [Rav Sheraya
 * Devlitzky's](https://he.wikipedia.org/wiki/%D7%A9%D7%A8%D7%99%D7%94_%D7%93%D7%91%D7%9C%D7%99%D7%A6%D7%A7%D7%99) comments).
 *
 * @return If *tachanun* is recited on [*Pesach Sheni*][JewishCalendar.PESACH_SHENI].
 */
@property BOOL isTachanunRecitedPesachSheni __attribute__((swift_name("isTachanunRecitedPesachSheni")));

/**
 * Is *tachanun* recited during the *Shivas Yemei Hamiluim*, from the 23 of [HebrewMonth.ADAR] on a non-leap-year or [*Adar II*][HebrewMonth.ADAR_II] on a
 * leap year to the end of the month. Some *chasidishe* communities do not say *tachanun*
 * during this week. See [Darkei Chaim Veshalom 191](https://hebrewbooks.org/pdfpager.aspx?req=4692&st=&pgnum=70).
 * @return if *tachanun* is recited during the *Shivas Yemei Hamiluim*, from the 23 of [HebrewMonth.ADAR] on a non-leap-year or [*Adar II*][HebrewMonth.ADAR_II]
 * on a leap year to the end of the month.
 * @see isTachanunRecitedShivasYemeiHamiluim
 */
@property BOOL isTachanunRecitedShivasYemeiHamiluim __attribute__((swift_name("isTachanunRecitedShivasYemeiHamiluim")));

/**
 * The default value is `true`.
 * @see .isTachanunRecitedSundays
 * @see .setTachanunRecitedSundays
 */
@property BOOL isTachanunRecitedSundays __attribute__((swift_name("isTachanunRecitedSundays")));

/**
 * Is *tachanun* recited during the week after *Shavuos*. This is the opinion of the Pri Megadim
 * quoted by the Mishna Berurah. This is since *karbanos* of *Shavuos* have *tashlumim* for
 * 7 days, it is still considered like a Yom Tov. The Chazon Ish quoted in the Orchos Rabainu vol. 1 page 68
 * recited *tachanun* during this week.
 *
 * @return If *tachanun* is set to be recited during the week after Shavuos.
 */
@property BOOL isTachanunRecitedWeekAfterShavuos __attribute__((swift_name("isTachanunRecitedWeekAfterShavuos")));

/**
 * Is *tachanun* recited during the *sefira* week of *Hod* (14 - 20 [*Iyar*][HebrewMonth.IYAR],
 * or the 29th - 35th of the [*Omer*][JewishCalendar.getDayOfOmer]). Some *chasidishe* communities
 * do not recite *tachanun* during this week. See Minhag Yisrael Torah 131:Iyar.
 * @return If *tachanun* is set to be recited during the *sefira* week of *Hod* (14 - 20 [HebrewMonth.IYAR], or the 29th - 35th of the [*Omer*][JewishCalendar.dayOfOmer]).
 * @see isTachanunRecitedWeekOfHod
 */
@property BOOL isTachanunRecitedWeekOfHod __attribute__((swift_name("isTachanunRecitedWeekOfHod")));

/**
 * The default value is `true`.
 * @see .isTachanunRecitedWeekOfPurim
 * @see .setTachanunRecitedWeekOfPurim
 */
@property BOOL isTachanunRecitedWeekOfPurim __attribute__((swift_name("isTachanunRecitedWeekOfPurim")));
@end


/**
 * This class calculates the [Talmud Yerusalmi](https://en.wikipedia.org/wiki/Jerusalem_Talmud) [Daf Yomi](https://en.wikipedia.org/wiki/Daf_Yomi) page ([Daf]) for the a given date.
 *
 * @author  elihaidv
 * @author  Eliyahu Hershfeld 2017 - 2023
 */
__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("YerushalmiYomiCalculator")))
@interface STTYerushalmiYomiCalculator : STTBase
+ (instancetype)alloc __attribute__((unavailable));

/**
 * This class calculates the [Talmud Yerusalmi](https://en.wikipedia.org/wiki/Jerusalem_Talmud) [Daf Yomi](https://en.wikipedia.org/wiki/Daf_Yomi) page ([Daf]) for the a given date.
 *
 * @author  elihaidv
 * @author  Eliyahu Hershfeld 2017 - 2023
 */
+ (instancetype)allocWithZone:(struct _NSZone *)zone __attribute__((unavailable));
+ (instancetype)yerushalmiYomiCalculator __attribute__((swift_name("init()")));
@property (class, readonly, getter=shared) STTYerushalmiYomiCalculator *shared __attribute__((swift_name("shared")));

/**
 * Returns the [Daf Yomi](https://en.wikipedia.org/wiki/Daf_Yomi)
 * [Yerusalmi](https://en.wikipedia.org/wiki/Jerusalem_Talmud) page ([Daf]) for a given date.
 * The first Daf Yomi cycle started on 15 Shevat (Tu Bishvat), 5740 (February, 2, 1980) and calculations
 * prior to this date will result in an IllegalArgumentException thrown. A null will be returned on Tisha B'Av or
 * Yom Kippur.
 *
 * @param calendar
 * the calendar date for calculation
 * @return the [Daf] or null if the date is on Tisha B'Av or Yom Kippur.
 *
 * @throws IllegalArgumentException
 * if the date is prior to the February 2, 1980, the start of the first Daf Yomi Yerushalmi cycle
 */
- (STTDaf * _Nullable)getDafYomiYerushalmiCalendar:(STTJewishCalendar *)calendar __attribute__((swift_name("getDafYomiYerushalmi(calendar:)")));
@property STTKotlinx_datetimeTimeZone *timeZone __attribute__((swift_name("timeZone")));
@end


/**
 * This class calculates the Daf Yomi Bavli page (daf) for a given date. To calculate Daf Yomi Yerushalmi
 * use the [YerushalmiYomiCalculator]. The library may cover Mishna Yomi etc. at some point in the future.
 *
 * @author  Bob Newell (original C code)
 * @author  Eliyahu Hershfeld 2011 - 2020
 */
__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("YomiCalculator")))
@interface STTYomiCalculator : STTBase
+ (instancetype)alloc __attribute__((unavailable));

/**
 * This class calculates the Daf Yomi Bavli page (daf) for a given date. To calculate Daf Yomi Yerushalmi
 * use the [YerushalmiYomiCalculator]. The library may cover Mishna Yomi etc. at some point in the future.
 *
 * @author  Bob Newell (original C code)
 * @author  Eliyahu Hershfeld 2011 - 2020
 */
+ (instancetype)allocWithZone:(struct _NSZone *)zone __attribute__((unavailable));
+ (instancetype)yomiCalculator __attribute__((swift_name("init()")));
@property (class, readonly, getter=shared) STTYomiCalculator *shared __attribute__((swift_name("shared")));

/**
 * Returns the [Daf Yomi](http://en.wikipedia.org/wiki/Daf_yomi) [Bavli](http://en.wikipedia.org/wiki/Talmud) [Daf] for a given date. The first Daf Yomi cycle
 * started on Rosh Hashana 5684 (September 11, 1923) and calculations prior to this date will result in an
 * IllegalArgumentException thrown. For historical calculations (supported by this method), it is important to note
 * that a change in length of the cycle was instituted starting in the eighth Daf Yomi cycle beginning on June 24,
 * 1975. The Daf Yomi Bavli cycle has a single masechta of the Talmud Yerushalmi - Shekalim as part of the cycle.
 * Unlike the Bavli where the number of daf per masechta was standardized since the original [Bomberg Edition](http://en.wikipedia.org/wiki/Daniel_Bomberg) published from 1520 - 1523, there is no
 * uniform page length in the Yerushalmi. The early cycles had the Yerushalmi Shekalim length of 13 days following the
 * [Slavuta/Zhytomyr](https://he.wikipedia.org/wiki/%D7%93%D7%A4%D7%95%D7%A1_%D7%A1%D7%9C%D7%90%D7%95%D7%95%D7%99%D7%98%D7%90)
 * Shas used by [Rabbi Meir Shapiro](http://en.wikipedia.org/wiki/Meir_Shapiro). With the start of the eighth Daf Yomi
 * cycle beginning on June 24, 1975 the length of the Yerushalmi Shekalim was changed from 13 to 22 daf to follow
 * the [Vilna Shas](https://en.wikipedia.org/wiki/Vilna_Edition_Shas) that is in common use today.
 *
 * @param jewishCalendar
 * The JewishCalendar date for calculation. TODO: this can be changed to use a regular GregorianCalendar since
 * there is nothing specific to the JewishCalendar in this class.
 * @return the [Daf].
 *
 * @throws IllegalArgumentException
 * if the date is prior to the September 11, 1923 start date of the first Daf Yomi cycle
 */
- (STTDaf * _Nullable)getDafYomiBavliJewishCalendar:(STTJewishCalendar *)jewishCalendar __attribute__((swift_name("getDafYomiBavli(jewishCalendar:)")));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("Occurrence")))
@interface STTOccurrence : STTBase
- (instancetype)initWithSubject:(STTZmanType *)subject calculationMethod:(id<STTZmanCalculationMethod>)calculationMethod __attribute__((swift_name("init(subject:calculationMethod:)"))) __attribute__((objc_designated_initializer));

/**
 * Syntactic sugar for [after] ([zman].[definition][Zman.definition]).
 * */
- (STTZmanRelationship *)afterZman:(STTZman<id> *)zman __attribute__((swift_name("after(zman:)")));
- (STTZmanRelationship *)afterZmanDefinition:(STTZmanDefinition *)zmanDefinition __attribute__((swift_name("after(zmanDefinition:)")));
- (STTZmanRelationship *)afterZmanType:(STTZmanType *)zmanType __attribute__((swift_name("after(zmanType:)")));

/**
 * Syntactic sugar for [before] ([zman].[definition][Zman.definition]).
 * */
- (STTZmanRelationship *)beforeZman:(STTZman<id> *)zman __attribute__((swift_name("before(zman:)")));
- (STTZmanRelationship *)beforeZmanDefinition:(STTZmanDefinition *)zmanDefinition __attribute__((swift_name("before(zmanDefinition:)")));
- (STTZmanRelationship *)beforeZmanType:(STTZmanType *)zmanType __attribute__((swift_name("before(zmanType:)")));
- (STTOccurrence *)doCopySubject:(STTZmanType *)subject calculationMethod:(id<STTZmanCalculationMethod>)calculationMethod __attribute__((swift_name("doCopy(subject:calculationMethod:)")));
- (BOOL)isEqual:(id _Nullable)other __attribute__((swift_name("isEqual(_:)")));
- (NSUInteger)hash __attribute__((swift_name("hash()")));
- (NSString *)description __attribute__((swift_name("description()")));
@property (readonly) id<STTZmanCalculationMethod> calculationMethod __attribute__((swift_name("calculationMethod")));
@property (readonly) STTZmanType *subject __attribute__((swift_name("subject")));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("UsesElevation")))
@interface STTUsesElevation : STTKotlinEnum<STTUsesElevation *>
+ (instancetype)alloc __attribute__((unavailable));
+ (instancetype)allocWithZone:(struct _NSZone *)zone __attribute__((unavailable));
- (instancetype)initWithName:(NSString *)name ordinal:(int32_t)ordinal __attribute__((swift_name("init(name:ordinal:)"))) __attribute__((objc_designated_initializer)) __attribute__((unavailable));
@property (class, readonly) STTUsesElevation *ifSet __attribute__((swift_name("ifSet")));
@property (class, readonly) STTUsesElevation *never __attribute__((swift_name("never")));
@property (class, readonly) STTUsesElevation *always __attribute__((swift_name("always")));
@property (class, readonly) STTUsesElevation *unspecified __attribute__((swift_name("unspecified")));
+ (STTKotlinArray<STTUsesElevation *> *)values __attribute__((swift_name("values()")));
@property (class, readonly) NSArray<STTUsesElevation *> *entries __attribute__((swift_name("entries")));
@end


/**
 * An instance of this class represents a description for how a zman is calculated. The description may rely on other
 * information provided in the [ZmanDefinition] (e.g. whether the calculation changes depending on the [ComplexZmanimCalendar.isUseElevation] setting).
 *
 * *Why are there so many ways to calculate a zman?*
 * The length of a shaah zmanis (halachic/solar hour) is calculated based on the length of the day.
 * The definition of day has various opinions, and thus the length of a shaah zmanis varies.
 * One such definition is dusk to dawn.
 * Dawn can either be calculated as:
 * 1. a fixed number of minutes before sunrise,
 * 2. or as the moment that the sun reaches a number of degrees above the eastern geometric horizon - which happens before sunrise.
 *
 * Sunrise is an astronomical phenomenon, not subject to varying opinions (save for whether to adjust for elevation).
 * Dusk is often calculated as the inverse of dawn (i.e. after sunrise, and below the western geometric horizon),
 * though some opinions place it orthogonally to their definiition of dawn (e.g. [ZmanAuthority.AteretTorah] in [ComplexZmanimCalendar.shaahZmanisAteretTorah]).
 * The number of fixed minutes for sunrise/sunset is determined by the time it takes to walk the distance of a [*mil*][https://en.wikipedia.org/wiki/Biblical_mile].
 * Some interpret those fixed minutes (let M = minutes) as measured by the position of the sun in degrees relative to
 * the eastern geometric horizon M minutes before sunrise in Jerusalem [around the equinox / equilux](https://kosherjava.com/2022/01/12/equinox-vs-equilux-zmanim-calculations/).
 *
 * This is the distinction between the two aforementioned ways of calculating dawn.
 * Some measure by the length of time it takes to walk 4 mil, while others measure using 5 mil.
 * This is but one divergence of opinion in the calculation of shaah zmanis. Here are all of them:
 *  1. Fixed minutes or degrees?
 *      - Measure in fixed minutes or zmaniyos minutes?
 *  2. How many minutes does it take to walk a mil?
 *  3. Should a full mil be used to measure, or 3/4 of a mil?
 *  4. Multiply by 4 or 5 mil?
 *  5. Account for elevation or not?
 *  6. When does day start/end?
 *    - Dawn/dusk
 *    - sunrise/sunset (which are astronomical phenomena)
 *    - etc.
 * see [DayDefinition]
 *
 *
 * */
__attribute__((swift_name("ZmanCalculationMethod")))
@protocol STTZmanCalculationMethod
@required
- (NSString *)durationValueToString:(int64_t)receiver halachic:(BOOL)halachic __attribute__((swift_name("durationValueToString(_:halachic:)")));
- (NSString *)format __attribute__((swift_name("format()")));
- (NSString *)formatInEnglish:(BOOL)inEnglish __attribute__((swift_name("format(inEnglish:)")));
- (NSString *)formatSubjectZman:(NSString *)subjectZman zmanRelativeTo:(NSString *)zmanRelativeTo __attribute__((swift_name("format(subjectZman:zmanRelativeTo:)")));
- (NSString *)shortDescription __attribute__((swift_name("shortDescription()")));
- (NSString *)valueToString __attribute__((swift_name("valueToString()")));
@end


/**
 * A [ZmanAuthority] is also a [ZmanCalculationMethod] so that it is possible to say (for example) that
 * a zman calculated using [ZmanCalculationMethod.ZmaniyosDuration._72] for [ZmanType.ALOS] and [ZmanType.SHAA_ZMANIS] of the [ZmanAuthority.GRA].
 * This is because if the zman is based on [sha'os zmaniyos][ZmanType.SHAA_ZMANIS], it is unclear by what calculation
 * the sha'ah zmanis is calculated. And, sometimes authority's calculations cannot be easily described in terms of simple [ZmanCalculationMethod]s.
 * It is also more meaningful to the reader/end user that it uses the GRA's sha'ah zmanis rather than a calculation method.
 * */
__attribute__((swift_name("ZmanAuthority")))
@interface STTZmanAuthority : STTBase <STTZmanCalculationMethod>
- (instancetype)initWithName:(NSString *)name __attribute__((swift_name("init(name:)"))) __attribute__((objc_designated_initializer));
- (STTZmanAuthorityAccordingTo *)accordingToAccordingTo:(STTZmanAuthority *)accordingTo __attribute__((swift_name("accordingTo(accordingTo:)")));
- (NSString *)format __attribute__((swift_name("format()")));
- (NSString *)valueToString __attribute__((swift_name("valueToString()")));
@property (readonly) NSString *name __attribute__((swift_name("name")));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("ZmanAuthority.AHAVAT_SHALOM")))
@interface STTZmanAuthorityAHAVAT_SHALOM : STTZmanAuthority
+ (instancetype)alloc __attribute__((unavailable));
+ (instancetype)allocWithZone:(struct _NSZone *)zone __attribute__((unavailable));
- (instancetype)initWithName:(NSString *)name __attribute__((swift_name("init(name:)"))) __attribute__((objc_designated_initializer)) __attribute__((unavailable));
+ (instancetype)aHAVAT_SHALOM __attribute__((swift_name("init()")));
@property (class, readonly, getter=shared) STTZmanAuthorityAHAVAT_SHALOM *shared __attribute__((swift_name("shared")));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("ZmanAuthority.ARUCH_HASHULCHAN")))
@interface STTZmanAuthorityARUCH_HASHULCHAN : STTZmanAuthority
+ (instancetype)alloc __attribute__((unavailable));
+ (instancetype)allocWithZone:(struct _NSZone *)zone __attribute__((unavailable));
- (instancetype)initWithName:(NSString *)name __attribute__((swift_name("init(name:)"))) __attribute__((objc_designated_initializer)) __attribute__((unavailable));
+ (instancetype)aRUCH_HASHULCHAN __attribute__((swift_name("init()")));
@property (class, readonly, getter=shared) STTZmanAuthorityARUCH_HASHULCHAN *shared __attribute__((swift_name("shared")));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("ZmanAuthority.AccordingTo")))
@interface STTZmanAuthorityAccordingTo : STTZmanAuthority
- (instancetype)initWithAuthority:(STTZmanAuthority * _Nullable)authority accordingTo:(STTZmanAuthority *)accordingTo calculationMethod:(id<STTZmanCalculationMethod> _Nullable)calculationMethod __attribute__((swift_name("init(authority:accordingTo:calculationMethod:)"))) __attribute__((objc_designated_initializer));
- (instancetype)initWithName:(NSString *)name __attribute__((swift_name("init(name:)"))) __attribute__((objc_designated_initializer)) __attribute__((unavailable));
- (STTZmanAuthorityAccordingTo *)doCopyAuthority:(STTZmanAuthority * _Nullable)authority accordingTo:(STTZmanAuthority *)accordingTo calculationMethod:(id<STTZmanCalculationMethod> _Nullable)calculationMethod __attribute__((swift_name("doCopy(authority:accordingTo:calculationMethod:)")));
- (BOOL)isEqual:(id _Nullable)other __attribute__((swift_name("isEqual(_:)")));
- (NSUInteger)hash __attribute__((swift_name("hash()")));
- (NSString *)description __attribute__((swift_name("description()")));
@property (readonly) STTZmanAuthority *accordingTo __attribute__((swift_name("accordingTo")));
@property (readonly) STTZmanAuthority * _Nullable authority __attribute__((swift_name("authority")));
@property (readonly) id<STTZmanCalculationMethod> _Nullable calculationMethod __attribute__((swift_name("calculationMethod")));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("ZmanAuthority.AteretTorah")))
@interface STTZmanAuthorityAteretTorah : STTZmanAuthority
- (instancetype)initWithMinutes:(double)minutes __attribute__((swift_name("init(minutes:)"))) __attribute__((objc_designated_initializer));
- (instancetype)initWithName:(NSString *)name __attribute__((swift_name("init(name:)"))) __attribute__((objc_designated_initializer)) __attribute__((unavailable));
- (STTZmanAuthorityAteretTorah *)doCopyMinutes:(double)minutes __attribute__((swift_name("doCopy(minutes:)")));
- (BOOL)isEqual:(id _Nullable)other __attribute__((swift_name("isEqual(_:)")));
- (NSUInteger)hash __attribute__((swift_name("hash()")));
- (NSString *)description __attribute__((swift_name("description()")));
@property (readonly) double minutes __attribute__((swift_name("minutes")));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("ZmanAuthority.BAAL_HATANYA")))
@interface STTZmanAuthorityBAAL_HATANYA : STTZmanAuthority
+ (instancetype)alloc __attribute__((unavailable));
+ (instancetype)allocWithZone:(struct _NSZone *)zone __attribute__((unavailable));
- (instancetype)initWithName:(NSString *)name __attribute__((swift_name("init(name:)"))) __attribute__((objc_designated_initializer)) __attribute__((unavailable));
+ (instancetype)bAAL_HATANYA __attribute__((swift_name("init()")));
@property (class, readonly, getter=shared) STTZmanAuthorityBAAL_HATANYA *shared __attribute__((swift_name("shared")));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("ZmanAuthority.BICK")))
@interface STTZmanAuthorityBICK : STTZmanAuthority
+ (instancetype)alloc __attribute__((unavailable));
+ (instancetype)allocWithZone:(struct _NSZone *)zone __attribute__((unavailable));
- (instancetype)initWithName:(NSString *)name __attribute__((swift_name("init(name:)"))) __attribute__((objc_designated_initializer)) __attribute__((unavailable));
+ (instancetype)bICK __attribute__((swift_name("init()")));
@property (class, readonly, getter=shared) STTZmanAuthorityBICK *shared __attribute__((swift_name("shared")));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("ZmanAuthority.CHASSAN_SOFER")))
@interface STTZmanAuthorityCHASSAN_SOFER : STTZmanAuthority
+ (instancetype)alloc __attribute__((unavailable));
+ (instancetype)allocWithZone:(struct _NSZone *)zone __attribute__((unavailable));
- (instancetype)initWithName:(NSString *)name __attribute__((swift_name("init(name:)"))) __attribute__((objc_designated_initializer)) __attribute__((unavailable));
+ (instancetype)cHASSAN_SOFER __attribute__((swift_name("init()")));
@property (class, readonly, getter=shared) STTZmanAuthorityCHASSAN_SOFER *shared __attribute__((swift_name("shared")));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("ZmanAuthority.CHAVAS_YAIR")))
@interface STTZmanAuthorityCHAVAS_YAIR : STTZmanAuthority
+ (instancetype)alloc __attribute__((unavailable));
+ (instancetype)allocWithZone:(struct _NSZone *)zone __attribute__((unavailable));
- (instancetype)initWithName:(NSString *)name __attribute__((swift_name("init(name:)"))) __attribute__((objc_designated_initializer)) __attribute__((unavailable));
+ (instancetype)cHAVAS_YAIR __attribute__((swift_name("init()")));
@property (class, readonly, getter=shared) STTZmanAuthorityCHAVAS_YAIR *shared __attribute__((swift_name("shared")));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("ZmanAuthority.DIVREI_MALKIEL")))
@interface STTZmanAuthorityDIVREI_MALKIEL : STTZmanAuthority
+ (instancetype)alloc __attribute__((unavailable));
+ (instancetype)allocWithZone:(struct _NSZone *)zone __attribute__((unavailable));
- (instancetype)initWithName:(NSString *)name __attribute__((swift_name("init(name:)"))) __attribute__((objc_designated_initializer)) __attribute__((unavailable));
+ (instancetype)dIVREI_MALKIEL __attribute__((swift_name("init()")));
@property (class, readonly, getter=shared) STTZmanAuthorityDIVREI_MALKIEL *shared __attribute__((swift_name("shared")));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("ZmanAuthority.DIVREI_YOSEF")))
@interface STTZmanAuthorityDIVREI_YOSEF : STTZmanAuthority
+ (instancetype)alloc __attribute__((unavailable));
+ (instancetype)allocWithZone:(struct _NSZone *)zone __attribute__((unavailable));
- (instancetype)initWithName:(NSString *)name __attribute__((swift_name("init(name:)"))) __attribute__((objc_designated_initializer)) __attribute__((unavailable));
+ (instancetype)dIVREI_YOSEF __attribute__((swift_name("init()")));
@property (class, readonly, getter=shared) STTZmanAuthorityDIVREI_YOSEF *shared __attribute__((swift_name("shared")));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("ZmanAuthority.EDELSTEIN")))
@interface STTZmanAuthorityEDELSTEIN : STTZmanAuthority
+ (instancetype)alloc __attribute__((unavailable));
+ (instancetype)allocWithZone:(struct _NSZone *)zone __attribute__((unavailable));
- (instancetype)initWithName:(NSString *)name __attribute__((swift_name("init(name:)"))) __attribute__((objc_designated_initializer)) __attribute__((unavailable));
+ (instancetype)eDELSTEIN __attribute__((swift_name("init()")));
@property (class, readonly, getter=shared) STTZmanAuthorityEDELSTEIN *shared __attribute__((swift_name("shared")));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("ZmanAuthority.EIDOT_HAMIZRACH")))
@interface STTZmanAuthorityEIDOT_HAMIZRACH : STTZmanAuthority
+ (instancetype)alloc __attribute__((unavailable));
+ (instancetype)allocWithZone:(struct _NSZone *)zone __attribute__((unavailable));
- (instancetype)initWithName:(NSString *)name __attribute__((swift_name("init(name:)"))) __attribute__((objc_designated_initializer)) __attribute__((unavailable));
+ (instancetype)eIDOT_HAMIZRACH __attribute__((swift_name("init()")));
@property (class, readonly, getter=shared) STTZmanAuthorityEIDOT_HAMIZRACH *shared __attribute__((swift_name("shared")));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("ZmanAuthority.FEINSTEIN")))
@interface STTZmanAuthorityFEINSTEIN : STTZmanAuthority
+ (instancetype)alloc __attribute__((unavailable));
+ (instancetype)allocWithZone:(struct _NSZone *)zone __attribute__((unavailable));
- (instancetype)initWithName:(NSString *)name __attribute__((swift_name("init(name:)"))) __attribute__((objc_designated_initializer)) __attribute__((unavailable));
+ (instancetype)fEINSTEIN __attribute__((swift_name("init()")));
@property (class, readonly, getter=shared) STTZmanAuthorityFEINSTEIN *shared __attribute__((swift_name("shared")));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("ZmanAuthority.GEONIM")))
@interface STTZmanAuthorityGEONIM : STTZmanAuthority
+ (instancetype)alloc __attribute__((unavailable));
+ (instancetype)allocWithZone:(struct _NSZone *)zone __attribute__((unavailable));
- (instancetype)initWithName:(NSString *)name __attribute__((swift_name("init(name:)"))) __attribute__((objc_designated_initializer)) __attribute__((unavailable));
+ (instancetype)gEONIM __attribute__((swift_name("init()")));
@property (class, readonly, getter=shared) STTZmanAuthorityGEONIM *shared __attribute__((swift_name("shared")));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("ZmanAuthority.GRA")))
@interface STTZmanAuthorityGRA : STTZmanAuthority
+ (instancetype)alloc __attribute__((unavailable));
+ (instancetype)allocWithZone:(struct _NSZone *)zone __attribute__((unavailable));
- (instancetype)initWithName:(NSString *)name __attribute__((swift_name("init(name:)"))) __attribute__((objc_designated_initializer)) __attribute__((unavailable));
+ (instancetype)gRA __attribute__((swift_name("init()")));
@property (class, readonly, getter=shared) STTZmanAuthorityGRA *shared __attribute__((swift_name("shared")));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("ZmanAuthority.GREENWALD")))
@interface STTZmanAuthorityGREENWALD : STTZmanAuthority
+ (instancetype)alloc __attribute__((unavailable));
+ (instancetype)allocWithZone:(struct _NSZone *)zone __attribute__((unavailable));
- (instancetype)initWithName:(NSString *)name __attribute__((swift_name("init(name:)"))) __attribute__((objc_designated_initializer)) __attribute__((unavailable));
+ (instancetype)gREENWALD __attribute__((swift_name("init()")));
@property (class, readonly, getter=shared) STTZmanAuthorityGREENWALD *shared __attribute__((swift_name("shared")));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("ZmanAuthority.HISACHDUS_HARABONIM")))
@interface STTZmanAuthorityHISACHDUS_HARABONIM : STTZmanAuthority
+ (instancetype)alloc __attribute__((unavailable));
+ (instancetype)allocWithZone:(struct _NSZone *)zone __attribute__((unavailable));
- (instancetype)initWithName:(NSString *)name __attribute__((swift_name("init(name:)"))) __attribute__((objc_designated_initializer)) __attribute__((unavailable));
+ (instancetype)hISACHDUS_HARABONIM __attribute__((swift_name("init()")));
@property (class, readonly, getter=shared) STTZmanAuthorityHISACHDUS_HARABONIM *shared __attribute__((swift_name("shared")));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("ZmanAuthority.KAMENETSKY")))
@interface STTZmanAuthorityKAMENETSKY : STTZmanAuthority
+ (instancetype)alloc __attribute__((unavailable));
+ (instancetype)allocWithZone:(struct _NSZone *)zone __attribute__((unavailable));
- (instancetype)initWithName:(NSString *)name __attribute__((swift_name("init(name:)"))) __attribute__((objc_designated_initializer)) __attribute__((unavailable));
+ (instancetype)kAMENETSKY __attribute__((swift_name("init()")));
@property (class, readonly, getter=shared) STTZmanAuthorityKAMENETSKY *shared __attribute__((swift_name("shared")));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("ZmanAuthority.KOMARNO")))
@interface STTZmanAuthorityKOMARNO : STTZmanAuthority
+ (instancetype)alloc __attribute__((unavailable));
+ (instancetype)allocWithZone:(struct _NSZone *)zone __attribute__((unavailable));
- (instancetype)initWithName:(NSString *)name __attribute__((swift_name("init(name:)"))) __attribute__((objc_designated_initializer)) __attribute__((unavailable));
+ (instancetype)kOMARNO __attribute__((swift_name("init()")));
@property (class, readonly, getter=shared) STTZmanAuthorityKOMARNO *shared __attribute__((swift_name("shared")));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("ZmanAuthority.KRONGLASS")))
@interface STTZmanAuthorityKRONGLASS : STTZmanAuthority
+ (instancetype)alloc __attribute__((unavailable));
+ (instancetype)allocWithZone:(struct _NSZone *)zone __attribute__((unavailable));
- (instancetype)initWithName:(NSString *)name __attribute__((swift_name("init(name:)"))) __attribute__((objc_designated_initializer)) __attribute__((unavailable));
+ (instancetype)kRONGLASS __attribute__((swift_name("init()")));
@property (class, readonly, getter=shared) STTZmanAuthorityKRONGLASS *shared __attribute__((swift_name("shared")));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("ZmanAuthority.LECHEM_MISHNAH")))
@interface STTZmanAuthorityLECHEM_MISHNAH : STTZmanAuthority
+ (instancetype)alloc __attribute__((unavailable));
+ (instancetype)allocWithZone:(struct _NSZone *)zone __attribute__((unavailable));
- (instancetype)initWithName:(NSString *)name __attribute__((swift_name("init(name:)"))) __attribute__((objc_designated_initializer)) __attribute__((unavailable));
+ (instancetype)lECHEM_MISHNAH __attribute__((swift_name("init()")));
@property (class, readonly, getter=shared) STTZmanAuthorityLECHEM_MISHNAH *shared __attribute__((swift_name("shared")));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("ZmanAuthority.MAAGALEI_TZEDEK")))
@interface STTZmanAuthorityMAAGALEI_TZEDEK : STTZmanAuthority
+ (instancetype)alloc __attribute__((unavailable));
+ (instancetype)allocWithZone:(struct _NSZone *)zone __attribute__((unavailable));
- (instancetype)initWithName:(NSString *)name __attribute__((swift_name("init(name:)"))) __attribute__((objc_designated_initializer)) __attribute__((unavailable));
+ (instancetype)mAAGALEI_TZEDEK __attribute__((swift_name("init()")));
@property (class, readonly, getter=shared) STTZmanAuthorityMAAGALEI_TZEDEK *shared __attribute__((swift_name("shared")));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("ZmanAuthority.MACHATZIS_HASHEKEL")))
@interface STTZmanAuthorityMACHATZIS_HASHEKEL : STTZmanAuthority
+ (instancetype)alloc __attribute__((unavailable));
+ (instancetype)allocWithZone:(struct _NSZone *)zone __attribute__((unavailable));
- (instancetype)initWithName:(NSString *)name __attribute__((swift_name("init(name:)"))) __attribute__((objc_designated_initializer)) __attribute__((unavailable));
+ (instancetype)mACHATZIS_HASHEKEL __attribute__((swift_name("init()")));
@property (class, readonly, getter=shared) STTZmanAuthorityMACHATZIS_HASHEKEL *shared __attribute__((swift_name("shared")));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("ZmanAuthority.MAHARIK")))
@interface STTZmanAuthorityMAHARIK : STTZmanAuthority
+ (instancetype)alloc __attribute__((unavailable));
+ (instancetype)allocWithZone:(struct _NSZone *)zone __attribute__((unavailable));
- (instancetype)initWithName:(NSString *)name __attribute__((swift_name("init(name:)"))) __attribute__((objc_designated_initializer)) __attribute__((unavailable));
+ (instancetype)mAHARIK __attribute__((swift_name("init()")));
@property (class, readonly, getter=shared) STTZmanAuthorityMAHARIK *shared __attribute__((swift_name("shared")));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("ZmanAuthority.MAHARIL")))
@interface STTZmanAuthorityMAHARIL : STTZmanAuthority
+ (instancetype)alloc __attribute__((unavailable));
+ (instancetype)allocWithZone:(struct _NSZone *)zone __attribute__((unavailable));
- (instancetype)initWithName:(NSString *)name __attribute__((swift_name("init(name:)"))) __attribute__((objc_designated_initializer)) __attribute__((unavailable));
+ (instancetype)mAHARIL __attribute__((swift_name("init()")));
@property (class, readonly, getter=shared) STTZmanAuthorityMAHARIL *shared __attribute__((swift_name("shared")));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("ZmanAuthority.MGA")))
@interface STTZmanAuthorityMGA : STTZmanAuthority
+ (instancetype)alloc __attribute__((unavailable));
+ (instancetype)allocWithZone:(struct _NSZone *)zone __attribute__((unavailable));
- (instancetype)initWithName:(NSString *)name __attribute__((swift_name("init(name:)"))) __attribute__((objc_designated_initializer)) __attribute__((unavailable));
+ (instancetype)mGA __attribute__((swift_name("init()")));
@property (class, readonly, getter=shared) STTZmanAuthorityMGA *shared __attribute__((swift_name("shared")));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("ZmanAuthority.MINCHAS_COHEN")))
@interface STTZmanAuthorityMINCHAS_COHEN : STTZmanAuthority
+ (instancetype)alloc __attribute__((unavailable));
+ (instancetype)allocWithZone:(struct _NSZone *)zone __attribute__((unavailable));
- (instancetype)initWithName:(NSString *)name __attribute__((swift_name("init(name:)"))) __attribute__((objc_designated_initializer)) __attribute__((unavailable));
+ (instancetype)mINCHAS_COHEN __attribute__((swift_name("init()")));
@property (class, readonly, getter=shared) STTZmanAuthorityMINCHAS_COHEN *shared __attribute__((swift_name("shared")));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("ZmanAuthority.NEIMAN")))
@interface STTZmanAuthorityNEIMAN : STTZmanAuthority
+ (instancetype)alloc __attribute__((unavailable));
+ (instancetype)allocWithZone:(struct _NSZone *)zone __attribute__((unavailable));
- (instancetype)initWithName:(NSString *)name __attribute__((swift_name("init(name:)"))) __attribute__((objc_designated_initializer)) __attribute__((unavailable));
+ (instancetype)nEIMAN __attribute__((swift_name("init()")));
@property (class, readonly, getter=shared) STTZmanAuthorityNEIMAN *shared __attribute__((swift_name("shared")));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("ZmanAuthority.POSEN")))
@interface STTZmanAuthorityPOSEN : STTZmanAuthority
+ (instancetype)alloc __attribute__((unavailable));
+ (instancetype)allocWithZone:(struct _NSZone *)zone __attribute__((unavailable));
- (instancetype)initWithName:(NSString *)name __attribute__((swift_name("init(name:)"))) __attribute__((objc_designated_initializer)) __attribute__((unavailable));
+ (instancetype)pOSEN __attribute__((swift_name("init()")));
@property (class, readonly, getter=shared) STTZmanAuthorityPOSEN *shared __attribute__((swift_name("shared")));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("ZmanAuthority.PRI_MEGADIM")))
@interface STTZmanAuthorityPRI_MEGADIM : STTZmanAuthority
+ (instancetype)alloc __attribute__((unavailable));
+ (instancetype)allocWithZone:(struct _NSZone *)zone __attribute__((unavailable));
- (instancetype)initWithName:(NSString *)name __attribute__((swift_name("init(name:)"))) __attribute__((objc_designated_initializer)) __attribute__((unavailable));
+ (instancetype)pRI_MEGADIM __attribute__((swift_name("init()")));
@property (class, readonly, getter=shared) STTZmanAuthorityPRI_MEGADIM *shared __attribute__((swift_name("shared")));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("ZmanAuthority.RAAVAN")))
@interface STTZmanAuthorityRAAVAN : STTZmanAuthority
+ (instancetype)alloc __attribute__((unavailable));
+ (instancetype)allocWithZone:(struct _NSZone *)zone __attribute__((unavailable));
- (instancetype)initWithName:(NSString *)name __attribute__((swift_name("init(name:)"))) __attribute__((objc_designated_initializer)) __attribute__((unavailable));
+ (instancetype)rAAVAN __attribute__((swift_name("init()")));
@property (class, readonly, getter=shared) STTZmanAuthorityRAAVAN *shared __attribute__((swift_name("shared")));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("ZmanAuthority.RABEINU_TAM")))
@interface STTZmanAuthorityRABEINU_TAM : STTZmanAuthority
+ (instancetype)alloc __attribute__((unavailable));
+ (instancetype)allocWithZone:(struct _NSZone *)zone __attribute__((unavailable));
- (instancetype)initWithName:(NSString *)name __attribute__((swift_name("init(name:)"))) __attribute__((objc_designated_initializer)) __attribute__((unavailable));
+ (instancetype)rABEINU_TAM __attribute__((swift_name("init()")));
@property (class, readonly, getter=shared) STTZmanAuthorityRABEINU_TAM *shared __attribute__((swift_name("shared")));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("ZmanAuthority.RABEINU_YONAH")))
@interface STTZmanAuthorityRABEINU_YONAH : STTZmanAuthority
+ (instancetype)alloc __attribute__((unavailable));
+ (instancetype)allocWithZone:(struct _NSZone *)zone __attribute__((unavailable));
- (instancetype)initWithName:(NSString *)name __attribute__((swift_name("init(name:)"))) __attribute__((objc_designated_initializer)) __attribute__((unavailable));
+ (instancetype)rABEINU_YONAH __attribute__((swift_name("init()")));
@property (class, readonly, getter=shared) STTZmanAuthorityRABEINU_YONAH *shared __attribute__((swift_name("shared")));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("ZmanAuthority.RAMBAM")))
@interface STTZmanAuthorityRAMBAM : STTZmanAuthority
+ (instancetype)alloc __attribute__((unavailable));
+ (instancetype)allocWithZone:(struct _NSZone *)zone __attribute__((unavailable));
- (instancetype)initWithName:(NSString *)name __attribute__((swift_name("init(name:)"))) __attribute__((objc_designated_initializer)) __attribute__((unavailable));
+ (instancetype)rAMBAM __attribute__((swift_name("init()")));
@property (class, readonly, getter=shared) STTZmanAuthorityRAMBAM *shared __attribute__((swift_name("shared")));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("ZmanAuthority.RAZEH")))
@interface STTZmanAuthorityRAZEH : STTZmanAuthority
+ (instancetype)alloc __attribute__((unavailable));
+ (instancetype)allocWithZone:(struct _NSZone *)zone __attribute__((unavailable));
- (instancetype)initWithName:(NSString *)name __attribute__((swift_name("init(name:)"))) __attribute__((objc_designated_initializer)) __attribute__((unavailable));
+ (instancetype)rAZEH __attribute__((swift_name("init()")));
@property (class, readonly, getter=shared) STTZmanAuthorityRAZEH *shared __attribute__((swift_name("shared")));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("ZmanAuthority.SATMER")))
@interface STTZmanAuthoritySATMER : STTZmanAuthority
+ (instancetype)alloc __attribute__((unavailable));
+ (instancetype)allocWithZone:(struct _NSZone *)zone __attribute__((unavailable));
- (instancetype)initWithName:(NSString *)name __attribute__((swift_name("init(name:)"))) __attribute__((objc_designated_initializer)) __attribute__((unavailable));
+ (instancetype)sATMER __attribute__((swift_name("init()")));
@property (class, readonly, getter=shared) STTZmanAuthoritySATMER *shared __attribute__((swift_name("shared")));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("ZmanAuthority.SHACH")))
@interface STTZmanAuthoritySHACH : STTZmanAuthority
+ (instancetype)alloc __attribute__((unavailable));
+ (instancetype)allocWithZone:(struct _NSZone *)zone __attribute__((unavailable));
- (instancetype)initWithName:(NSString *)name __attribute__((swift_name("init(name:)"))) __attribute__((objc_designated_initializer)) __attribute__((unavailable));
+ (instancetype)sHACH __attribute__((swift_name("init()")));
@property (class, readonly, getter=shared) STTZmanAuthoritySHACH *shared __attribute__((swift_name("shared")));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("ZmanAuthority.SHAKOW")))
@interface STTZmanAuthoritySHAKOW : STTZmanAuthority
+ (instancetype)alloc __attribute__((unavailable));
+ (instancetype)allocWithZone:(struct _NSZone *)zone __attribute__((unavailable));
- (instancetype)initWithName:(NSString *)name __attribute__((swift_name("init(name:)"))) __attribute__((objc_designated_initializer)) __attribute__((unavailable));
+ (instancetype)sHAKOW __attribute__((swift_name("init()")));
@property (class, readonly, getter=shared) STTZmanAuthoritySHAKOW *shared __attribute__((swift_name("shared")));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("ZmanAuthority.SHOR")))
@interface STTZmanAuthoritySHOR : STTZmanAuthority
+ (instancetype)alloc __attribute__((unavailable));
+ (instancetype)allocWithZone:(struct _NSZone *)zone __attribute__((unavailable));
- (instancetype)initWithName:(NSString *)name __attribute__((swift_name("init(name:)"))) __attribute__((objc_designated_initializer)) __attribute__((unavailable));
+ (instancetype)sHOR __attribute__((swift_name("init()")));
@property (class, readonly, getter=shared) STTZmanAuthoritySHOR *shared __attribute__((swift_name("shared")));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("ZmanAuthority.SHULCHAN_ARUCH")))
@interface STTZmanAuthoritySHULCHAN_ARUCH : STTZmanAuthority
+ (instancetype)alloc __attribute__((unavailable));
+ (instancetype)allocWithZone:(struct _NSZone *)zone __attribute__((unavailable));
- (instancetype)initWithName:(NSString *)name __attribute__((swift_name("init(name:)"))) __attribute__((objc_designated_initializer)) __attribute__((unavailable));
+ (instancetype)sHULCHAN_ARUCH __attribute__((swift_name("init()")));
@property (class, readonly, getter=shared) STTZmanAuthoritySHULCHAN_ARUCH *shared __attribute__((swift_name("shared")));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("ZmanAuthority.SHVUS_YAAKOV")))
@interface STTZmanAuthoritySHVUS_YAAKOV : STTZmanAuthority
+ (instancetype)alloc __attribute__((unavailable));
+ (instancetype)allocWithZone:(struct _NSZone *)zone __attribute__((unavailable));
- (instancetype)initWithName:(NSString *)name __attribute__((swift_name("init(name:)"))) __attribute__((objc_designated_initializer)) __attribute__((unavailable));
+ (instancetype)sHVUS_YAAKOV __attribute__((swift_name("init()")));
@property (class, readonly, getter=shared) STTZmanAuthoritySHVUS_YAAKOV *shared __attribute__((swift_name("shared")));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("ZmanAuthority.Strings")))
@interface STTZmanAuthorityStrings : STTBase
+ (instancetype)alloc __attribute__((unavailable));
+ (instancetype)allocWithZone:(struct _NSZone *)zone __attribute__((unavailable));
+ (instancetype)strings __attribute__((swift_name("init()")));
@property (class, readonly, getter=shared) STTZmanAuthorityStrings *shared __attribute__((swift_name("shared")));
@property (readonly) NSString *AHAVAT_SHALOM __attribute__((swift_name("AHAVAT_SHALOM")));
@property (readonly) NSString *ARUCH_HASHULCHAN __attribute__((swift_name("ARUCH_HASHULCHAN")));
@property (readonly) NSString *ATERET_TORAH __attribute__((swift_name("ATERET_TORAH")));
@property (readonly) NSString *BAAL_HATANYA __attribute__((swift_name("BAAL_HATANYA")));
@property (readonly) NSString *BICK __attribute__((swift_name("BICK")));
@property (readonly) NSString *CHASSAN_SOFER __attribute__((swift_name("CHASSAN_SOFER")));
@property (readonly) NSString *CHAVAS_YAIR __attribute__((swift_name("CHAVAS_YAIR")));
@property (readonly) NSString *DIVREI_MALKIEL __attribute__((swift_name("DIVREI_MALKIEL")));
@property (readonly) NSString *DIVREI_YOSEF __attribute__((swift_name("DIVREI_YOSEF")));
@property (readonly) NSString *EDELSTEIN __attribute__((swift_name("EDELSTEIN")));
@property (readonly) NSString *EIDOT_HAMIZRACH __attribute__((swift_name("EIDOT_HAMIZRACH")));
@property (readonly) NSString *FEINSTEIN __attribute__((swift_name("FEINSTEIN")));
@property (readonly) NSString *GEONIM __attribute__((swift_name("GEONIM")));
@property (readonly) NSString *GRA __attribute__((swift_name("GRA")));
@property (readonly) NSString *GREENWALD __attribute__((swift_name("GREENWALD")));
@property (readonly) NSString *HISACHDUS_HARABONIM __attribute__((swift_name("HISACHDUS_HARABONIM")));
@property (readonly) NSString *KAMENETSKY __attribute__((swift_name("KAMENETSKY")));
@property (readonly) NSString *KOMARNO __attribute__((swift_name("KOMARNO")));
@property (readonly) NSString *KRONGLASS __attribute__((swift_name("KRONGLASS")));
@property (readonly) NSString *LECHEM_MISHNAH __attribute__((swift_name("LECHEM_MISHNAH")));
@property (readonly) NSString *MAAGALEI_TZEDEK __attribute__((swift_name("MAAGALEI_TZEDEK")));
@property (readonly) NSString *MACHATZIS_HASHEKEL __attribute__((swift_name("MACHATZIS_HASHEKEL")));
@property (readonly) NSString *MAHARIK __attribute__((swift_name("MAHARIK")));
@property (readonly) NSString *MAHARIL __attribute__((swift_name("MAHARIL")));
@property (readonly) NSString *MGA __attribute__((swift_name("MGA")));
@property (readonly) NSString *MINCHAS_COHEN __attribute__((swift_name("MINCHAS_COHEN")));
@property (readonly) NSString *NEIMAN __attribute__((swift_name("NEIMAN")));
@property (readonly) NSString *POSEN __attribute__((swift_name("POSEN")));
@property (readonly) NSString *PRI_MEGADIM __attribute__((swift_name("PRI_MEGADIM")));
@property (readonly) NSString *RAAVAN __attribute__((swift_name("RAAVAN")));
@property (readonly) NSString *RABEINU_TAM __attribute__((swift_name("RABEINU_TAM")));
@property (readonly) NSString *RABEINU_YONAH __attribute__((swift_name("RABEINU_YONAH")));
@property (readonly) NSString *RAMBAM __attribute__((swift_name("RAMBAM")));
@property (readonly) NSString *RAZEH __attribute__((swift_name("RAZEH")));
@property (readonly) NSString *SATMER __attribute__((swift_name("SATMER")));
@property (readonly) NSString *SHACH __attribute__((swift_name("SHACH")));
@property (readonly) NSString *SHAKOW __attribute__((swift_name("SHAKOW")));
@property (readonly) NSString *SHOR __attribute__((swift_name("SHOR")));
@property (readonly) NSString *SHULCHAN_ARUCH __attribute__((swift_name("SHULCHAN_ARUCH")));
@property (readonly) NSString *SHVUS_YAAKOV __attribute__((swift_name("SHVUS_YAAKOV")));
@property (readonly) NSString *Unanimous __attribute__((swift_name("Unanimous")));
@property (readonly) NSString *WEISS __attribute__((swift_name("WEISS")));
@property (readonly) NSString *YAAVETZ __attribute__((swift_name("YAAVETZ")));
@property (readonly) NSString *YEREIM __attribute__((swift_name("YEREIM")));
@property (readonly) NSString *ZILBER __attribute__((swift_name("ZILBER")));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("ZmanAuthority.Unanimous")))
@interface STTZmanAuthorityUnanimous : STTZmanAuthority
+ (instancetype)alloc __attribute__((unavailable));
+ (instancetype)allocWithZone:(struct _NSZone *)zone __attribute__((unavailable));
- (instancetype)initWithName:(NSString *)name __attribute__((swift_name("init(name:)"))) __attribute__((objc_designated_initializer)) __attribute__((unavailable));
+ (instancetype)unanimous __attribute__((swift_name("init()")));
@property (class, readonly, getter=shared) STTZmanAuthorityUnanimous *shared __attribute__((swift_name("shared")));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("ZmanAuthority.WEISS")))
@interface STTZmanAuthorityWEISS : STTZmanAuthority
+ (instancetype)alloc __attribute__((unavailable));
+ (instancetype)allocWithZone:(struct _NSZone *)zone __attribute__((unavailable));
- (instancetype)initWithName:(NSString *)name __attribute__((swift_name("init(name:)"))) __attribute__((objc_designated_initializer)) __attribute__((unavailable));
+ (instancetype)wEISS __attribute__((swift_name("init()")));
@property (class, readonly, getter=shared) STTZmanAuthorityWEISS *shared __attribute__((swift_name("shared")));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("ZmanAuthority.YAAVETZ")))
@interface STTZmanAuthorityYAAVETZ : STTZmanAuthority
+ (instancetype)alloc __attribute__((unavailable));
+ (instancetype)allocWithZone:(struct _NSZone *)zone __attribute__((unavailable));
- (instancetype)initWithName:(NSString *)name __attribute__((swift_name("init(name:)"))) __attribute__((objc_designated_initializer)) __attribute__((unavailable));
+ (instancetype)yAAVETZ __attribute__((swift_name("init()")));
@property (class, readonly, getter=shared) STTZmanAuthorityYAAVETZ *shared __attribute__((swift_name("shared")));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("ZmanAuthority.YEREIM")))
@interface STTZmanAuthorityYEREIM : STTZmanAuthority
+ (instancetype)alloc __attribute__((unavailable));
+ (instancetype)allocWithZone:(struct _NSZone *)zone __attribute__((unavailable));
- (instancetype)initWithName:(NSString *)name __attribute__((swift_name("init(name:)"))) __attribute__((objc_designated_initializer)) __attribute__((unavailable));
+ (instancetype)yEREIM __attribute__((swift_name("init()")));
@property (class, readonly, getter=shared) STTZmanAuthorityYEREIM *shared __attribute__((swift_name("shared")));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("ZmanAuthority.ZILBER")))
@interface STTZmanAuthorityZILBER : STTZmanAuthority
+ (instancetype)alloc __attribute__((unavailable));
+ (instancetype)allocWithZone:(struct _NSZone *)zone __attribute__((unavailable));
- (instancetype)initWithName:(NSString *)name __attribute__((swift_name("init(name:)"))) __attribute__((objc_designated_initializer)) __attribute__((unavailable));
+ (instancetype)zILBER __attribute__((swift_name("init()")));
@property (class, readonly, getter=shared) STTZmanAuthorityZILBER *shared __attribute__((swift_name("shared")));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("ZmanCalculationMethodCompanion")))
@interface STTZmanCalculationMethodCompanion : STTBase
+ (instancetype)alloc __attribute__((unavailable));
+ (instancetype)allocWithZone:(struct _NSZone *)zone __attribute__((unavailable));
+ (instancetype)companion __attribute__((swift_name("init()")));
@property (class, readonly, getter=shared) STTZmanCalculationMethodCompanion *shared __attribute__((swift_name("shared")));
- (STTZmanCalculationMethodDegrees *)degrees:(double)receiver __attribute__((swift_name("degrees(_:)")));
- (STTZmanCalculationMethodDegrees *)degrees_:(float)receiver __attribute__((swift_name("degrees(__:)")));
- (STTZmanCalculationMethodDegrees *)degrees__:(int32_t)receiver __attribute__((swift_name("degrees(___:)")));
- (STTZmanCalculationMethodFixedDuration *)fixed:(int64_t)receiver __attribute__((swift_name("fixed(_:)")));
- (STTZmanCalculationMethodZmaniyosDuration *)zmaniyos:(int64_t)receiver __attribute__((swift_name("zmaniyos(_:)")));
@end


/**
 * - The [GR"A][ZmanAuthority.GRA] holds that the day starts at [sunrise][ZmanType.HANAITZ] and ends at [sunset][ZmanType.SHKIAH].
 * - The [MG"A][ZmanAuthority.MGA] holds that the day starts at [dawn][ZmanType.ALOS] and ends at [dusk][ZmanType.TZAIS].
 * - The [Raze"h/Menorah HaTehorah][ZmanAuthority.RAZEH] holds that the day starts at [*alos* 16.1˚][ComplexZmanimCalendar.alos16Point1Degrees] and ends at
 * [sea level sunset][ComplexZmanimCalendar.seaLevelSunset]
 * */
__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("ZmanCalculationMethodDayDefinition")))
@interface STTZmanCalculationMethodDayDefinition : STTBase <STTZmanCalculationMethod>
- (instancetype)initWithDayStart:(STTZmanDefinition *)dayStart dayEnd:(STTZmanDefinition *)dayEnd dayStartRelationship:(STTZmanRelationship * _Nullable)dayStartRelationship dayEndRelationship:(STTZmanRelationship * _Nullable)dayEndRelationship __attribute__((swift_name("init(dayStart:dayEnd:dayStartRelationship:dayEndRelationship:)"))) __attribute__((objc_designated_initializer));
@property (class, readonly, getter=companion) STTZmanCalculationMethodDayDefinitionCompanion *companion __attribute__((swift_name("companion")));

/**
 * - The [GR"A][ZmanAuthority.GRA] holds that the day starts at [sunrise][ZmanType.HANAITZ] and ends at [sunset][ZmanType.SHKIAH].
 * - The [MG"A][ZmanAuthority.MGA] holds that the day starts at [dawn][ZmanType.ALOS] and ends at [dusk][ZmanType.TZAIS].
 * - The [Raze"h/Menorah HaTehorah][ZmanAuthority.RAZEH] holds that the day starts at [*alos* 16.1˚][ComplexZmanimCalendar.alos16Point1Degrees] and ends at
 * [sea level sunset][ComplexZmanimCalendar.seaLevelSunset]
 * */
- (STTZmanCalculationMethodDayDefinition *)doCopyDayStart:(STTZmanDefinition *)dayStart dayEnd:(STTZmanDefinition *)dayEnd dayStartRelationship:(STTZmanRelationship * _Nullable)dayStartRelationship dayEndRelationship:(STTZmanRelationship * _Nullable)dayEndRelationship __attribute__((swift_name("doCopy(dayStart:dayEnd:dayStartRelationship:dayEndRelationship:)")));

/**
 * - The [GR"A][ZmanAuthority.GRA] holds that the day starts at [sunrise][ZmanType.HANAITZ] and ends at [sunset][ZmanType.SHKIAH].
 * - The [MG"A][ZmanAuthority.MGA] holds that the day starts at [dawn][ZmanType.ALOS] and ends at [dusk][ZmanType.TZAIS].
 * - The [Raze"h/Menorah HaTehorah][ZmanAuthority.RAZEH] holds that the day starts at [*alos* 16.1˚][ComplexZmanimCalendar.alos16Point1Degrees] and ends at
 * [sea level sunset][ComplexZmanimCalendar.seaLevelSunset]
 * */
- (BOOL)isEqual:(id _Nullable)other __attribute__((swift_name("isEqual(_:)")));
- (NSString *)format __attribute__((swift_name("format()")));

/**
 * - The [GR"A][ZmanAuthority.GRA] holds that the day starts at [sunrise][ZmanType.HANAITZ] and ends at [sunset][ZmanType.SHKIAH].
 * - The [MG"A][ZmanAuthority.MGA] holds that the day starts at [dawn][ZmanType.ALOS] and ends at [dusk][ZmanType.TZAIS].
 * - The [Raze"h/Menorah HaTehorah][ZmanAuthority.RAZEH] holds that the day starts at [*alos* 16.1˚][ComplexZmanimCalendar.alos16Point1Degrees] and ends at
 * [sea level sunset][ComplexZmanimCalendar.seaLevelSunset]
 * */
- (NSUInteger)hash __attribute__((swift_name("hash()")));

/**
 * - The [GR"A][ZmanAuthority.GRA] holds that the day starts at [sunrise][ZmanType.HANAITZ] and ends at [sunset][ZmanType.SHKIAH].
 * - The [MG"A][ZmanAuthority.MGA] holds that the day starts at [dawn][ZmanType.ALOS] and ends at [dusk][ZmanType.TZAIS].
 * - The [Raze"h/Menorah HaTehorah][ZmanAuthority.RAZEH] holds that the day starts at [*alos* 16.1˚][ComplexZmanimCalendar.alos16Point1Degrees] and ends at
 * [sea level sunset][ComplexZmanimCalendar.seaLevelSunset]
 * */
- (NSString *)description __attribute__((swift_name("description()")));
- (NSString *)valueToString __attribute__((swift_name("valueToString()")));
@property (readonly) STTZmanDefinition *dayEnd __attribute__((swift_name("dayEnd")));
@property (readonly) STTZmanRelationship * _Nullable dayEndRelationship __attribute__((swift_name("dayEndRelationship")));
@property (readonly) STTZmanDefinition *dayStart __attribute__((swift_name("dayStart")));
@property (readonly) STTZmanRelationship * _Nullable dayStartRelationship __attribute__((swift_name("dayStartRelationship")));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("ZmanCalculationMethodDayDefinition.Companion")))
@interface STTZmanCalculationMethodDayDefinitionCompanion : STTBase
+ (instancetype)alloc __attribute__((unavailable));
+ (instancetype)allocWithZone:(struct _NSZone *)zone __attribute__((unavailable));
+ (instancetype)companion __attribute__((swift_name("init()")));
@property (class, readonly, getter=shared) STTZmanCalculationMethodDayDefinitionCompanion *shared __attribute__((swift_name("shared")));
- (STTZmanCalculationMethodDayDefinition *)dawn72ZmanisToDuskAteretTorahOffset:(double)offset __attribute__((swift_name("dawn72ZmanisToDuskAteretTorah(offset:)")));
- (STTZmanCalculationMethodDayDefinition *)dawnToDuskStartMethod:(id<STTZmanCalculationMethod>)startMethod endMethod:(id<STTZmanCalculationMethod>)endMethod __attribute__((swift_name("dawnToDusk(startMethod:endMethod:)")));
- (STTZmanCalculationMethodDayDefinition *)fromCalculationMethodDayStartCalculationMethod:(id<STTZmanCalculationMethod>)dayStartCalculationMethod dayEndCalculationMethod:(id<STTZmanCalculationMethod>)dayEndCalculationMethod dayStartsAtZman:(STTZmanType *)dayStartsAtZman dayEndsAtZman:(STTZmanType *)dayEndsAtZman dayStartUsesElevation:(STTUsesElevation *)dayStartUsesElevation dayEndUsesElevation:(STTUsesElevation *)dayEndUsesElevation __attribute__((swift_name("fromCalculationMethod(dayStartCalculationMethod:dayEndCalculationMethod:dayStartsAtZman:dayEndsAtZman:dayStartUsesElevation:dayEndUsesElevation:)")));
- (STTZmanCalculationMethodDayDefinition *)sunriseToSunsetStartMethod:(id<STTZmanCalculationMethod>)startMethod endMethod:(id<STTZmanCalculationMethod>)endMethod __attribute__((swift_name("sunriseToSunset(startMethod:endMethod:)")));
@property (readonly) STTZmanCalculationMethodDayDefinition *DAWN_16_1_TO_DUSK_3_7 __attribute__((swift_name("DAWN_16_1_TO_DUSK_3_7")));
@property (readonly) STTZmanCalculationMethodDayDefinition *DAWN_16_1_TO_DUSK_3_8 __attribute__((swift_name("DAWN_16_1_TO_DUSK_3_8")));

/**
 * @see ComplexZmanimCalendar.sofZmanShmaAlos16Point1ToTzaisGeonim7Point083Degrees
 * day starts at [*alos* 16.1˚][alos16Point1Degrees] and ends at
 * [*tzais* 7.083˚][tzaisGeonim7Point083Degrees]
 * */
@property (readonly) STTZmanCalculationMethodDayDefinition *DAWN_16_1_TO_DUSK_7_083 __attribute__((swift_name("DAWN_16_1_TO_DUSK_7_083")));

/**
 * @see ZmanAuthority.RAZEH
 * */
@property (readonly) STTZmanCalculationMethodDayDefinition *DAWN_16_1_TO_ELEVATION_ADJUSTED_SUNSET __attribute__((swift_name("DAWN_16_1_TO_ELEVATION_ADJUSTED_SUNSET")));
@property (readonly) STTZmanCalculationMethodDayDefinition *DAWN_16_1_TO_FIXED_LOCAL_CHATZOS __attribute__((swift_name("DAWN_16_1_TO_FIXED_LOCAL_CHATZOS")));
@property (readonly) STTZmanCalculationMethodDayDefinition *DAWN_18_TO_FIXED_LOCAL_CHATZOS __attribute__((swift_name("DAWN_18_TO_FIXED_LOCAL_CHATZOS")));
@property (readonly) STTZmanCalculationMethodDayDefinition *DAWN_72_MINUTES_TO_FIXED_LOCAL_CHATZOS __attribute__((swift_name("DAWN_72_MINUTES_TO_FIXED_LOCAL_CHATZOS")));
@property (readonly) STTZmanCalculationMethodDayDefinition *DAWN_90_MINUTES_TO_FIXED_LOCAL_CHATZOS __attribute__((swift_name("DAWN_90_MINUTES_TO_FIXED_LOCAL_CHATZOS")));
@property (readonly) STTZmanCalculationMethodDayDefinition *FIXED_LOCAL_CHATZOS_TO_SUNSET __attribute__((swift_name("FIXED_LOCAL_CHATZOS_TO_SUNSET")));
@property (readonly) STTZmanCalculationMethodDayDefinition *SUNRISE_TO_FIXED_LOCAL_CHATZOS __attribute__((swift_name("SUNRISE_TO_FIXED_LOCAL_CHATZOS")));
@property (readonly) STTZmanCalculationMethodDayDefinition *SUNRISE_TO_SUNSET __attribute__((swift_name("SUNRISE_TO_SUNSET")));
@end


/**
 * Dawn is when the sun is x degrees below the eastern geometric horizon before sunrise.
 * Dusk is when the sun is x degrees below the western geometric horizon after sunset.
 * */
__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("ZmanCalculationMethodDegrees")))
@interface STTZmanCalculationMethodDegrees : STTBase <STTZmanCalculationMethod>
- (instancetype)initWithDegrees:(float)degrees __attribute__((swift_name("init(degrees:)"))) __attribute__((objc_designated_initializer));
@property (class, readonly, getter=companion) STTZmanCalculationMethodDegreesCompanion *companion __attribute__((swift_name("companion")));

/**
 * Dawn is when the sun is x degrees below the eastern geometric horizon before sunrise.
 * Dusk is when the sun is x degrees below the western geometric horizon after sunset.
 * */
- (STTZmanCalculationMethodDegrees *)doCopyDegrees:(float)degrees __attribute__((swift_name("doCopy(degrees:)")));

/**
 * Dawn is when the sun is x degrees below the eastern geometric horizon before sunrise.
 * Dusk is when the sun is x degrees below the western geometric horizon after sunset.
 * */
- (BOOL)isEqual:(id _Nullable)other __attribute__((swift_name("isEqual(_:)")));
- (NSString *)format __attribute__((swift_name("format()")));
- (NSString *)formatSubjectZman:(NSString *)subjectZman zmanRelativeTo:(NSString *)zmanRelativeTo __attribute__((swift_name("format(subjectZman:zmanRelativeTo:)")));

/**
 * Dawn is when the sun is x degrees below the eastern geometric horizon before sunrise.
 * Dusk is when the sun is x degrees below the western geometric horizon after sunset.
 * */
- (NSUInteger)hash __attribute__((swift_name("hash()")));

/**
 * Dawn is when the sun is x degrees below the eastern geometric horizon before sunrise.
 * Dusk is when the sun is x degrees below the western geometric horizon after sunset.
 * */
- (NSString *)description __attribute__((swift_name("description()")));
- (NSString *)valueToString __attribute__((swift_name("valueToString()")));
@property (readonly) float degrees __attribute__((swift_name("degrees")));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("ZmanCalculationMethodDegrees.Companion")))
@interface STTZmanCalculationMethodDegreesCompanion : STTBase
+ (instancetype)alloc __attribute__((unavailable));
+ (instancetype)allocWithZone:(struct _NSZone *)zone __attribute__((unavailable));
+ (instancetype)companion __attribute__((swift_name("init()")));
@property (class, readonly, getter=shared) STTZmanCalculationMethodDegreesCompanion *shared __attribute__((swift_name("shared")));

/**
 * 45 minutes before [sunrise] in Jerusalem [around the equinox / equilux](https://kosherjava.com/2022/01/12/equinox-vs-equilux-zmanim-calculations/)
 * */
@property (readonly) STTZmanCalculationMethodDegrees *_10_2 __attribute__((swift_name("_10_2")));

/**
 * 48 minutes before [sunrise] in Jerusalem [around the equinox / equilux](https://kosherjava.com/2022/01/12/equinox-vs-equilux-zmanim-calculations/)
 * */
@property (readonly) STTZmanCalculationMethodDegrees *_11 __attribute__((swift_name("_11")));

/**
 * 52 minutes before [sunrise] in Jerusalem [around the equinox / equilux](https://kosherjava.com/2022/01/12/equinox-vs-equilux-zmanim-calculations/)
 * */
@property (readonly) STTZmanCalculationMethodDegrees *_11_5 __attribute__((swift_name("_11_5")));
@property (readonly) STTZmanCalculationMethodDegrees *_13_24 __attribute__((swift_name("_13_24")));

/**
 * Rabeinu tam/72 minutes as measured in degrees
 * */
@property (readonly) STTZmanCalculationMethodDegrees *_16_1 __attribute__((swift_name("_16_1")));
@property (readonly) STTZmanCalculationMethodDegrees *_18 __attribute__((swift_name("_18")));

/**
 * - This is the [Rambam](https://en.wikipedia.org/wiki/Maimonides)'s *alos* according to
 * - Rabbi Moshe Kosower's [Maaglei Tzedek](https://www.worldcat.org/oclc/145454098), page 88,
 * - Rabbi Dovid Shor's [Ayeles Hashachar Vol. I, page 12](https://hebrewbooks.org/pdfpager.aspx?req=33464&pgnum=13),
 * - Rabbi Yaakov Gershon Weiss's [Yom Valayla Shel Torah, Ch. 34, p. 222](https://hebrewbooks.org/pdfpager.aspx?req=55960&pgnum=258) and
 * - Rabbi Yaakov Shakow's [Luach Ikvei Hayom](https://www.worldcat.org/oclc/1043573513).
 *
 * @see ZmanAuthority.RAMBAM
 * @see ZmanAuthority.MAAGALEI_TZEDEK
 * @see ZmanAuthority.SHOR
 * @see ZmanAuthority.WEISS
 * @see ZmanAuthority.SHAKOW
 * */
@property (readonly) STTZmanCalculationMethodDegrees *_19 __attribute__((swift_name("_19")));

/**
 * 90 minutes as measured in degrees
 * */
@property (readonly) STTZmanCalculationMethodDegrees *_19_8 __attribute__((swift_name("_19_8")));
@property (readonly) STTZmanCalculationMethodDegrees *_26 __attribute__((swift_name("_26")));

/**
 * geonim/13.5 minutes as measured in degrees
 * */
@property (readonly) STTZmanCalculationMethodDegrees *_3_7 __attribute__((swift_name("_3_7")));

/**
 * geonim/14 minutes as measured in degrees.
 * The 14 minutes are based on 3/4 of an 18 minute *mil*, with half a minute added for Rav Yosi.
 * */
@property (readonly) STTZmanCalculationMethodDegrees *_3_8 __attribute__((swift_name("_3_8")));

/**
 * @see ComplexZmanimCalendar.tzaisGeonim7Point083Degrees
 * */
@property (readonly) STTZmanCalculationMethodDegrees *_7_083 __attribute__((swift_name("_7_083")));

/**
 * 35/36 minutes as measured in degrees
 * @see [ComplexZmanimCalendar.misheyakir7Point65Degrees] for sources
 * */
@property (readonly) STTZmanCalculationMethodDegrees *_7_65 __attribute__((swift_name("_7_65")));
@property (readonly) STTZmanCalculationMethodDegrees *_7_67 __attribute__((swift_name("_7_67")));
@property (readonly) STTZmanCalculationMethodDegrees *_8_5 __attribute__((swift_name("_8_5")));
@property (readonly) STTZmanCalculationMethodDegrees *_9_3 __attribute__((swift_name("_9_3")));

/**
 * 45 minutes as measured in degrees
 * @see [ComplexZmanimCalendar.misheyakir9Point5Degrees] for sources
 * */
@property (readonly) STTZmanCalculationMethodDegrees *_9_5 __attribute__((swift_name("_9_5")));
@property (readonly) STTZmanCalculationMethodDegrees *_9_75 __attribute__((swift_name("_9_75")));
@end


/**
 * Dawn for this calculation is 60 minutes before sunrise.
 * Dusk is 60 minutes after sunset.
 *
 * @param duration if negative, this zman is [duration] before what this is relative to . If positive, after.
 * */
__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("ZmanCalculationMethodFixedDuration")))
@interface STTZmanCalculationMethodFixedDuration : STTBase <STTZmanCalculationMethod>
- (instancetype)initWithDuration:(int64_t)duration __attribute__((swift_name("init(duration:)"))) __attribute__((objc_designated_initializer));
@property (class, readonly, getter=companion) STTZmanCalculationMethodFixedDurationCompanion *companion __attribute__((swift_name("companion")));

/**
 * Dawn for this calculation is 60 minutes before sunrise.
 * Dusk is 60 minutes after sunset.
 *
 * @param duration if negative, this zman is [duration] before what this is relative to . If positive, after.
 * */
- (STTZmanCalculationMethodFixedDuration *)doCopyDuration:(int64_t)duration __attribute__((swift_name("doCopy(duration:)")));

/**
 * Dawn for this calculation is 60 minutes before sunrise.
 * Dusk is 60 minutes after sunset.
 *
 * @param duration if negative, this zman is [duration] before what this is relative to . If positive, after.
 * */
- (BOOL)isEqual:(id _Nullable)other __attribute__((swift_name("isEqual(_:)")));
- (NSString *)format __attribute__((swift_name("format()")));
- (NSString *)formatSubjectZman:(NSString *)subjectZman zmanRelativeTo:(NSString *)zmanRelativeTo __attribute__((swift_name("format(subjectZman:zmanRelativeTo:)")));

/**
 * Dawn for this calculation is 60 minutes before sunrise.
 * Dusk is 60 minutes after sunset.
 *
 * @param duration if negative, this zman is [duration] before what this is relative to . If positive, after.
 * */
- (NSUInteger)hash __attribute__((swift_name("hash()")));
- (NSString *)shortDescription __attribute__((swift_name("shortDescription()")));

/**
 * Dawn for this calculation is 60 minutes before sunrise.
 * Dusk is 60 minutes after sunset.
 *
 * @param duration if negative, this zman is [duration] before what this is relative to . If positive, after.
 * */
- (NSString *)description __attribute__((swift_name("description()")));
- (NSString *)valueToString __attribute__((swift_name("valueToString()")));
@property (readonly) int64_t duration __attribute__((swift_name("duration")));
@end


/**
 * Ateret torah (which defaults to 40 minutes)
 * */
__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("ZmanCalculationMethodFixedDuration.AteretTorah")))
@interface STTZmanCalculationMethodFixedDurationAteretTorah : STTBase <STTZmanCalculationMethod>
- (instancetype)initWithMinutes:(double)minutes __attribute__((swift_name("init(minutes:)"))) __attribute__((objc_designated_initializer));

/**
 * Ateret torah (which defaults to 40 minutes)
 * */
- (STTZmanCalculationMethodFixedDurationAteretTorah *)doCopyMinutes:(double)minutes __attribute__((swift_name("doCopy(minutes:)")));

/**
 * Ateret torah (which defaults to 40 minutes)
 * */
- (BOOL)isEqual:(id _Nullable)other __attribute__((swift_name("isEqual(_:)")));

/**
 * Ateret torah (which defaults to 40 minutes)
 * */
- (NSUInteger)hash __attribute__((swift_name("hash()")));
- (NSString *)shortDescription __attribute__((swift_name("shortDescription()")));

/**
 * Ateret torah (which defaults to 40 minutes)
 * */
- (NSString *)description __attribute__((swift_name("description()")));
- (NSString *)valueToString __attribute__((swift_name("valueToString()")));
@property (readonly) double minutes __attribute__((swift_name("minutes")));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("ZmanCalculationMethodFixedDuration.Companion")))
@interface STTZmanCalculationMethodFixedDurationCompanion : STTBase
+ (instancetype)alloc __attribute__((unavailable));
+ (instancetype)allocWithZone:(struct _NSZone *)zone __attribute__((unavailable));
+ (instancetype)companion __attribute__((swift_name("init()")));
@property (class, readonly, getter=shared) STTZmanCalculationMethodFixedDurationCompanion *shared __attribute__((swift_name("shared")));

/**
 * A mil takes 24 minutes to walk; 5 mil * 24 minutes/mil = 120 minutes
 * */
@property (readonly) STTZmanCalculationMethodFixedDuration *_120 __attribute__((swift_name("_120")));

/**
 * A mil takes 15 minutes to walk; 4 mil * 15 minutes/mil = 60 minutes
 *
 * @see ZmanAuthority.CHAVAS_YAIR
 * @see ZmanAuthority.DIVREI_MALKIEL
 * @see ZmanAuthority.MAHARIK
 * @see ZmanAuthority.HISACHDUS_HARABONIM
 *
 * */
@property (readonly) STTZmanCalculationMethodFixedDuration *_60 __attribute__((swift_name("_60")));

/**
 * A mil takes 18 minutes to walk; 4 mil * 18 minutes/mil = 72 minutes
 * @see ZmanAuthority.RAAVAN (disputed - see [ComplexZmanimCalendar.alos60])
 * */
@property (readonly) STTZmanCalculationMethodFixedDuration *_72 __attribute__((swift_name("_72")));

/**
 * A mil takes 22.5 minutes to walk; 4 mil * 22.5 minutes/mil = 90 minutes
 * */
@property (readonly) STTZmanCalculationMethodFixedDuration *_90 __attribute__((swift_name("_90")));

/**
 * A mil takes 24 minutes to walk; 4 mil * 24 minutes/mil = 96 minutes
 * */
@property (readonly) STTZmanCalculationMethodFixedDuration *_96 __attribute__((swift_name("_96")));
@end


/**
 * @see ComplexZmanimCalendar.fixedLocalChatzos
 * */
__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("ZmanCalculationMethodFixedLocalChatzos")))
@interface STTZmanCalculationMethodFixedLocalChatzos : STTBase <STTZmanCalculationMethod>
+ (instancetype)alloc __attribute__((unavailable));

/**
 * @see ComplexZmanimCalendar.fixedLocalChatzos
 * */
+ (instancetype)allocWithZone:(struct _NSZone *)zone __attribute__((unavailable));
+ (instancetype)fixedLocalChatzos __attribute__((swift_name("init()")));
@property (class, readonly, getter=shared) STTZmanCalculationMethodFixedLocalChatzos *shared __attribute__((swift_name("shared")));
- (NSString *)format __attribute__((swift_name("format()")));
- (NSString *)valueToString __attribute__((swift_name("valueToString()")));
@end


/**
 * A method of calculation in which the later of two zmanim is used.
 * Meaning that if [zman1] occurs at 6:00 AM and [zman2] occurs at 6:05 AM, this zman takes on the value of 6:00 AM.
 * */
__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("ZmanCalculationMethodLaterOf")))
@interface STTZmanCalculationMethodLaterOf : STTBase <STTZmanCalculationMethod>
- (instancetype)initWithZman1:(STTZmanDefinition *)zman1 zman2:(STTZmanDefinition *)zman2 __attribute__((swift_name("init(zman1:zman2:)"))) __attribute__((objc_designated_initializer));

/**
 * A method of calculation in which the later of two zmanim is used.
 * Meaning that if [zman1] occurs at 6:00 AM and [zman2] occurs at 6:05 AM, this zman takes on the value of 6:00 AM.
 * */
- (STTZmanCalculationMethodLaterOf *)doCopyZman1:(STTZmanDefinition *)zman1 zman2:(STTZmanDefinition *)zman2 __attribute__((swift_name("doCopy(zman1:zman2:)")));

/**
 * A method of calculation in which the later of two zmanim is used.
 * Meaning that if [zman1] occurs at 6:00 AM and [zman2] occurs at 6:05 AM, this zman takes on the value of 6:00 AM.
 * */
- (BOOL)isEqual:(id _Nullable)other __attribute__((swift_name("isEqual(_:)")));
- (NSString *)format __attribute__((swift_name("format()")));

/**
 * A method of calculation in which the later of two zmanim is used.
 * Meaning that if [zman1] occurs at 6:00 AM and [zman2] occurs at 6:05 AM, this zman takes on the value of 6:00 AM.
 * */
- (NSUInteger)hash __attribute__((swift_name("hash()")));

/**
 * A method of calculation in which the later of two zmanim is used.
 * Meaning that if [zman1] occurs at 6:00 AM and [zman2] occurs at 6:05 AM, this zman takes on the value of 6:00 AM.
 * */
- (NSString *)description __attribute__((swift_name("description()")));
- (NSString *)valueToString __attribute__((swift_name("valueToString()")));
@property (readonly) STTZmanDefinition *zman1 __attribute__((swift_name("zman1")));
@property (readonly) STTZmanDefinition *zman2 __attribute__((swift_name("zman2")));
@end


/**
 * A method of calculation in which the zman is calculated relative to another zman (e.g. X occurs 10 minutes before Y).
 * If a [com.kosherjava.zmanim.Zman] uses this [ZmanCalculationMethod], the information on how it is calculated will be in the [relationship]
 *
 * A [ZmanRelationship] is a relationship between two [ZmanType]s, dictating when [ZmanRelationship.subject] occurs relative to [ZmanRelationship.relativeToZman].
 * ZmanType.TZAIS  occurs 45.minutes          after  ZmanType.SHKIAH
 * ZmanType.SHKIAH occurs 45.minutes          before ZmanType.TZAIS
 *
 * ZmanType.SHKIAH occurs 45.minutes.zmaniyos before ZmanType.TZAIS
 * ZmanType.SHKIAH occurs 16.1F.degrees       before ZmanType.TZAIS
 *
 * ZmanType.BAIN_HASHMASHOS occurs 13.5.minutes before tzaisGeonim7Point083Degrees.definition
 *
 *
 * @see ZmanRelationship
 * @see ZmanType.occurs
 * @see Occurrence
 * */
__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("ZmanCalculationMethodRelationship")))
@interface STTZmanCalculationMethodRelationship : STTBase <STTZmanCalculationMethod>
- (instancetype)initWithRelationship:(STTZmanRelationship *)relationship __attribute__((swift_name("init(relationship:)"))) __attribute__((objc_designated_initializer));

/**
 * A method of calculation in which the zman is calculated relative to another zman (e.g. X occurs 10 minutes before Y).
 * If a [com.kosherjava.zmanim.Zman] uses this [ZmanCalculationMethod], the information on how it is calculated will be in the [relationship]
 *
 * A [ZmanRelationship] is a relationship between two [ZmanType]s, dictating when [ZmanRelationship.subject] occurs relative to [ZmanRelationship.relativeToZman].
 * ZmanType.TZAIS  occurs 45.minutes          after  ZmanType.SHKIAH
 * ZmanType.SHKIAH occurs 45.minutes          before ZmanType.TZAIS
 *
 * ZmanType.SHKIAH occurs 45.minutes.zmaniyos before ZmanType.TZAIS
 * ZmanType.SHKIAH occurs 16.1F.degrees       before ZmanType.TZAIS
 *
 * ZmanType.BAIN_HASHMASHOS occurs 13.5.minutes before tzaisGeonim7Point083Degrees.definition
 *
 *
 * @see ZmanRelationship
 * @see ZmanType.occurs
 * @see Occurrence
 * */
- (STTZmanCalculationMethodRelationship *)doCopyRelationship:(STTZmanRelationship *)relationship __attribute__((swift_name("doCopy(relationship:)")));

/**
 * A method of calculation in which the zman is calculated relative to another zman (e.g. X occurs 10 minutes before Y).
 * If a [com.kosherjava.zmanim.Zman] uses this [ZmanCalculationMethod], the information on how it is calculated will be in the [relationship]
 *
 * A [ZmanRelationship] is a relationship between two [ZmanType]s, dictating when [ZmanRelationship.subject] occurs relative to [ZmanRelationship.relativeToZman].
 * ZmanType.TZAIS  occurs 45.minutes          after  ZmanType.SHKIAH
 * ZmanType.SHKIAH occurs 45.minutes          before ZmanType.TZAIS
 *
 * ZmanType.SHKIAH occurs 45.minutes.zmaniyos before ZmanType.TZAIS
 * ZmanType.SHKIAH occurs 16.1F.degrees       before ZmanType.TZAIS
 *
 * ZmanType.BAIN_HASHMASHOS occurs 13.5.minutes before tzaisGeonim7Point083Degrees.definition
 *
 *
 * @see ZmanRelationship
 * @see ZmanType.occurs
 * @see Occurrence
 * */
- (BOOL)isEqual:(id _Nullable)other __attribute__((swift_name("isEqual(_:)")));
- (NSString *)format __attribute__((swift_name("format()")));

/**
 * A method of calculation in which the zman is calculated relative to another zman (e.g. X occurs 10 minutes before Y).
 * If a [com.kosherjava.zmanim.Zman] uses this [ZmanCalculationMethod], the information on how it is calculated will be in the [relationship]
 *
 * A [ZmanRelationship] is a relationship between two [ZmanType]s, dictating when [ZmanRelationship.subject] occurs relative to [ZmanRelationship.relativeToZman].
 * ZmanType.TZAIS  occurs 45.minutes          after  ZmanType.SHKIAH
 * ZmanType.SHKIAH occurs 45.minutes          before ZmanType.TZAIS
 *
 * ZmanType.SHKIAH occurs 45.minutes.zmaniyos before ZmanType.TZAIS
 * ZmanType.SHKIAH occurs 16.1F.degrees       before ZmanType.TZAIS
 *
 * ZmanType.BAIN_HASHMASHOS occurs 13.5.minutes before tzaisGeonim7Point083Degrees.definition
 *
 *
 * @see ZmanRelationship
 * @see ZmanType.occurs
 * @see Occurrence
 * */
- (NSUInteger)hash __attribute__((swift_name("hash()")));

/**
 * A method of calculation in which the zman is calculated relative to another zman (e.g. X occurs 10 minutes before Y).
 * If a [com.kosherjava.zmanim.Zman] uses this [ZmanCalculationMethod], the information on how it is calculated will be in the [relationship]
 *
 * A [ZmanRelationship] is a relationship between two [ZmanType]s, dictating when [ZmanRelationship.subject] occurs relative to [ZmanRelationship.relativeToZman].
 * ZmanType.TZAIS  occurs 45.minutes          after  ZmanType.SHKIAH
 * ZmanType.SHKIAH occurs 45.minutes          before ZmanType.TZAIS
 *
 * ZmanType.SHKIAH occurs 45.minutes.zmaniyos before ZmanType.TZAIS
 * ZmanType.SHKIAH occurs 16.1F.degrees       before ZmanType.TZAIS
 *
 * ZmanType.BAIN_HASHMASHOS occurs 13.5.minutes before tzaisGeonim7Point083Degrees.definition
 *
 *
 * @see ZmanRelationship
 * @see ZmanType.occurs
 * @see Occurrence
 * */
- (NSString *)description __attribute__((swift_name("description()")));
- (NSString *)valueToString __attribute__((swift_name("valueToString()")));
@property (readonly) STTZmanRelationship *relationship __attribute__((swift_name("relationship")));
@end


/**
 * A form of empty set/placeholder indicating that the calculation method was not specified/is irrelevant.
 * Almost exclusively used when defining a [ZmanDefinition] that is reused across zmanim.
 * */
__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("ZmanCalculationMethodUnspecified")))
@interface STTZmanCalculationMethodUnspecified : STTBase <STTZmanCalculationMethod>
+ (instancetype)alloc __attribute__((unavailable));

/**
 * A form of empty set/placeholder indicating that the calculation method was not specified/is irrelevant.
 * Almost exclusively used when defining a [ZmanDefinition] that is reused across zmanim.
 * */
+ (instancetype)allocWithZone:(struct _NSZone *)zone __attribute__((unavailable));
+ (instancetype)unspecified __attribute__((swift_name("init()")));
@property (class, readonly, getter=shared) STTZmanCalculationMethodUnspecified *shared __attribute__((swift_name("shared")));

/**
 * A form of empty set/placeholder indicating that the calculation method was not specified/is irrelevant.
 * Almost exclusively used when defining a [ZmanDefinition] that is reused across zmanim.
 * */
- (BOOL)isEqual:(id _Nullable)other __attribute__((swift_name("isEqual(_:)")));
- (NSString *)format __attribute__((swift_name("format()")));

/**
 * A form of empty set/placeholder indicating that the calculation method was not specified/is irrelevant.
 * Almost exclusively used when defining a [ZmanDefinition] that is reused across zmanim.
 * */
- (NSUInteger)hash __attribute__((swift_name("hash()")));

/**
 * A form of empty set/placeholder indicating that the calculation method was not specified/is irrelevant.
 * Almost exclusively used when defining a [ZmanDefinition] that is reused across zmanim.
 * */
- (NSString *)description __attribute__((swift_name("description()")));
- (NSString *)valueToString __attribute__((swift_name("valueToString()")));
@end


/**
 * Dawn for this calculation is X zmaniyos minutes before sunrise.
 * Dusk is X zmaniyos minutes after sunset.
 * */
__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("ZmanCalculationMethodZmaniyosDuration")))
@interface STTZmanCalculationMethodZmaniyosDuration : STTBase <STTZmanCalculationMethod>
- (instancetype)initWithDuration:(int64_t)duration __attribute__((swift_name("init(duration:)"))) __attribute__((objc_designated_initializer));
@property (class, readonly, getter=companion) STTZmanCalculationMethodZmaniyosDurationCompanion *companion __attribute__((swift_name("companion")));

/**
 * Dawn for this calculation is X zmaniyos minutes before sunrise.
 * Dusk is X zmaniyos minutes after sunset.
 * */
- (STTZmanCalculationMethodZmaniyosDuration *)doCopyDuration:(int64_t)duration __attribute__((swift_name("doCopy(duration:)")));

/**
 * Dawn for this calculation is X zmaniyos minutes before sunrise.
 * Dusk is X zmaniyos minutes after sunset.
 * */
- (BOOL)isEqual:(id _Nullable)other __attribute__((swift_name("isEqual(_:)")));
- (NSString *)formatInEnglish:(BOOL)inEnglish __attribute__((swift_name("format(inEnglish:)")));

/**
 * Dawn for this calculation is X zmaniyos minutes before sunrise.
 * Dusk is X zmaniyos minutes after sunset.
 * */
- (NSUInteger)hash __attribute__((swift_name("hash()")));
- (NSString *)shortDescription __attribute__((swift_name("shortDescription()")));

/**
 * Dawn for this calculation is X zmaniyos minutes before sunrise.
 * Dusk is X zmaniyos minutes after sunset.
 * */
- (NSString *)description __attribute__((swift_name("description()")));
- (NSString *)valueToString __attribute__((swift_name("valueToString()")));
@property (readonly) int64_t duration __attribute__((swift_name("duration")));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("ZmanCalculationMethodZmaniyosDuration.Companion")))
@interface STTZmanCalculationMethodZmaniyosDurationCompanion : STTBase
+ (instancetype)alloc __attribute__((unavailable));
+ (instancetype)allocWithZone:(struct _NSZone *)zone __attribute__((unavailable));
+ (instancetype)companion __attribute__((swift_name("init()")));
@property (class, readonly, getter=shared) STTZmanCalculationMethodZmaniyosDurationCompanion *shared __attribute__((swift_name("shared")));
@property (readonly) STTZmanCalculationMethodZmaniyosDuration *_120 __attribute__((swift_name("_120")));

/**
 * A mil takes 18 minutes to walk
 *
 *
 * @see ZmanAuthority.RAAVAN (disputed - see [ComplexZmanimCalendar.alos60])
 * */
@property (readonly) STTZmanCalculationMethodZmaniyosDuration *_72 __attribute__((swift_name("_72")));
@property (readonly) STTZmanCalculationMethodZmaniyosDuration *_90 __attribute__((swift_name("_90")));
@property (readonly) STTZmanCalculationMethodZmaniyosDuration *_96 __attribute__((swift_name("_96")));
@end


/**
 *
 * */
__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("ZmanDefinition")))
@interface STTZmanDefinition : STTBase
- (instancetype)initWithType:(STTZmanType *)type calculationMethod:(id<STTZmanCalculationMethod>)calculationMethod isElevationUsed:(STTUsesElevation *)isElevationUsed supportingAuthorities:(NSArray<STTZmanAuthority *> *)supportingAuthorities __attribute__((swift_name("init(type:calculationMethod:isElevationUsed:supportingAuthorities:)"))) __attribute__((objc_designated_initializer));

/**
 *
 * */
- (STTZmanDefinition *)doCopyType:(STTZmanType *)type calculationMethod:(id<STTZmanCalculationMethod>)calculationMethod isElevationUsed:(STTUsesElevation *)isElevationUsed supportingAuthorities:(NSArray<STTZmanAuthority *> *)supportingAuthorities __attribute__((swift_name("doCopy(type:calculationMethod:isElevationUsed:supportingAuthorities:)")));

/**
 *
 * */
- (BOOL)isEqual:(id _Nullable)other __attribute__((swift_name("isEqual(_:)")));

/**
 *
 * */
- (NSUInteger)hash __attribute__((swift_name("hash()")));

/**
 *
 * */
- (NSString *)description __attribute__((swift_name("description()")));
@property (readonly) id<STTZmanCalculationMethod> calculationMethod __attribute__((swift_name("calculationMethod")));
@property (readonly) STTUsesElevation *isElevationUsed __attribute__((swift_name("isElevationUsed")));
@property (readonly) NSArray<STTZmanAuthority *> *supportingAuthorities __attribute__((swift_name("supportingAuthorities")));
@property (readonly) STTZmanType *type __attribute__((swift_name("type")));
@end


/**
 * A [ZmanRelationship] is a relationship between two [ZmanType]s, dictating when [subject] occurs relative to [relativeToZman].
 * ZmanType.TZAIS  occurs 45.minutes          after  ZmanType.SHKIAH
 * ZmanType.SHKIAH occurs 45.minutes          before ZmanType.TZAIS
 *
 * ZmanType.SHKIAH occurs 45.minutes.zmaniyos before ZmanType.TZAIS
 * ZmanType.SHKIAH occurs 16.1F.degrees       before ZmanType.TZAIS
 *
 * ZmanType.BAIN_HASHMASHOS occurs 13.5.minutes before tzaisGeonim7Point083Degrees.definition
 *
 * */
__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("ZmanRelationship")))
@interface STTZmanRelationship : STTBase
- (instancetype)initWithSubject:(STTZmanType *)subject calculation:(id<STTZmanCalculationMethod>)calculation relativeToZmanType:(STTZmanType * _Nullable)relativeToZmanType relativeToZman:(STTZmanDefinition * _Nullable)relativeToZman __attribute__((swift_name("init(subject:calculation:relativeToZmanType:relativeToZman:)"))) __attribute__((objc_designated_initializer));

/**
 * A [ZmanRelationship] is a relationship between two [ZmanType]s, dictating when [subject] occurs relative to [relativeToZman].
 * ZmanType.TZAIS  occurs 45.minutes          after  ZmanType.SHKIAH
 * ZmanType.SHKIAH occurs 45.minutes          before ZmanType.TZAIS
 *
 * ZmanType.SHKIAH occurs 45.minutes.zmaniyos before ZmanType.TZAIS
 * ZmanType.SHKIAH occurs 16.1F.degrees       before ZmanType.TZAIS
 *
 * ZmanType.BAIN_HASHMASHOS occurs 13.5.minutes before tzaisGeonim7Point083Degrees.definition
 *
 * */
- (STTZmanRelationship *)doCopySubject:(STTZmanType *)subject calculation:(id<STTZmanCalculationMethod>)calculation relativeToZmanType:(STTZmanType * _Nullable)relativeToZmanType relativeToZman:(STTZmanDefinition * _Nullable)relativeToZman __attribute__((swift_name("doCopy(subject:calculation:relativeToZmanType:relativeToZman:)")));

/**
 * A [ZmanRelationship] is a relationship between two [ZmanType]s, dictating when [subject] occurs relative to [relativeToZman].
 * ZmanType.TZAIS  occurs 45.minutes          after  ZmanType.SHKIAH
 * ZmanType.SHKIAH occurs 45.minutes          before ZmanType.TZAIS
 *
 * ZmanType.SHKIAH occurs 45.minutes.zmaniyos before ZmanType.TZAIS
 * ZmanType.SHKIAH occurs 16.1F.degrees       before ZmanType.TZAIS
 *
 * ZmanType.BAIN_HASHMASHOS occurs 13.5.minutes before tzaisGeonim7Point083Degrees.definition
 *
 * */
- (BOOL)isEqual:(id _Nullable)other __attribute__((swift_name("isEqual(_:)")));

/**
 * A [ZmanRelationship] is a relationship between two [ZmanType]s, dictating when [subject] occurs relative to [relativeToZman].
 * ZmanType.TZAIS  occurs 45.minutes          after  ZmanType.SHKIAH
 * ZmanType.SHKIAH occurs 45.minutes          before ZmanType.TZAIS
 *
 * ZmanType.SHKIAH occurs 45.minutes.zmaniyos before ZmanType.TZAIS
 * ZmanType.SHKIAH occurs 16.1F.degrees       before ZmanType.TZAIS
 *
 * ZmanType.BAIN_HASHMASHOS occurs 13.5.minutes before tzaisGeonim7Point083Degrees.definition
 *
 * */
- (NSUInteger)hash __attribute__((swift_name("hash()")));
- (NSString *)description __attribute__((swift_name("description()")));
@property (readonly) id<STTZmanCalculationMethod> calculation __attribute__((swift_name("calculation")));
@property (readonly) STTZmanDefinition * _Nullable relativeToZman __attribute__((swift_name("relativeToZman")));
@property (readonly) STTZmanType * _Nullable relativeToZmanType __attribute__((swift_name("relativeToZmanType")));
@property (readonly) STTZmanType *subject __attribute__((swift_name("subject")));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("ZmanType")))
@interface STTZmanType : STTKotlinEnum<STTZmanType *>
+ (instancetype)alloc __attribute__((unavailable));
+ (instancetype)allocWithZone:(struct _NSZone *)zone __attribute__((unavailable));
- (instancetype)initWithName:(NSString *)name ordinal:(int32_t)ordinal __attribute__((swift_name("init(name:ordinal:)"))) __attribute__((objc_designated_initializer)) __attribute__((unavailable));
@property (class, readonly, getter=companion) STTZmanTypeCompanion *companion __attribute__((swift_name("companion")));
@property (class, readonly) STTZmanType *shaaZmanis __attribute__((swift_name("shaaZmanis")));
@property (class, readonly) STTZmanType *chatzosHalaylah __attribute__((swift_name("chatzosHalaylah")));
@property (class, readonly) STTZmanType *mishmar __attribute__((swift_name("mishmar")));
@property (class, readonly) STTZmanType *alos __attribute__((swift_name("alos")));
@property (class, readonly) STTZmanType *misheyakir __attribute__((swift_name("misheyakir")));
@property (class, readonly) STTZmanType *hanaitz __attribute__((swift_name("hanaitz")));
@property (class, readonly) STTZmanType *chatzosHayom __attribute__((swift_name("chatzosHayom")));
@property (class, readonly) STTZmanType *minchaGedolah __attribute__((swift_name("minchaGedolah")));
@property (class, readonly) STTZmanType *minchaKetanah __attribute__((swift_name("minchaKetanah")));
@property (class, readonly) STTZmanType *plagHamincha __attribute__((swift_name("plagHamincha")));
@property (class, readonly) STTZmanType *shkiah __attribute__((swift_name("shkiah")));
@property (class, readonly) STTZmanType *bainHashmashos __attribute__((swift_name("bainHashmashos")));
@property (class, readonly) STTZmanType *tzais __attribute__((swift_name("tzais")));
@property (class, readonly) STTZmanType *molad __attribute__((swift_name("molad")));
@property (class, readonly) STTZmanType *samuchLeminchaKetana __attribute__((swift_name("samuchLeminchaKetana")));
@property (class, readonly) STTZmanType *sofZmanKriasShema __attribute__((swift_name("sofZmanKriasShema")));
@property (class, readonly) STTZmanType *sofZmanTefillah __attribute__((swift_name("sofZmanTefillah")));
@property (class, readonly) STTZmanType *sofZmanAchilasChametz __attribute__((swift_name("sofZmanAchilasChametz")));
@property (class, readonly) STTZmanType *sofZmanBiurChametz __attribute__((swift_name("sofZmanBiurChametz")));
@property (class, readonly) STTZmanType *earliestMincha __attribute__((swift_name("earliestMincha")));
@property (class, readonly) STTZmanType *earliestKiddushLevana __attribute__((swift_name("earliestKiddushLevana")));
@property (class, readonly) STTZmanType *sofZmanKiddushLevana __attribute__((swift_name("sofZmanKiddushLevana")));
@property (class, readonly) STTZmanType *candleLighting __attribute__((swift_name("candleLighting")));
+ (STTKotlinArray<STTZmanType *> *)values __attribute__((swift_name("values()")));
@property (class, readonly) NSArray<STTZmanType *> *entries __attribute__((swift_name("entries")));
- (STTOccurrence *)occursMagnitudeOfOccurrence:(int64_t)magnitudeOfOccurrence __attribute__((swift_name("occurs(magnitudeOfOccurrence:)")));
- (STTOccurrence *)occursTime:(STTZmanCalculationMethodDegrees *)time __attribute__((swift_name("occurs(time:)")));
- (STTOccurrence *)occursMagnitudeOfOccurrence_:(STTZmanCalculationMethodFixedDuration *)magnitudeOfOccurrence __attribute__((swift_name("occurs(magnitudeOfOccurrence_:)")));
- (STTOccurrence *)occursMagnitudeOfOccurrence__:(STTZmanCalculationMethodZmaniyosDuration *)magnitudeOfOccurrence __attribute__((swift_name("occurs(magnitudeOfOccurrence__:)")));
@property (readonly) NSString *friendlyNameEnglish __attribute__((swift_name("friendlyNameEnglish")));
@property (readonly) NSString *friendlyNameHebrew __attribute__((swift_name("friendlyNameHebrew")));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("ZmanType.Companion")))
@interface STTZmanTypeCompanion : STTBase
+ (instancetype)alloc __attribute__((unavailable));
+ (instancetype)allocWithZone:(struct _NSZone *)zone __attribute__((unavailable));
+ (instancetype)companion __attribute__((swift_name("init()")));
@property (class, readonly, getter=shared) STTZmanTypeCompanion *shared __attribute__((swift_name("shared")));
@property (readonly) NSDictionary<STTZmanType *, STTFloat *> *shaosZmaniyosIntoDay __attribute__((swift_name("shaosZmaniyosIntoDay")));
@end


/**
 * An abstract class that all sun time calculating classes extend. This allows the algorithm used to be changed at
 * runtime, easily allowing comparison the results of using different algorithms.
 * @todo Consider methods that would allow atmospheric modeling. This can currently be adjusted by [refraction].
 *
 * @author  Eliyahu Hershfeld 2004 - 2023
 */
__attribute__((swift_name("AstronomicalCalculator")))
@interface STTAstronomicalCalculator : STTBase

/**
 * An abstract class that all sun time calculating classes extend. This allows the algorithm used to be changed at
 * runtime, easily allowing comparison the results of using different algorithms.
 * @todo Consider methods that would allow atmospheric modeling. This can currently be adjusted by [refraction].
 *
 * @author  Eliyahu Hershfeld 2004 - 2023
 */
- (instancetype)init __attribute__((swift_name("init()"))) __attribute__((objc_designated_initializer));

/**
 * An abstract class that all sun time calculating classes extend. This allows the algorithm used to be changed at
 * runtime, easily allowing comparison the results of using different algorithms.
 * @todo Consider methods that would allow atmospheric modeling. This can currently be adjusted by [refraction].
 *
 * @author  Eliyahu Hershfeld 2004 - 2023
 */
+ (instancetype)new __attribute__((availability(swift, unavailable, message="use object initializers instead")));
@property (class, readonly, getter=companion) STTAstronomicalCalculatorCompanion *companion __attribute__((swift_name("companion")));

/**
 * Adjusts the zenith of astronomical sunrise and sunset to account for solar refraction, solar radius and
 * elevation. The value for Sun's zenith and true rise/set Zenith (used in this class and subclasses) is the angle
 * that the center of the Sun makes to a line perpendicular to the Earth's surface. If the Sun were a point and the
 * Earth were without an atmosphere, true sunset and sunrise would correspond to a 90 zenith. Because the Sun
 * is not a point, and because the atmosphere refracts light, this 90 zenith does not, in fact, correspond to
 * true sunset or sunrise, instead the center of the Sun's disk must lie just below the horizon for the upper edge
 * to be obscured. This means that a zenith of just above 90 must be used. The Sun subtends an angle of 16
 * minutes of arc (this can be changed via the [.setSolarRadius] method , and atmospheric refraction
 * accounts for 34 minutes or so (this can be changed via the [.setRefraction] method), giving a total
 * of 50 arcminutes. The total value for ZENITH is 90+(5/6) or 90.8333333 for true sunrise/sunset. Since a
 * person at an elevation can see blow the horizon of a person at sea level, this will also adjust the zenith to
 * account for elevation if available. Note that this will only adjust the value if the zenith is exactly 90 degrees.
 * For values below and above this no correction is done. As an example, astronomical twilight is when the sun is
 * 18 below the horizon or [108˚][com.kosherjava.zmanim.AstronomicalCalendar.ASTRONOMICAL_ZENITH]. This is traditionally calculated with none of the above mentioned adjustments. The same goes
 * for various *tzais* and *alos* times such as the
 * [16.1˚][com.kosherjava.zmanim.ZmanimCalendarZENITH_16_POINT_1] dip used in
 * [com.kosherjava.zmanim.ComplexZmanimCalendar.getAlos16Point1Degrees].
 *
 * @param zenith
 * the azimuth below the vertical zenith of 90. For sunset typically the [zenith][.adjustZenith] used for the calculation uses geometric zenith of 90 and [adjusts][.adjustZenith]
 * this slightly to account for solar refraction and the sun's radius. Another example would be
 * [com.kosherjava.zmanim.AstronomicalCalendar.getEndNauticalTwilight] that passes
 * [com.kosherjava.zmanim.AstronomicalCalendar.NAUTICAL_ZENITH] to this method.
 * @param elevation
 * elevation in Meters.
 * @return The zenith adjusted to include the [sun&#39;s radius][solarRadius], [refraction][.getRefraction] and [elevation][.getElevationAdjustment] adjustment. This will only be adjusted for
 * sunrise and sunset (if the zenith == 90)
 * @see .getElevationAdjustment
 */
- (double)adjustZenithZenith:(double)zenith elevation:(double)elevation __attribute__((swift_name("adjustZenith(zenith:elevation:)")));
- (STTAstronomicalCalculator *)doCopy __attribute__((swift_name("doCopy()")));

/**
 * Method to return the adjustment to the zenith required to account for the elevation. Since a person at a higher
 * elevation can see farther below the horizon, the calculation for sunrise / sunset is calculated below the horizon
 * used at sea level. This is only used for sunrise and sunset and not times before or after it such as
 * [nautical twilight][com.kosherjava.zmanim.AstronomicalCalendar.getBeginNauticalTwilight] since those
 * calculations are based on the level of available light at the given dip below the horizon, something that is not
 * affected by elevation, the adjustment should only made if the zenith == 90 [adjusted][.adjustZenith]
 * for refraction and solar radius. The algorithm used is
 *
 * <pre>
 * elevationAdjustment = Math.toDegrees(Math.acos(earthRadiusInMeters / (earthRadiusInMeters + elevationMeters)));
</pre> *
 *
 * The source of this algorithm is [Calendrical Calculations](http://www.calendarists.com) by Edward M.
 * Reingold and Nachum Dershowitz. An alternate algorithm that produces an almost identical (but not accurate)
 * result found in Ma'aglay Tzedek by Moishe Kosower and other sources is:
 *
 * <pre>
 * elevationAdjustment = 0.0347 * Math.sqrt(elevationMeters);
</pre> *
 *
 * @param elevation
 * elevation in Meters.
 * @return the adjusted zenith
 */
- (double)getElevationAdjustmentElevation:(double)elevation __attribute__((swift_name("getElevationAdjustment(elevation:)")));

/**
 * Return [solar noon](https://en.wikipedia.org/wiki/Noon#Solar_noon) (UTC) for the given day at the
 * given location on earth. The the [com.kosherjava.zmanim.util.NOAACalculator] implementation calculates
 * true solar noon, while the [com.kosherjava.zmanim.util.SunTimesCalculator] approximates it, calculating
 * the time as halfway between sunrise and sunset.
 *
 * @param date
 * Used to calculate day of year.
 * @param geoLocation
 * The location information used for astronomical calculating sun times.
 *
 * @return the time in minutes from zero UTC
 */
- (double)getUTCNoonDate:(STTKotlinx_datetimeLocalDate *)date geoLocation:(STTGeoLocation *)geoLocation __attribute__((swift_name("getUTCNoon(date:geoLocation:)")));

/**
 * A method that calculates UTC sunrise as well as any time based on an angle above or below sunrise. This abstract
 * method is implemented by the classes that extend this class.
 *
 * @param calendar
 * Used to calculate day of year.
 * @param geoLocation
 * The location information used for astronomical calculating sun times.
 * @param zenith
 * the azimuth below the vertical zenith of 90 degrees. for sunrise typically the [zenith][.adjustZenith] used for the calculation uses geometric zenith of 90 and [adjusts][.adjustZenith]
 * this slightly to account for solar refraction and the sun's radius. Another example would be
 * [com.kosherjava.zmanim.AstronomicalCalendar.getBeginNauticalTwilight] that passes
 * [com.kosherjava.zmanim.AstronomicalCalendar.NAUTICAL_ZENITH] to this method.
 * @param adjustForElevation
 * Should the time be adjusted for elevation
 * @return The UTC time of sunrise in 24 hour format. 5:45:00 AM will return 5.75.0. If an error was encountered in
 * the calculation (expected behavior for some locations such as near the poles,
 * [Double.NaN] will be returned.
 * @see .getElevationAdjustment
 */
- (double)getUTCSunriseLocalDate:(STTKotlinx_datetimeLocalDate *)LocalDate geoLocation:(STTGeoLocation *)geoLocation zenith:(double)zenith adjustForElevation:(BOOL)adjustForElevation __attribute__((swift_name("getUTCSunrise(LocalDate:geoLocation:zenith:adjustForElevation:)")));

/**
 * A method that calculates UTC sunset as well as any time based on an angle above or below sunset. This abstract
 * method is implemented by the classes that extend this class.
 *
 * @param LocalDate
 * Used to calculate day of year.
 * @param geoLocation
 * The location information used for astronomical calculating sun times.
 * @param zenith
 * the azimuth below the vertical zenith of 90. For sunset typically the [zenith][adjustZenith] used for the calculation uses geometric zenith of 90 and [adjusts][.adjustZenith]
 * this slightly to account for solar refraction and the sun's radius. Another example would be
 * [com.kosherjava.zmanim.AstronomicalCalendar.getEndNauticalTwilight] that passes
 * [com.kosherjava.zmanim.AstronomicalCalendar.NAUTICAL_ZENITH] to this method.
 * @param adjustForElevation
 * Should the time be adjusted for elevation
 * @return The UTC time of sunset in 24 hour format. 5:45:00 AM will return 5.75.0. If an error was encountered in
 * the calculation (expected behavior for some locations such as near the poles,
 * [Double.NaN] will be returned.
 * @see .getElevationAdjustment
 */
- (double)getUTCSunsetLocalDate:(STTKotlinx_datetimeLocalDate *)LocalDate geoLocation:(STTGeoLocation *)geoLocation zenith:(double)zenith adjustForElevation:(BOOL)adjustForElevation __attribute__((swift_name("getUTCSunset(LocalDate:geoLocation:zenith:adjustForElevation:)")));

/**
 * Returns the name of the algorithm.
 *
 * @return the descriptive name of the algorithm.
 */
@property (readonly) NSString *calculatorName __attribute__((swift_name("calculatorName")));

/**
 * The commonly used average earth radius in KM. At this time, this only affects elevation adjustment and not the
 * sunrise and sunset calculations. The value currently defaults to 6356.9 KM.
 *
 * @see .getEarthRadius
 * @see .setEarthRadius
 */
@property double earthRadius __attribute__((swift_name("earthRadius")));

/**
 * The commonly used average solar refraction. Calendrical Calculations lists a more accurate global average of
 * 34.478885263888294
 *
 * @see .getRefraction
 */
@property double refraction __attribute__((swift_name("refraction")));

/**
 * The commonly used average solar radius in minutes of a degree.
 *
 * @see solarRadius
 */
@property double solarRadius __attribute__((swift_name("solarRadius")));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("AstronomicalCalculator.Companion")))
@interface STTAstronomicalCalculatorCompanion : STTBase
+ (instancetype)alloc __attribute__((unavailable));
+ (instancetype)allocWithZone:(struct _NSZone *)zone __attribute__((unavailable));
+ (instancetype)companion __attribute__((swift_name("init()")));
@property (class, readonly, getter=shared) STTAstronomicalCalculatorCompanion *shared __attribute__((swift_name("shared")));

/**
 * Converts an angle measured in radians to an approximately
 * equivalent angle measured in degrees.  The conversion from
 * radians to degrees is generally inexact; users should
 * *not* expect `cos(toRadians(90.0))` to exactly
 * equal `0.0`.
 *
 * @param   angrad   an angle, in radians
 * @return  the measurement of the angle `angrad`
 * in degrees.
 * @since   1.2
 */
- (double)toDegreesAngrad:(double)angrad __attribute__((swift_name("toDegrees(angrad:)")));

/**
 * Converts an angle measured in degrees to an approximately
 * equivalent angle measured in radians.  The conversion from
 * degrees to radians is generally inexact.
 *
 * @param   angdeg   an angle, in degrees
 * @return  the measurement of the angle `angdeg`
 * in radians.
 * @since   1.2
 */
- (double)toRadiansAngdeg:(double)angdeg __attribute__((swift_name("toRadians(angdeg:)")));

/**
 * Constant by which to multiply an angular value in degrees to obtain an
 * angular value in radians.
 */
@property (readonly) double DEGREES_TO_RADIANS __attribute__((swift_name("DEGREES_TO_RADIANS")));

/**
 * Constant by which to multiply an angular value in radians to obtain an
 * angular value in degrees.
 */
@property (readonly) double RADIANS_TO_DEGREES __attribute__((swift_name("RADIANS_TO_DEGREES")));

/**
 * Returns the default class for calculating sunrise and sunset. This is currently the [NOAACalculator],
 * but this may change.
 *
 * @return AstronomicalCalculator the default class for calculating sunrise and sunset. In the current
 * implementation the default calculator returned is the [NOAACalculator].
 */
@property (readonly, getter=default) STTAstronomicalCalculator *default_ __attribute__((swift_name("default_")));
@end


/**
 * TODO this is debateably an anti-pattern. Figure out where to put these functinos.
 * */
__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("DateUtils")))
@interface STTDateUtils : STTBase
+ (instancetype)alloc __attribute__((unavailable));

/**
 * TODO this is debateably an anti-pattern. Figure out where to put these functinos.
 * */
+ (instancetype)allocWithZone:(struct _NSZone *)zone __attribute__((unavailable));
+ (instancetype)dateUtils __attribute__((swift_name("init()")));
@property (class, readonly, getter=shared) STTDateUtils *shared __attribute__((swift_name("shared")));

/**
 * Return the [Julian day](http://en.wikipedia.org/wiki/Julian_day) from a Java LocalDate.
 *
 * @param date
 * The Java LocalDate of the date to be calculated
 * @return the Julian day number corresponding to the date  Note: Number is returned for start of day. Fractional days
 * should be added later.
 */
- (double)getJulianDayDate:(STTKotlinx_datetimeLocalDate *)date __attribute__((swift_name("getJulianDay(date:)")));
- (STTKotlinx_datetimeLocalDate *)now:(STTKotlinx_datetimeLocalDateCompanion *)receiver __attribute__((swift_name("now(_:)")));
@end


/**
 * A class that contains location information such as latitude and longitude required for astronomical calculations. The
 * elevation field may not be used by some calculation engines and would be ignored if set. Check the documentation for
 * specific implementations of the [AstronomicalCalculator] to see if elevation is calculated as part of the
 * algorithm.
 *
 * @author  Eliyahu Hershfeld 2004 - 2022
 */
__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("GeoLocation")))
@interface STTGeoLocation : STTBase

/**
 * Default GeoLocation constructor will set location to the Prime Meridian at Greenwich, England and a TimeZone of
 * GMT. The longitude will be set to 0 and the latitude will be 51.4772 to match the location of the [Royal Observatory, Greenwich](https://www.rmg.co.uk/royal-observatory). No daylight savings time will be used.
 */
- (instancetype)init __attribute__((swift_name("init()"))) __attribute__((objc_designated_initializer));

/**
 * Default GeoLocation constructor will set location to the Prime Meridian at Greenwich, England and a TimeZone of
 * GMT. The longitude will be set to 0 and the latitude will be 51.4772 to match the location of the [Royal Observatory, Greenwich](https://www.rmg.co.uk/royal-observatory). No daylight savings time will be used.
 */
+ (instancetype)new __attribute__((availability(swift, unavailable, message="use object initializers instead")));
- (instancetype)initWithLocation:(STTLocation *)location __attribute__((swift_name("init(location:)"))) __attribute__((objc_designated_initializer));
- (instancetype)initWithTimeZone:(STTKotlinx_datetimeTimeZone *)timeZone locationName:(NSString *)locationName __attribute__((swift_name("init(timeZone:locationName:)"))) __attribute__((objc_designated_initializer));

/**
 * GeoLocation constructor with parameters for all required fields.
 *
 * @param name
 * The location name for display use such as &quot;Lakewood, NJ&quot;
 * @param latitude
 * the latitude in a double format such as 40.095965 for Lakewood, NJ.
 * **Note:** For latitudes south of the equator, a negative value should be used.
 * @param longitude
 * double the longitude in a double format such as -74.222130 for Lakewood, NJ.
 * **Note:** For longitudes east of the [Prime Meridian](https://en.wikipedia.org/wiki/Prime_Meridian) (Greenwich),
 * a negative value should be used.
 * @param timeZone
 * the `TimeZone` for the location.
 */
- (instancetype)initWithName:(NSString *)name latitude:(double)latitude longitude:(double)longitude timeZone:(STTKotlinx_datetimeTimeZone *)timeZone __attribute__((swift_name("init(name:latitude:longitude:timeZone:)"))) __attribute__((objc_designated_initializer));

/**
 * GeoLocation constructor with parameters for all required fields.
 *
 * @param name
 * The location name for display use such as &quot;Lakewood, NJ&quot;
 * @param latitude
 * the latitude in a double format such as 40.095965 for Lakewood, NJ.
 * **Note:** For latitudes south of the equator, a negative value should be used.
 * @param longitude
 * double the longitude in a double format such as -74.222130 for Lakewood, NJ.
 * **Note:** For longitudes east of the [Prime
 * Meridian](https://en.wikipedia.org/wiki/Prime_Meridian) (Greenwich), a negative value should be used.
 * @param elevation
 * the elevation above sea level in Meters. Elevation is not used in most algorithms used for calculating
 * sunrise and set.
 * @param timeZone
 * the `TimeZone` for the location.
 */
- (instancetype)initWithName:(NSString *)name latitude:(double)latitude longitude:(double)longitude elevation:(double)elevation timeZone:(STTKotlinx_datetimeTimeZone *)timeZone __attribute__((swift_name("init(name:latitude:longitude:elevation:timeZone:)"))) __attribute__((objc_designated_initializer));
@property (class, readonly, getter=companion) STTGeoLocationCompanion *companion __attribute__((swift_name("companion")));

/**
 * A class that contains location information such as latitude and longitude required for astronomical calculations. The
 * elevation field may not be used by some calculation engines and would be ignored if set. Check the documentation for
 * specific implementations of the [AstronomicalCalculator] to see if elevation is calculated as part of the
 * algorithm.
 *
 * @author  Eliyahu Hershfeld 2004 - 2022
 */
- (STTGeoLocation *)doCopyTimeZone:(STTKotlinx_datetimeTimeZone *)timeZone locationName:(NSString *)locationName __attribute__((swift_name("doCopy(timeZone:locationName:)")));

/**
 * @see Object.equals
 */
- (BOOL)isEqual:(id _Nullable)other __attribute__((swift_name("isEqual(_:)")));

/**
 * Calculate [geodesic distance](https://en.wikipedia.org/wiki/Great-circle_distance) in Meters between
 * this Object and a second Object passed to this method using [Thaddeus Vincenty's](https://en.wikipedia.org/wiki/Thaddeus_Vincenty) inverse formula See T Vincenty, "[Direct and Inverse Solutions of Geodesics on the Ellipsoid
 * with application of nested equations](https://www.ngs.noaa.gov/PUBS_LIB/inverse.pdf)", Survey Review, vol XXII no 176, 1975
 *
 * @see .vincentyFormula
 * @param location
 * the destination location
 * @return the geodesic distance in Meters
 */
- (double)getGeodesicDistanceLocation:(STTGeoLocation *)location __attribute__((swift_name("getGeodesicDistance(location:)")));

/**
 * Calculate the final [geodesic](https://en.wikipedia.org/wiki/Great_circle) bearing between this Object
 * and a second Object passed to this method using [Thaddeus
 * Vincenty's](https://en.wikipedia.org/wiki/Thaddeus_Vincenty) inverse formula See T Vincenty, "[Direct and
 * Inverse Solutions of Geodesics on the Ellipsoid with application of nested equations](https://www.ngs.noaa.gov/PUBS_LIB/inverse.pdf)", Survey Review, vol
 * XXII no 176, 1975
 *
 * @param location
 * the destination location
 * @return the final bearing
 */
- (double)getGeodesicFinalBearingLocation:(STTGeoLocation *)location __attribute__((swift_name("getGeodesicFinalBearing(location:)")));

/**
 * Calculate the initial [geodesic](https://en.wikipedia.org/wiki/Great_circle) bearing between this
 * Object and a second Object passed to this method using [Thaddeus Vincenty's](https://en.wikipedia.org/wiki/Thaddeus_Vincenty) inverse formula See T Vincenty, "[Direct and Inverse Solutions of Geodesics on the Ellipsoid
 * with application of nested equations](https://www.ngs.noaa.gov/PUBS_LIB/inverse.pdf)", Survey Review, vol XXII no 176, 1975
 *
 * @param location
 * the destination location
 * @return the initial bearing
 */
- (double)getGeodesicInitialBearingLocation:(STTGeoLocation *)location __attribute__((swift_name("getGeodesicInitialBearing(location:)")));

/**
 * Returns the [rhumb line](https://en.wikipedia.org/wiki/Rhumb_line) bearing from the current location to
 * the GeoLocation passed in.
 *
 * @param location
 * destination location
 * @return the bearing in degrees
 */
- (double)getRhumbLineBearingLocation:(STTGeoLocation *)location __attribute__((swift_name("getRhumbLineBearing(location:)")));

/**
 * Returns the [rhumb line](https://en.wikipedia.org/wiki/Rhumb_line) distance from the current location
 * to the GeoLocation passed in.
 *
 * @param location
 * the destination location
 * @return the distance in Meters
 */
- (double)getRhumbLineDistanceLocation:(STTGeoLocation *)location __attribute__((swift_name("getRhumbLineDistance(location:)")));

/**
 * @see Object.hashCode
 */
- (NSUInteger)hash __attribute__((swift_name("hash()")));

/**
 * Method to set the latitude in degrees, minutes and seconds.
 *
 * @param degrees
 * The degrees of latitude to set between 0 and 90. For example 40 would be used for Lakewood, NJ.
 * An IllegalArgumentException will be thrown if the value exceeds the limit.
 * @param minutes
 * [minutes of arc](https://en.wikipedia.org/wiki/Minute_of_arc#Cartography)
 * @param seconds
 * [seconds of arc](https://en.wikipedia.org/wiki/Minute_of_arc#Cartography)
 * @param direction
 * N for north and S for south. An IllegalArgumentException will be thrown if the value is not S or N.
 */
- (STTGeoLocation *)setLatitudeDegrees:(int32_t)degrees minutes:(int32_t)minutes seconds:(double)seconds direction:(NSString *)direction __attribute__((swift_name("setLatitude(degrees:minutes:seconds:direction:)")));

/**
 * Method to set the longitude in degrees, minutes and seconds.
 *
 * @param degrees
 * The degrees of longitude to set between 0 and 180. As an example 74 would be set for Lakewood, NJ.
 * An IllegalArgumentException will be thrown if the value exceeds the limits.
 * @param minutes
 * [minutes of arc](https://en.wikipedia.org/wiki/Minute_of_arc#Cartography)
 * @param seconds
 * [seconds of arc](https://en.wikipedia.org/wiki/Minute_of_arc#Cartography)
 * @param direction
 * E for east of the [Prime Meridian](https://en.wikipedia.org/wiki/Prime_Meridian) or W for west of it.
 * An IllegalArgumentException will be thrown if
 * the value is not E or W.
 */
- (STTGeoLocation *)setLongitudeDegrees:(int32_t)degrees minutes:(int32_t)minutes seconds:(double)seconds direction:(NSString *)direction __attribute__((swift_name("setLongitude(degrees:minutes:seconds:direction:)")));

/**
 * @see Object.toString
 */
- (NSString *)description __attribute__((swift_name("description()")));

/**
 * A method that returns an XML formatted `String` representing the serialized `Object`. Very
 * similar to the toString method but the return value is in an xml format. The format currently used (subject to
 * change) is:
 *
 * <pre>
 * <GeoLocation>
 * <LocationName>Lakewood, NJ</LocationName>
 * <Latitude>40.0828&amp;deg</Latitude>
 * <Longitude>-74.2094&amp;deg</Longitude>
 * <Elevation>0 Meters</Elevation>
 * <TimezoneName>America/New_York</TimezoneName>
 * <TimeZoneDisplayName>Eastern Standard Time</TimeZoneDisplayName>
 * <TimezoneGMTOffset>-5</TimezoneGMTOffset>
 * <TimezoneDSTOffset>1</TimezoneDSTOffset>
 * </GeoLocation>
</pre> *
 *
 * @return The XML formatted `String`.
 */
- (NSString *)toXML __attribute__((swift_name("toXML()")));

/**
 * Adjust the date for [antimeridian](https://en.wikipedia.org/wiki/180th_meridian) crossover. This is
 * needed to deal with edge cases such as Samoa that use a different LocalDate date than expected based on their
 * geographic location.
 *
 * The actual Time Zone offset may deviate from the expected offset based on the longitude. Since the 'absolute time'
 * calculations are always based on longitudinal offset from UTC for a given date, the date is presumed to only
 * increase East of the Prime Meridian, and to only decrease West of it. For Time Zones that cross the antimeridian,
 * the date will be artificially adjusted before calculation to conform with this presumption.
 *
 * For example, Apia, Samoa with a longitude of -171.75 uses a local offset of +14:00.  When calculating sunrise for
 * 2018-02-03, the calculator should operate using 2018-02-02 since the expected zone is -11.  After determining the
 * UTC time, the local DST offset of [UTC+14:00](https://en.wikipedia.org/wiki/UTC%2B14:00) should be applied
 * to bring the date back to 2018-02-03.
 *
 * @return the number of days to adjust the date This will typically be 0 unless the date crosses the antimeridian
 */
@property (readonly) int32_t antimeridianAdjustment __attribute__((swift_name("antimeridianAdjustment")));

/**
 * The elevation in Meters
 */
@property double elevation __attribute__((swift_name("elevation")));
@property double latitude __attribute__((swift_name("latitude")));

/**
 * A method that will return the location's local mean time offset in milliseconds from local [standard time](https://en.wikipedia.org/wiki/Standard_time). The globe is split into 360, with
 * 15 per hour of the day. For a local that is at a longitude that is evenly divisible by 15 (longitude % 15 ==
 * 0), at solar [noon][com.kosherjava.zmanim.AstronomicalCalendar.getSunTransit] (with adjustment for the [equation of time](https://en.wikipedia.org/wiki/Equation_of_time)) the sun should be directly overhead,
 * so a user who is 1 west of this will have noon at 4 minutes after standard time noon, and conversely, a user
 * who is 1 east of the 15 longitude will have noon at 11:56 AM. Lakewood, N.J., whose longitude is
 * -74.2094, is 0.7906 away from the closest multiple of 15 at -75. This is multiplied by 4 to yield 3 minutes
 * and 10 seconds earlier than standard time. The offset returned does not account for the [Daylight saving time](https://en.wikipedia.org/wiki/Daylight_saving_time) offset since this class is
 * unaware of dates.
 *
 * @return the offset in milliseconds not accounting for Daylight saving time. A positive value will be returned
 * East of the 15 timezone line, and a negative value West of it.
 * @since 1.1
 */
@property (readonly) int64_t localMeanTimeOffset __attribute__((swift_name("localMeanTimeOffset")));
@property NSString *locationName __attribute__((swift_name("locationName")));
@property double longitude __attribute__((swift_name("longitude")));

/**
 * If this is ever set after the GeoLocation is set in the
 * [com.kosherjava.zmanim.AstronomicalCalendar], it is critical that
 * [com.kosherjava.zmanim.AstronomicalCalendar.localDateTime].[setTimeZone(TimeZone)][java.util.Calendar.setTimeZone] be called in order for the
 * AstronomicalCalendar to output times in the expected offset. This situation will arise if the
 * AstronomicalCalendar is ever [cloned][com.kosherjava.zmanim.AstronomicalCalendar.clone].
 */
@property STTKotlinx_datetimeTimeZone *timeZone __attribute__((swift_name("timeZone")));
@end


/**
 * An implementation of the [Object.clone] method that creates a [deep copy](https://en.wikipedia.org/wiki/Object_copy#Deep_copy) of the object.
 * **Note:** If the [TimeZone] in the clone will be changed from the original, it is critical
 * that [com.kosherjava.zmanim.AstronomicalCalendar.getCalendar].
 * [setTimeZone(TimeZone)][java.util.Calendar.setTimeZone] is called after cloning in order for the
 * AstronomicalCalendar to output times in the expected offset.
 *
 * @see Object.clone
 * @since 1.1
 */
__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("GeoLocation.Companion")))
@interface STTGeoLocationCompanion : STTBase
+ (instancetype)alloc __attribute__((unavailable));

/**
 * An implementation of the [Object.clone] method that creates a [deep copy](https://en.wikipedia.org/wiki/Object_copy#Deep_copy) of the object.
 * **Note:** If the [TimeZone] in the clone will be changed from the original, it is critical
 * that [com.kosherjava.zmanim.AstronomicalCalendar.getCalendar].
 * [setTimeZone(TimeZone)][java.util.Calendar.setTimeZone] is called after cloning in order for the
 * AstronomicalCalendar to output times in the expected offset.
 *
 * @see Object.clone
 * @since 1.1
 */
+ (instancetype)allocWithZone:(struct _NSZone *)zone __attribute__((unavailable));
+ (instancetype)companion __attribute__((swift_name("init()")));
@property (class, readonly, getter=shared) STTGeoLocationCompanion *shared __attribute__((swift_name("shared")));
- (int32_t)rawOffset:(STTKotlinx_datetimeTimeZone *)receiver __attribute__((swift_name("rawOffset(_:)")));
@property (readonly) NSDictionary<NSString *, STTInt *> *mapOfTimeZoneIdToRawOffsetInMillis __attribute__((swift_name("mapOfTimeZoneIdToRawOffsetInMillis")));
@end


/**
 * Represents a coordinate on the globe. In contrast to [GeoLocation] which has an associated timezone and place name,
 * [Location] may not. This is to accommodate various platforms, which may not expose as rich information as [GeoLocation]
 * requires.
 *
 * @param timestamp epoch milliseconds when the location was last updated.
 * On some platforms (e.g. Kotlin/JS) this can be significantly delayed (I think e.g. if the user is offline, etc.)
 * compared to when the location flow is updated.
 * @param accuracy the margin of error in latitude and longitude. A smaller number means the [latitude] and [longitude]
 * are more accurate.
 * */
__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("Location")))
@interface STTLocation : STTBase
- (instancetype)initWithLatitude:(double)latitude longitude:(double)longitude elevation:(STTDouble * _Nullable)elevation accuracy:(STTDouble * _Nullable)accuracy timestamp:(STTLong * _Nullable)timestamp tz:(STTKotlinx_datetimeTimeZone * _Nullable)tz locationName:(NSString * _Nullable)locationName __attribute__((swift_name("init(latitude:longitude:elevation:accuracy:timestamp:tz:locationName:)"))) __attribute__((objc_designated_initializer));

/**
 * Represents a coordinate on the globe. In contrast to [GeoLocation] which has an associated timezone and place name,
 * [Location] may not. This is to accommodate various platforms, which may not expose as rich information as [GeoLocation]
 * requires.
 *
 * @param timestamp epoch milliseconds when the location was last updated.
 * On some platforms (e.g. Kotlin/JS) this can be significantly delayed (I think e.g. if the user is offline, etc.)
 * compared to when the location flow is updated.
 * @param accuracy the margin of error in latitude and longitude. A smaller number means the [latitude] and [longitude]
 * are more accurate.
 * */
- (STTLocation *)doCopyLatitude:(double)latitude longitude:(double)longitude elevation:(STTDouble * _Nullable)elevation accuracy:(STTDouble * _Nullable)accuracy timestamp:(STTLong * _Nullable)timestamp tz:(STTKotlinx_datetimeTimeZone * _Nullable)tz locationName:(NSString * _Nullable)locationName __attribute__((swift_name("doCopy(latitude:longitude:elevation:accuracy:timestamp:tz:locationName:)")));

/**
 * Represents a coordinate on the globe. In contrast to [GeoLocation] which has an associated timezone and place name,
 * [Location] may not. This is to accommodate various platforms, which may not expose as rich information as [GeoLocation]
 * requires.
 *
 * @param timestamp epoch milliseconds when the location was last updated.
 * On some platforms (e.g. Kotlin/JS) this can be significantly delayed (I think e.g. if the user is offline, etc.)
 * compared to when the location flow is updated.
 * @param accuracy the margin of error in latitude and longitude. A smaller number means the [latitude] and [longitude]
 * are more accurate.
 * */
- (BOOL)isEqual:(id _Nullable)other __attribute__((swift_name("isEqual(_:)")));

/**
 * Represents a coordinate on the globe. In contrast to [GeoLocation] which has an associated timezone and place name,
 * [Location] may not. This is to accommodate various platforms, which may not expose as rich information as [GeoLocation]
 * requires.
 *
 * @param timestamp epoch milliseconds when the location was last updated.
 * On some platforms (e.g. Kotlin/JS) this can be significantly delayed (I think e.g. if the user is offline, etc.)
 * compared to when the location flow is updated.
 * @param accuracy the margin of error in latitude and longitude. A smaller number means the [latitude] and [longitude]
 * are more accurate.
 * */
- (NSUInteger)hash __attribute__((swift_name("hash()")));

/**
 * Represents a coordinate on the globe. In contrast to [GeoLocation] which has an associated timezone and place name,
 * [Location] may not. This is to accommodate various platforms, which may not expose as rich information as [GeoLocation]
 * requires.
 *
 * @param timestamp epoch milliseconds when the location was last updated.
 * On some platforms (e.g. Kotlin/JS) this can be significantly delayed (I think e.g. if the user is offline, etc.)
 * compared to when the location flow is updated.
 * @param accuracy the margin of error in latitude and longitude. A smaller number means the [latitude] and [longitude]
 * are more accurate.
 * */
- (NSString *)description __attribute__((swift_name("description()")));
@property (readonly) STTDouble * _Nullable accuracy __attribute__((swift_name("accuracy")));
@property (readonly) STTDouble * _Nullable elevation __attribute__((swift_name("elevation")));
@property (readonly) double latitude __attribute__((swift_name("latitude")));
@property (readonly) NSString * _Nullable locationName __attribute__((swift_name("locationName")));
@property (readonly) double longitude __attribute__((swift_name("longitude")));
@property (readonly) STTLong * _Nullable timestamp __attribute__((swift_name("timestamp")));
@property (readonly) STTKotlinx_datetimeTimeZone * _Nullable tz __attribute__((swift_name("tz")));
@end


/**
 * Implementation of sunrise and sunset methods to calculate astronomical times based on the [NOAA](https://noaa.gov) algorithm. This calculator uses the Java algorithm based on the implementation by [NOAA - National Oceanic and Atmospheric Administration](https://noaa.gov)'s [Surface Radiation Research Branch](https://www.srrb.noaa.gov/highlights/sunrise/sunrise.html). NOAA's [implementation](https://www.srrb.noaa.gov/highlights/sunrise/solareqns.PDF) is based on equations from [Astronomical Algorithms](https://www.amazon.com/Astronomical-Table-Sun-Moon-Planets/dp/1942675038/) by [Jean Meeus](https://en.wikipedia.org/wiki/Jean_Meeus). Added to the algorithm is an adjustment of the zenith
 * to account for elevation. The algorithm can be found in the [Wikipedia Sunrise Equation](https://en.wikipedia.org/wiki/Sunrise_equation) article.
 *
 * @author  Eliyahu Hershfeld 2011 - 2023
 */
__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("NOAACalculator")))
@interface STTNOAACalculator : STTAstronomicalCalculator

/**
 * Implementation of sunrise and sunset methods to calculate astronomical times based on the [NOAA](https://noaa.gov) algorithm. This calculator uses the Java algorithm based on the implementation by [NOAA - National Oceanic and Atmospheric Administration](https://noaa.gov)'s [Surface Radiation Research Branch](https://www.srrb.noaa.gov/highlights/sunrise/sunrise.html). NOAA's [implementation](https://www.srrb.noaa.gov/highlights/sunrise/solareqns.PDF) is based on equations from [Astronomical Algorithms](https://www.amazon.com/Astronomical-Table-Sun-Moon-Planets/dp/1942675038/) by [Jean Meeus](https://en.wikipedia.org/wiki/Jean_Meeus). Added to the algorithm is an adjustment of the zenith
 * to account for elevation. The algorithm can be found in the [Wikipedia Sunrise Equation](https://en.wikipedia.org/wiki/Sunrise_equation) article.
 *
 * @author  Eliyahu Hershfeld 2011 - 2023
 */
- (instancetype)init __attribute__((swift_name("init()"))) __attribute__((objc_designated_initializer));

/**
 * Implementation of sunrise and sunset methods to calculate astronomical times based on the [NOAA](https://noaa.gov) algorithm. This calculator uses the Java algorithm based on the implementation by [NOAA - National Oceanic and Atmospheric Administration](https://noaa.gov)'s [Surface Radiation Research Branch](https://www.srrb.noaa.gov/highlights/sunrise/sunrise.html). NOAA's [implementation](https://www.srrb.noaa.gov/highlights/sunrise/solareqns.PDF) is based on equations from [Astronomical Algorithms](https://www.amazon.com/Astronomical-Table-Sun-Moon-Planets/dp/1942675038/) by [Jean Meeus](https://en.wikipedia.org/wiki/Jean_Meeus). Added to the algorithm is an adjustment of the zenith
 * to account for elevation. The algorithm can be found in the [Wikipedia Sunrise Equation](https://en.wikipedia.org/wiki/Sunrise_equation) article.
 *
 * @author  Eliyahu Hershfeld 2011 - 2023
 */
+ (instancetype)new __attribute__((availability(swift, unavailable, message="use object initializers instead")));
@property (class, readonly, getter=companion) STTNOAACalculatorCompanion *companion __attribute__((swift_name("companion")));
- (STTAstronomicalCalculator *)doCopy __attribute__((swift_name("doCopy()")));

/**
 * Return the [Universal Coordinated Time](https://en.wikipedia.org/wiki/Universal_Coordinated_Time) (UTC)
 * of [solar noon](https://en.wikipedia.org/wiki/Noon#Solar_noon) for the given day at the given location
 * on earth. This implementation returns true solar noon as opposed to the time halfway between sunrise and sunset.
 * Other calculators may return a more simplified calculation of halfway between sunrise and sunset. See [The Definition of *Chatzos*](https://kosherjava.com/2020/07/02/definition-of-chatzos/) for details on
 * solar noon calculations.
 * @see com.kosherjava.zmanim.util.AstronomicalCalculator.getUTCNoon
 * @see solarNoonUTC
 * @param calendar
 * The Calendar representing the date to calculate solar noon for
 * @param geoLocation
 * The location information used for astronomical calculating sun times. This class uses only requires
 * the longitude for calculating noon since it is the same time anywhere along the longitude line.
 * @return the time in minutes from zero UTC
 */
- (double)getUTCNoonDate:(STTKotlinx_datetimeLocalDate *)date geoLocation:(STTGeoLocation *)geoLocation __attribute__((swift_name("getUTCNoon(date:geoLocation:)")));

/**
 * @see com.kosherjava.zmanim.util.AstronomicalCalculator.getUTCSunrise
 */
- (double)getUTCSunriseLocalDate:(STTKotlinx_datetimeLocalDate *)LocalDate geoLocation:(STTGeoLocation *)geoLocation zenith:(double)zenith adjustForElevation:(BOOL)adjustForElevation __attribute__((swift_name("getUTCSunrise(LocalDate:geoLocation:zenith:adjustForElevation:)")));

/**
 * @see com.kosherjava.zmanim.util.AstronomicalCalculator.getUTCSunset
 */
- (double)getUTCSunsetLocalDate:(STTKotlinx_datetimeLocalDate *)LocalDate geoLocation:(STTGeoLocation *)geoLocation zenith:(double)zenith adjustForElevation:(BOOL)adjustForElevation __attribute__((swift_name("getUTCSunset(LocalDate:geoLocation:zenith:adjustForElevation:)")));

/**
 * @see com.kosherjava.zmanim.util.AstronomicalCalculator.getCalculatorName
 */
@property (readonly) NSString *calculatorName __attribute__((swift_name("calculatorName")));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("NOAACalculator.Companion")))
@interface STTNOAACalculatorCompanion : STTBase
+ (instancetype)alloc __attribute__((unavailable));
+ (instancetype)allocWithZone:(struct _NSZone *)zone __attribute__((unavailable));
+ (instancetype)companion __attribute__((swift_name("init()")));
@property (class, readonly, getter=shared) STTNOAACalculatorCompanion *shared __attribute__((swift_name("shared")));
- (STTKotlinTriple<STTDouble *, STTDouble *, STTDouble *> *)getHourAngleLatAndDecCal:(STTKotlinx_datetimeLocalDateTime *)cal lat:(double)lat lon:(double)lon __attribute__((swift_name("getHourAngleLatAndDec(cal:lat:lon:)")));

/**
 * Return the [Solar Azimuth](https://en.wikipedia.org/wiki/Celestial_coordinate_system) for the
 * horizontal coordinate system at the given location at the given time. Not corrected for altitude. True south is 0
 * degrees.
 *
 * @param cal
 * time of calculation
 * @param lat
 * latitude of location for calculation
 * @param lon
 * longitude of location for calculation
 * @return the solar azimuth
 */
- (double)getSolarAzimuthCal:(STTKotlinx_datetimeLocalDateTime *)cal lat:(double)lat lon:(double)lon __attribute__((swift_name("getSolarAzimuth(cal:lat:lon:)")));

/**
 * Return the [Solar Elevation](https://en.wikipedia.org/wiki/Celestial_coordinate_system) for the
 * horizontal coordinate system at the given location at the given time. Can be negative if the sun is below the
 * horizon. Not corrected for altitude.
 *
 * @param cal
 * time of calculation
 * @param lat
 * latitude of location for calculation
 * @param lon
 * longitude of location for calculation
 * @return solar elevation in degrees - horizon is 0 degrees, civil twilight is -6 degrees
 */
- (double)getSolarElevationCal:(STTKotlinx_datetimeLocalDateTime *)cal lat:(double)lat lon:(double)lon __attribute__((swift_name("getSolarElevation(cal:lat:lon:)")));
@end


/**
 * Implementation of sunrise and sunset methods to calculate astronomical times. This calculator uses the Java algorithm
 * written by [Kevin
 * Boone](htts://web.archive.org/web/20090531215353/http://www.kevinboone.com/suntimes.html) that is based on the [US Naval Observatory's](https://aa.usno.navy.mil/)[Astronomical Almanac](https://aa.usno.navy.mil/publications/asa) and used with his permission. Added to Kevin's
 * code is adjustment of the zenith to account for elevation. This algorithm returns the same time every year and does not
 * account for leap years. It is not as accurate as the Jean Meeus based [NOAACalculator] that is the default calculator
 * use by the KosherJava *zmanim* library.
 *
 * @author  Eliyahu Hershfeld 2004 - 2023
 * @author  Kevin Boone 2000
 */
__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("SunTimesCalculator")))
@interface STTSunTimesCalculator : STTAstronomicalCalculator

/**
 * Implementation of sunrise and sunset methods to calculate astronomical times. This calculator uses the Java algorithm
 * written by [Kevin
 * Boone](htts://web.archive.org/web/20090531215353/http://www.kevinboone.com/suntimes.html) that is based on the [US Naval Observatory's](https://aa.usno.navy.mil/)[Astronomical Almanac](https://aa.usno.navy.mil/publications/asa) and used with his permission. Added to Kevin's
 * code is adjustment of the zenith to account for elevation. This algorithm returns the same time every year and does not
 * account for leap years. It is not as accurate as the Jean Meeus based [NOAACalculator] that is the default calculator
 * use by the KosherJava *zmanim* library.
 *
 * @author  Eliyahu Hershfeld 2004 - 2023
 * @author  Kevin Boone 2000
 */
- (instancetype)init __attribute__((swift_name("init()"))) __attribute__((objc_designated_initializer));

/**
 * Implementation of sunrise and sunset methods to calculate astronomical times. This calculator uses the Java algorithm
 * written by [Kevin
 * Boone](htts://web.archive.org/web/20090531215353/http://www.kevinboone.com/suntimes.html) that is based on the [US Naval Observatory's](https://aa.usno.navy.mil/)[Astronomical Almanac](https://aa.usno.navy.mil/publications/asa) and used with his permission. Added to Kevin's
 * code is adjustment of the zenith to account for elevation. This algorithm returns the same time every year and does not
 * account for leap years. It is not as accurate as the Jean Meeus based [NOAACalculator] that is the default calculator
 * use by the KosherJava *zmanim* library.
 *
 * @author  Eliyahu Hershfeld 2004 - 2023
 * @author  Kevin Boone 2000
 */
+ (instancetype)new __attribute__((availability(swift, unavailable, message="use object initializers instead")));
@property (class, readonly, getter=companion) STTSunTimesCalculatorCompanion *companion __attribute__((swift_name("companion")));
- (STTAstronomicalCalculator *)doCopy __attribute__((swift_name("doCopy()")));

/**
 * Return the [Universal Coordinated Time](https://en.wikipedia.org/wiki/Universal_Coordinated_Time) (UTC)
 * of [solar noon](https://en.wikipedia.org/wiki/Noon#Solar_noon) for the given day at the given location
 * on earth. This implementation returns solar noon as the time halfway between sunrise and sunset.
 * Other calculators may return true solar noon. See [The Definition of Chatzos](https://kosherjava.com/2020/07/02/definition-of-chatzos/) for details on solar
 * noon calculations.
 * @see com.kosherjava.zmanim.util.AstronomicalCalculator.getUTCNoon
 * @see NOAACalculator
 *
 *
 * @param date
 * The LocalDate representing the date to calculate solar noon for
 * @param geoLocation
 * The location information used for astronomical calculating sun times.
 * @return the time in minutes from zero UTC
 */
- (double)getUTCNoonDate:(STTKotlinx_datetimeLocalDate *)date geoLocation:(STTGeoLocation *)geoLocation __attribute__((swift_name("getUTCNoon(date:geoLocation:)")));

/**
 * @see com.kosherjava.zmanim.util.AstronomicalCalculator.getUTCSunrise
 */
- (double)getUTCSunriseLocalDate:(STTKotlinx_datetimeLocalDate *)LocalDate geoLocation:(STTGeoLocation *)geoLocation zenith:(double)zenith adjustForElevation:(BOOL)adjustForElevation __attribute__((swift_name("getUTCSunrise(LocalDate:geoLocation:zenith:adjustForElevation:)")));

/**
 * @see com.kosherjava.zmanim.util.AstronomicalCalculator.getUTCSunset
 */
- (double)getUTCSunsetLocalDate:(STTKotlinx_datetimeLocalDate *)LocalDate geoLocation:(STTGeoLocation *)geoLocation zenith:(double)zenith adjustForElevation:(BOOL)adjustForElevation __attribute__((swift_name("getUTCSunset(LocalDate:geoLocation:zenith:adjustForElevation:)")));

/**
 * @see getCalculatorName
 */
@property (readonly) NSString *calculatorName __attribute__((swift_name("calculatorName")));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("SunTimesCalculator.Companion")))
@interface STTSunTimesCalculatorCompanion : STTBase
+ (instancetype)alloc __attribute__((unavailable));
+ (instancetype)allocWithZone:(struct _NSZone *)zone __attribute__((unavailable));
+ (instancetype)companion __attribute__((swift_name("init()")));
@property (class, readonly, getter=shared) STTSunTimesCalculatorCompanion *shared __attribute__((swift_name("shared")));
@end


/**
 * A class that represents a numeric time. Times that represent a time of day are stored as [java.util.Date]s in
 * this API. The time class is used to represent numeric time such as the time in hours, minutes, seconds and
 * milliseconds of a [temporal hour][com.kosherjava.zmanim.AstronomicalCalendar.temporalHour].
 *
 * This is a data class so that it inherits the [copy] method, and to semantically signify it is a data holder.
 * @author  Eliyahu Hershfeld 2004 - 2020
 */
__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("Time")))
@interface STTTime : STTBase

/**
 * Constructor with a parameter for milliseconds. This constructor casts the milliseconds to an int and
 * calls a secondary constructo
 * @param millis the milliseconds to set the object with.
 */
- (instancetype)initWithMillis:(double)millis __attribute__((swift_name("init(millis:)"))) __attribute__((objc_designated_initializer));

/**
 * A constructor that sets the time by milliseconds. The milliseconds are converted to hours, minutes, seconds
 * and milliseconds. If the milliseconds are negative it will set [isNegative] to true.
 * @param millis the milliseconds to set.
 */
- (instancetype)initWithMillis_:(int32_t)millis __attribute__((swift_name("init(millis_:)"))) __attribute__((objc_designated_initializer));
- (instancetype)initWithHours:(int32_t)hours minutes:(int32_t)minutes seconds:(int32_t)seconds milliseconds:(int32_t)milliseconds isNegative:(BOOL)isNegative __attribute__((swift_name("init(hours:minutes:seconds:milliseconds:isNegative:)"))) __attribute__((objc_designated_initializer));
@property (class, readonly, getter=companion) STTTimeCompanion *companion __attribute__((swift_name("companion")));

/**
 * A class that represents a numeric time. Times that represent a time of day are stored as [java.util.Date]s in
 * this API. The time class is used to represent numeric time such as the time in hours, minutes, seconds and
 * milliseconds of a [temporal hour][com.kosherjava.zmanim.AstronomicalCalendar.temporalHour].
 *
 * This is a data class so that it inherits the [copy] method, and to semantically signify it is a data holder.
 * @author  Eliyahu Hershfeld 2004 - 2020
 */
- (STTTime *)doCopyHours:(int32_t)hours minutes:(int32_t)minutes seconds:(int32_t)seconds milliseconds:(int32_t)milliseconds isNegative:(BOOL)isNegative __attribute__((swift_name("doCopy(hours:minutes:seconds:milliseconds:isNegative:)")));

/**
 * A class that represents a numeric time. Times that represent a time of day are stored as [java.util.Date]s in
 * this API. The time class is used to represent numeric time such as the time in hours, minutes, seconds and
 * milliseconds of a [temporal hour][com.kosherjava.zmanim.AstronomicalCalendar.temporalHour].
 *
 * This is a data class so that it inherits the [copy] method, and to semantically signify it is a data holder.
 * @author  Eliyahu Hershfeld 2004 - 2020
 */
- (BOOL)isEqual:(id _Nullable)other __attribute__((swift_name("isEqual(_:)")));

/**
 * A class that represents a numeric time. Times that represent a time of day are stored as [java.util.Date]s in
 * this API. The time class is used to represent numeric time such as the time in hours, minutes, seconds and
 * milliseconds of a [temporal hour][com.kosherjava.zmanim.AstronomicalCalendar.temporalHour].
 *
 * This is a data class so that it inherits the [copy] method, and to semantically signify it is a data holder.
 * @author  Eliyahu Hershfeld 2004 - 2020
 */
- (NSUInteger)hash __attribute__((swift_name("hash()")));

/**
 * A class that represents a numeric time. Times that represent a time of day are stored as [java.util.Date]s in
 * this API. The time class is used to represent numeric time such as the time in hours, minutes, seconds and
 * milliseconds of a [temporal hour][com.kosherjava.zmanim.AstronomicalCalendar.temporalHour].
 *
 * This is a data class so that it inherits the [copy] method, and to semantically signify it is a data holder.
 * @author  Eliyahu Hershfeld 2004 - 2020
 */
- (NSString *)description __attribute__((swift_name("description()")));
@property int32_t hours __attribute__((swift_name("hours")));

/**
 * Does the time represent a negative time 9such as using this to subtract time from another Time.
 * True if the time is negative.
 */
@property BOOL isNegative __attribute__((swift_name("isNegative")));
@property int32_t milliseconds __attribute__((swift_name("milliseconds")));
@property int32_t minutes __attribute__((swift_name("minutes")));
@property int32_t seconds __attribute__((swift_name("seconds")));

/**
 * Returns the time in milliseconds by converting hours, minutes and seconds into milliseconds.
 * @return the time in milliseconds
 */
@property (readonly) double time __attribute__((swift_name("time")));
@end


/**
 * @see Object.toString
 */
__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("Time.Companion")))
@interface STTTimeCompanion : STTBase
+ (instancetype)alloc __attribute__((unavailable));

/**
 * @see Object.toString
 */
+ (instancetype)allocWithZone:(struct _NSZone *)zone __attribute__((unavailable));
+ (instancetype)companion __attribute__((swift_name("init()")));
@property (class, readonly, getter=shared) STTTimeCompanion *shared __attribute__((swift_name("shared")));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("WeekFormat")))
@interface STTWeekFormat : STTBase
+ (instancetype)alloc __attribute__((unavailable));
+ (instancetype)allocWithZone:(struct _NSZone *)zone __attribute__((unavailable));
+ (instancetype)weekFormat __attribute__((swift_name("init()")));
@property (class, readonly, getter=shared) STTWeekFormat *shared __attribute__((swift_name("shared")));
- (NSString *)dayName:(STTKotlinx_datetimeLocalDate *)receiver __attribute__((swift_name("dayName(_:)")));
@property (readonly, getter=long) id<STTWeekFormatFormatter> long_ __attribute__((swift_name("long_")));
@property (readonly, getter=short) id<STTWeekFormatFormatter> short_ __attribute__((swift_name("short_")));
@end

__attribute__((swift_name("WeekFormatFormatter")))
@protocol STTWeekFormatFormatter
@required
- (NSString *)formatInput:(STTKotlinx_datetimeLocalDate *)input __attribute__((swift_name("format(input:)")));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("MainKt")))
@interface STTMainKt : STTBase
+ (void)mainArgs:(STTKotlinArray<NSString *> *)args __attribute__((swift_name("main(args:)")));
@end

__attribute__((swift_name("Kotlinx_serialization_coreSerializationStrategy")))
@protocol STTKotlinx_serialization_coreSerializationStrategy
@required
- (void)serializeEncoder:(id<STTKotlinx_serialization_coreEncoder>)encoder value:(id _Nullable)value __attribute__((swift_name("serialize(encoder:value:)")));
@property (readonly) id<STTKotlinx_serialization_coreSerialDescriptor> descriptor __attribute__((swift_name("descriptor")));
@end

__attribute__((swift_name("Kotlinx_serialization_coreDeserializationStrategy")))
@protocol STTKotlinx_serialization_coreDeserializationStrategy
@required
- (id _Nullable)deserializeDecoder:(id<STTKotlinx_serialization_coreDecoder>)decoder __attribute__((swift_name("deserialize(decoder:)")));
@property (readonly) id<STTKotlinx_serialization_coreSerialDescriptor> descriptor __attribute__((swift_name("descriptor")));
@end

__attribute__((swift_name("Kotlinx_serialization_coreKSerializer")))
@protocol STTKotlinx_serialization_coreKSerializer <STTKotlinx_serialization_coreSerializationStrategy, STTKotlinx_serialization_coreDeserializationStrategy>
@required
@end


/**
 * @note annotations
 *   kotlinx.serialization.Serializable(with=NormalClass(value=kotlinx/datetime/serializers/InstantIso8601Serializer))
*/
__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("Kotlinx_datetimeInstant")))
@interface STTKotlinx_datetimeInstant : STTBase <STTKotlinComparable>
@property (class, readonly, getter=companion) STTKotlinx_datetimeInstantCompanion *companion __attribute__((swift_name("companion")));
- (int32_t)compareToOther:(STTKotlinx_datetimeInstant *)other __attribute__((swift_name("compareTo(other:)")));
- (BOOL)isEqual:(id _Nullable)other __attribute__((swift_name("isEqual(_:)")));
- (NSUInteger)hash __attribute__((swift_name("hash()")));
- (STTKotlinx_datetimeInstant *)minusDuration:(int64_t)duration __attribute__((swift_name("minus(duration:)")));
- (int64_t)minusOther:(STTKotlinx_datetimeInstant *)other __attribute__((swift_name("minus(other:)")));
- (STTKotlinx_datetimeInstant *)plusDuration:(int64_t)duration __attribute__((swift_name("plus(duration:)")));
- (int64_t)toEpochMilliseconds __attribute__((swift_name("toEpochMilliseconds()")));
- (NSString *)description __attribute__((swift_name("description()")));
@property (readonly) int64_t epochSeconds __attribute__((swift_name("epochSeconds")));
@property (readonly) int32_t nanosecondsOfSecond __attribute__((swift_name("nanosecondsOfSecond")));
@end


/**
 * @note annotations
 *   kotlinx.serialization.Serializable(with=NormalClass(value=kotlinx/datetime/serializers/LocalDateTimeIso8601Serializer))
*/
__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("Kotlinx_datetimeLocalDateTime")))
@interface STTKotlinx_datetimeLocalDateTime : STTBase <STTKotlinComparable>
- (instancetype)initWithDate:(STTKotlinx_datetimeLocalDate *)date time:(STTKotlinx_datetimeLocalTime *)time __attribute__((swift_name("init(date:time:)"))) __attribute__((objc_designated_initializer));
- (instancetype)initWithYear:(int32_t)year monthNumber:(int32_t)monthNumber dayOfMonth:(int32_t)dayOfMonth hour:(int32_t)hour minute:(int32_t)minute second:(int32_t)second nanosecond:(int32_t)nanosecond __attribute__((swift_name("init(year:monthNumber:dayOfMonth:hour:minute:second:nanosecond:)"))) __attribute__((objc_designated_initializer));
- (instancetype)initWithYear:(int32_t)year month:(STTKotlinx_datetimeMonth *)month dayOfMonth:(int32_t)dayOfMonth hour:(int32_t)hour minute:(int32_t)minute second:(int32_t)second nanosecond:(int32_t)nanosecond __attribute__((swift_name("init(year:month:dayOfMonth:hour:minute:second:nanosecond:)"))) __attribute__((objc_designated_initializer));
@property (class, readonly, getter=companion) STTKotlinx_datetimeLocalDateTimeCompanion *companion __attribute__((swift_name("companion")));
- (int32_t)compareToOther:(STTKotlinx_datetimeLocalDateTime *)other __attribute__((swift_name("compareTo(other:)")));
- (BOOL)isEqual:(id _Nullable)other __attribute__((swift_name("isEqual(_:)")));
- (NSUInteger)hash __attribute__((swift_name("hash()")));
- (NSString *)description __attribute__((swift_name("description()")));
@property (readonly) STTKotlinx_datetimeLocalDate *date __attribute__((swift_name("date")));
@property (readonly) int32_t dayOfMonth __attribute__((swift_name("dayOfMonth")));
@property (readonly) STTKotlinx_datetimeDayOfWeek *dayOfWeek __attribute__((swift_name("dayOfWeek")));
@property (readonly) int32_t dayOfYear __attribute__((swift_name("dayOfYear")));
@property (readonly) int32_t hour __attribute__((swift_name("hour")));
@property (readonly) int32_t minute __attribute__((swift_name("minute")));
@property (readonly) STTKotlinx_datetimeMonth *month __attribute__((swift_name("month")));
@property (readonly) int32_t monthNumber __attribute__((swift_name("monthNumber")));
@property (readonly) int32_t nanosecond __attribute__((swift_name("nanosecond")));
@property (readonly) int32_t second __attribute__((swift_name("second")));
@property (readonly) STTKotlinx_datetimeLocalTime *time __attribute__((swift_name("time")));
@property (readonly) int32_t year __attribute__((swift_name("year")));
@end


/**
 * @note annotations
 *   kotlinx.serialization.Serializable(with=NormalClass(value=kotlinx/datetime/serializers/LocalDateIso8601Serializer))
*/
__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("Kotlinx_datetimeLocalDate")))
@interface STTKotlinx_datetimeLocalDate : STTBase <STTKotlinComparable>
- (instancetype)initWithYear:(int32_t)year monthNumber:(int32_t)monthNumber dayOfMonth:(int32_t)dayOfMonth __attribute__((swift_name("init(year:monthNumber:dayOfMonth:)"))) __attribute__((objc_designated_initializer));
- (instancetype)initWithYear:(int32_t)year month:(STTKotlinx_datetimeMonth *)month dayOfMonth:(int32_t)dayOfMonth __attribute__((swift_name("init(year:month:dayOfMonth:)"))) __attribute__((objc_designated_initializer));
@property (class, readonly, getter=companion) STTKotlinx_datetimeLocalDateCompanion *companion __attribute__((swift_name("companion")));
- (int32_t)compareToOther:(STTKotlinx_datetimeLocalDate *)other __attribute__((swift_name("compareTo(other:)")));
- (BOOL)isEqual:(id _Nullable)other __attribute__((swift_name("isEqual(_:)")));
- (NSUInteger)hash __attribute__((swift_name("hash()")));
- (int32_t)toEpochDays __attribute__((swift_name("toEpochDays()")));
- (NSString *)description __attribute__((swift_name("description()")));
@property (readonly) int32_t dayOfMonth __attribute__((swift_name("dayOfMonth")));
@property (readonly) STTKotlinx_datetimeDayOfWeek *dayOfWeek __attribute__((swift_name("dayOfWeek")));
@property (readonly) int32_t dayOfYear __attribute__((swift_name("dayOfYear")));
@property (readonly) STTKotlinx_datetimeMonth *month __attribute__((swift_name("month")));
@property (readonly) int32_t monthNumber __attribute__((swift_name("monthNumber")));
@property (readonly) int32_t year __attribute__((swift_name("year")));
@end


/**
 * @note annotations
 *   kotlinx.serialization.Serializable(with=NormalClass(value=kotlinx/datetime/serializers/LocalTimeIso8601Serializer))
*/
__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("Kotlinx_datetimeLocalTime")))
@interface STTKotlinx_datetimeLocalTime : STTBase <STTKotlinComparable>
- (instancetype)initWithHour:(int32_t)hour minute:(int32_t)minute second:(int32_t)second nanosecond:(int32_t)nanosecond __attribute__((swift_name("init(hour:minute:second:nanosecond:)"))) __attribute__((objc_designated_initializer));
@property (class, readonly, getter=companion) STTKotlinx_datetimeLocalTimeCompanion *companion __attribute__((swift_name("companion")));
- (int32_t)compareToOther:(STTKotlinx_datetimeLocalTime *)other __attribute__((swift_name("compareTo(other:)")));
- (BOOL)isEqual:(id _Nullable)other __attribute__((swift_name("isEqual(_:)")));
- (NSUInteger)hash __attribute__((swift_name("hash()")));
- (int32_t)toMillisecondOfDay __attribute__((swift_name("toMillisecondOfDay()")));
- (int64_t)toNanosecondOfDay __attribute__((swift_name("toNanosecondOfDay()")));
- (int32_t)toSecondOfDay __attribute__((swift_name("toSecondOfDay()")));
- (NSString *)description __attribute__((swift_name("description()")));
@property (readonly) int32_t hour __attribute__((swift_name("hour")));
@property (readonly) int32_t minute __attribute__((swift_name("minute")));
@property (readonly) int32_t nanosecond __attribute__((swift_name("nanosecond")));
@property (readonly) int32_t second __attribute__((swift_name("second")));
@end


/**
 * @note annotations
 *   kotlinx.serialization.Serializable(with=NormalClass(value=kotlinx/datetime/serializers/TimeZoneSerializer))
*/
__attribute__((swift_name("Kotlinx_datetimeTimeZone")))
@interface STTKotlinx_datetimeTimeZone : STTBase
@property (class, readonly, getter=companion) STTKotlinx_datetimeTimeZoneCompanion *companion __attribute__((swift_name("companion")));
- (BOOL)isEqual:(id _Nullable)other __attribute__((swift_name("isEqual(_:)")));
- (NSUInteger)hash __attribute__((swift_name("hash()")));
- (STTKotlinx_datetimeInstant *)toInstant:(STTKotlinx_datetimeLocalDateTime *)receiver __attribute__((swift_name("toInstant(_:)")));
- (STTKotlinx_datetimeLocalDateTime *)toLocalDateTime:(STTKotlinx_datetimeInstant *)receiver __attribute__((swift_name("toLocalDateTime(_:)")));
- (NSString *)description __attribute__((swift_name("description()")));
@property (readonly) NSString *id __attribute__((swift_name("id")));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("KotlinArray")))
@interface STTKotlinArray<T> : STTBase
+ (instancetype)arrayWithSize:(int32_t)size init:(T _Nullable (^)(STTInt *))init __attribute__((swift_name("init(size:init:)")));
+ (instancetype)alloc __attribute__((unavailable));
+ (instancetype)allocWithZone:(struct _NSZone *)zone __attribute__((unavailable));
- (T _Nullable)getIndex:(int32_t)index __attribute__((swift_name("get(index:)")));
- (id<STTKotlinIterator>)iterator __attribute__((swift_name("iterator()")));
- (void)setIndex:(int32_t)index value:(T _Nullable)value __attribute__((swift_name("set(index:value:)")));
@property (readonly) int32_t size __attribute__((swift_name("size")));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("Kotlinx_datetimeMonth")))
@interface STTKotlinx_datetimeMonth : STTKotlinEnum<STTKotlinx_datetimeMonth *>
+ (instancetype)alloc __attribute__((unavailable));
+ (instancetype)allocWithZone:(struct _NSZone *)zone __attribute__((unavailable));
- (instancetype)initWithName:(NSString *)name ordinal:(int32_t)ordinal __attribute__((swift_name("init(name:ordinal:)"))) __attribute__((objc_designated_initializer)) __attribute__((unavailable));
@property (class, readonly) STTKotlinx_datetimeMonth *january __attribute__((swift_name("january")));
@property (class, readonly) STTKotlinx_datetimeMonth *february __attribute__((swift_name("february")));
@property (class, readonly) STTKotlinx_datetimeMonth *march __attribute__((swift_name("march")));
@property (class, readonly) STTKotlinx_datetimeMonth *april __attribute__((swift_name("april")));
@property (class, readonly) STTKotlinx_datetimeMonth *may __attribute__((swift_name("may")));
@property (class, readonly) STTKotlinx_datetimeMonth *june __attribute__((swift_name("june")));
@property (class, readonly) STTKotlinx_datetimeMonth *july __attribute__((swift_name("july")));
@property (class, readonly) STTKotlinx_datetimeMonth *august __attribute__((swift_name("august")));
@property (class, readonly) STTKotlinx_datetimeMonth *september __attribute__((swift_name("september")));
@property (class, readonly) STTKotlinx_datetimeMonth *october __attribute__((swift_name("october")));
@property (class, readonly) STTKotlinx_datetimeMonth *november __attribute__((swift_name("november")));
@property (class, readonly) STTKotlinx_datetimeMonth *december __attribute__((swift_name("december")));
+ (STTKotlinArray<STTKotlinx_datetimeMonth *> *)values __attribute__((swift_name("values()")));
@property (class, readonly) NSArray<STTKotlinx_datetimeMonth *> *entries __attribute__((swift_name("entries")));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("KotlinEnumCompanion")))
@interface STTKotlinEnumCompanion : STTBase
+ (instancetype)alloc __attribute__((unavailable));
+ (instancetype)allocWithZone:(struct _NSZone *)zone __attribute__((unavailable));
+ (instancetype)companion __attribute__((swift_name("init()")));
@property (class, readonly, getter=shared) STTKotlinEnumCompanion *shared __attribute__((swift_name("shared")));
@end

__attribute__((swift_name("KotlinIterator")))
@protocol STTKotlinIterator
@required
- (BOOL)hasNext __attribute__((swift_name("hasNext()")));
- (id _Nullable)next __attribute__((swift_name("next()")));
@end


/**
 * @note annotations
 *   kotlinx.serialization.Serializable(with=NormalClass(value=kotlinx/datetime/serializers/DateTimeUnitSerializer))
*/
__attribute__((swift_name("Kotlinx_datetimeDateTimeUnit")))
@interface STTKotlinx_datetimeDateTimeUnit : STTBase
@property (class, readonly, getter=companion) STTKotlinx_datetimeDateTimeUnitCompanion *companion __attribute__((swift_name("companion")));

/**
 * @note This method has protected visibility in Kotlin source and is intended only for use by subclasses.
*/
- (NSString *)formatToStringValue:(int32_t)value unit:(NSString *)unit __attribute__((swift_name("formatToString(value:unit:)")));

/**
 * @note This method has protected visibility in Kotlin source and is intended only for use by subclasses.
*/
- (NSString *)formatToStringValue:(int64_t)value unit_:(NSString *)unit __attribute__((swift_name("formatToString(value:unit_:)")));
- (STTKotlinx_datetimeDateTimeUnit *)timesScalar:(int32_t)scalar __attribute__((swift_name("times(scalar:)")));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("Kotlinx_datetimeDayOfWeek")))
@interface STTKotlinx_datetimeDayOfWeek : STTKotlinEnum<STTKotlinx_datetimeDayOfWeek *>
+ (instancetype)alloc __attribute__((unavailable));
+ (instancetype)allocWithZone:(struct _NSZone *)zone __attribute__((unavailable));
- (instancetype)initWithName:(NSString *)name ordinal:(int32_t)ordinal __attribute__((swift_name("init(name:ordinal:)"))) __attribute__((objc_designated_initializer)) __attribute__((unavailable));
@property (class, readonly) STTKotlinx_datetimeDayOfWeek *monday __attribute__((swift_name("monday")));
@property (class, readonly) STTKotlinx_datetimeDayOfWeek *tuesday __attribute__((swift_name("tuesday")));
@property (class, readonly) STTKotlinx_datetimeDayOfWeek *wednesday __attribute__((swift_name("wednesday")));
@property (class, readonly) STTKotlinx_datetimeDayOfWeek *thursday __attribute__((swift_name("thursday")));
@property (class, readonly) STTKotlinx_datetimeDayOfWeek *friday __attribute__((swift_name("friday")));
@property (class, readonly) STTKotlinx_datetimeDayOfWeek *saturday __attribute__((swift_name("saturday")));
@property (class, readonly) STTKotlinx_datetimeDayOfWeek *sunday __attribute__((swift_name("sunday")));
+ (STTKotlinArray<STTKotlinx_datetimeDayOfWeek *> *)values __attribute__((swift_name("values()")));
@property (class, readonly) NSArray<STTKotlinx_datetimeDayOfWeek *> *entries __attribute__((swift_name("entries")));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("Kotlinx_datetimeLocalDate.Companion")))
@interface STTKotlinx_datetimeLocalDateCompanion : STTBase
+ (instancetype)alloc __attribute__((unavailable));
+ (instancetype)allocWithZone:(struct _NSZone *)zone __attribute__((unavailable));
+ (instancetype)companion __attribute__((swift_name("init()")));
@property (class, readonly, getter=shared) STTKotlinx_datetimeLocalDateCompanion *shared __attribute__((swift_name("shared")));
- (id<STTKotlinx_datetimeDateTimeFormat>)FormatBlock:(void (^)(id<STTKotlinx_datetimeDateTimeFormatBuilderWithDate>))block __attribute__((swift_name("Format(block:)")));
- (STTKotlinx_datetimeLocalDate *)fromEpochDaysEpochDays:(int32_t)epochDays __attribute__((swift_name("fromEpochDays(epochDays:)")));
- (STTKotlinx_datetimeLocalDate *)parseInput:(id)input format:(id<STTKotlinx_datetimeDateTimeFormat>)format __attribute__((swift_name("parse(input:format:)")));
- (id<STTKotlinx_serialization_coreKSerializer>)serializer __attribute__((swift_name("serializer()")));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("KotlinTriple")))
@interface STTKotlinTriple<__covariant A, __covariant B, __covariant C> : STTBase
- (instancetype)initWithFirst:(A _Nullable)first second:(B _Nullable)second third:(C _Nullable)third __attribute__((swift_name("init(first:second:third:)"))) __attribute__((objc_designated_initializer));
- (STTKotlinTriple<A, B, C> *)doCopyFirst:(A _Nullable)first second:(B _Nullable)second third:(C _Nullable)third __attribute__((swift_name("doCopy(first:second:third:)")));
- (BOOL)equalsOther:(id _Nullable)other __attribute__((swift_name("equals(other:)")));
- (int32_t)hashCode __attribute__((swift_name("hashCode()")));
- (NSString *)toString __attribute__((swift_name("toString()")));
@property (readonly) A _Nullable first __attribute__((swift_name("first")));
@property (readonly) B _Nullable second __attribute__((swift_name("second")));
@property (readonly) C _Nullable third __attribute__((swift_name("third")));
@end

__attribute__((swift_name("Kotlinx_serialization_coreEncoder")))
@protocol STTKotlinx_serialization_coreEncoder
@required
- (id<STTKotlinx_serialization_coreCompositeEncoder>)beginCollectionDescriptor:(id<STTKotlinx_serialization_coreSerialDescriptor>)descriptor collectionSize:(int32_t)collectionSize __attribute__((swift_name("beginCollection(descriptor:collectionSize:)")));
- (id<STTKotlinx_serialization_coreCompositeEncoder>)beginStructureDescriptor:(id<STTKotlinx_serialization_coreSerialDescriptor>)descriptor __attribute__((swift_name("beginStructure(descriptor:)")));
- (void)encodeBooleanValue:(BOOL)value __attribute__((swift_name("encodeBoolean(value:)")));
- (void)encodeByteValue:(int8_t)value __attribute__((swift_name("encodeByte(value:)")));
- (void)encodeCharValue:(unichar)value __attribute__((swift_name("encodeChar(value:)")));
- (void)encodeDoubleValue:(double)value __attribute__((swift_name("encodeDouble(value:)")));
- (void)encodeEnumEnumDescriptor:(id<STTKotlinx_serialization_coreSerialDescriptor>)enumDescriptor index:(int32_t)index __attribute__((swift_name("encodeEnum(enumDescriptor:index:)")));
- (void)encodeFloatValue:(float)value __attribute__((swift_name("encodeFloat(value:)")));
- (id<STTKotlinx_serialization_coreEncoder>)encodeInlineDescriptor:(id<STTKotlinx_serialization_coreSerialDescriptor>)descriptor __attribute__((swift_name("encodeInline(descriptor:)")));
- (void)encodeIntValue:(int32_t)value __attribute__((swift_name("encodeInt(value:)")));
- (void)encodeLongValue:(int64_t)value __attribute__((swift_name("encodeLong(value:)")));

/**
 * @note annotations
 *   kotlinx.serialization.ExperimentalSerializationApi
*/
- (void)encodeNotNullMark __attribute__((swift_name("encodeNotNullMark()")));

/**
 * @note annotations
 *   kotlinx.serialization.ExperimentalSerializationApi
*/
- (void)encodeNull __attribute__((swift_name("encodeNull()")));

/**
 * @note annotations
 *   kotlinx.serialization.ExperimentalSerializationApi
*/
- (void)encodeNullableSerializableValueSerializer:(id<STTKotlinx_serialization_coreSerializationStrategy>)serializer value:(id _Nullable)value __attribute__((swift_name("encodeNullableSerializableValue(serializer:value:)")));
- (void)encodeSerializableValueSerializer:(id<STTKotlinx_serialization_coreSerializationStrategy>)serializer value:(id _Nullable)value __attribute__((swift_name("encodeSerializableValue(serializer:value:)")));
- (void)encodeShortValue:(int16_t)value __attribute__((swift_name("encodeShort(value:)")));
- (void)encodeStringValue:(NSString *)value __attribute__((swift_name("encodeString(value:)")));
@property (readonly) STTKotlinx_serialization_coreSerializersModule *serializersModule __attribute__((swift_name("serializersModule")));
@end

__attribute__((swift_name("Kotlinx_serialization_coreSerialDescriptor")))
@protocol STTKotlinx_serialization_coreSerialDescriptor
@required

/**
 * @note annotations
 *   kotlinx.serialization.ExperimentalSerializationApi
*/
- (NSArray<id<STTKotlinAnnotation>> *)getElementAnnotationsIndex:(int32_t)index __attribute__((swift_name("getElementAnnotations(index:)")));

/**
 * @note annotations
 *   kotlinx.serialization.ExperimentalSerializationApi
*/
- (id<STTKotlinx_serialization_coreSerialDescriptor>)getElementDescriptorIndex:(int32_t)index __attribute__((swift_name("getElementDescriptor(index:)")));

/**
 * @note annotations
 *   kotlinx.serialization.ExperimentalSerializationApi
*/
- (int32_t)getElementIndexName:(NSString *)name __attribute__((swift_name("getElementIndex(name:)")));

/**
 * @note annotations
 *   kotlinx.serialization.ExperimentalSerializationApi
*/
- (NSString *)getElementNameIndex:(int32_t)index __attribute__((swift_name("getElementName(index:)")));

/**
 * @note annotations
 *   kotlinx.serialization.ExperimentalSerializationApi
*/
- (BOOL)isElementOptionalIndex:(int32_t)index __attribute__((swift_name("isElementOptional(index:)")));

/**
 * @note annotations
 *   kotlinx.serialization.ExperimentalSerializationApi
*/
@property (readonly) NSArray<id<STTKotlinAnnotation>> *annotations __attribute__((swift_name("annotations")));

/**
 * @note annotations
 *   kotlinx.serialization.ExperimentalSerializationApi
*/
@property (readonly) int32_t elementsCount __attribute__((swift_name("elementsCount")));
@property (readonly) BOOL isInline __attribute__((swift_name("isInline")));

/**
 * @note annotations
 *   kotlinx.serialization.ExperimentalSerializationApi
*/
@property (readonly) BOOL isNullable __attribute__((swift_name("isNullable")));

/**
 * @note annotations
 *   kotlinx.serialization.ExperimentalSerializationApi
*/
@property (readonly) STTKotlinx_serialization_coreSerialKind *kind __attribute__((swift_name("kind")));

/**
 * @note annotations
 *   kotlinx.serialization.ExperimentalSerializationApi
*/
@property (readonly) NSString *serialName __attribute__((swift_name("serialName")));
@end

__attribute__((swift_name("Kotlinx_serialization_coreDecoder")))
@protocol STTKotlinx_serialization_coreDecoder
@required
- (id<STTKotlinx_serialization_coreCompositeDecoder>)beginStructureDescriptor:(id<STTKotlinx_serialization_coreSerialDescriptor>)descriptor __attribute__((swift_name("beginStructure(descriptor:)")));
- (BOOL)decodeBoolean __attribute__((swift_name("decodeBoolean()")));
- (int8_t)decodeByte __attribute__((swift_name("decodeByte()")));
- (unichar)decodeChar __attribute__((swift_name("decodeChar()")));
- (double)decodeDouble __attribute__((swift_name("decodeDouble()")));
- (int32_t)decodeEnumEnumDescriptor:(id<STTKotlinx_serialization_coreSerialDescriptor>)enumDescriptor __attribute__((swift_name("decodeEnum(enumDescriptor:)")));
- (float)decodeFloat __attribute__((swift_name("decodeFloat()")));
- (id<STTKotlinx_serialization_coreDecoder>)decodeInlineDescriptor:(id<STTKotlinx_serialization_coreSerialDescriptor>)descriptor __attribute__((swift_name("decodeInline(descriptor:)")));
- (int32_t)decodeInt __attribute__((swift_name("decodeInt()")));
- (int64_t)decodeLong __attribute__((swift_name("decodeLong()")));

/**
 * @note annotations
 *   kotlinx.serialization.ExperimentalSerializationApi
*/
- (BOOL)decodeNotNullMark __attribute__((swift_name("decodeNotNullMark()")));

/**
 * @note annotations
 *   kotlinx.serialization.ExperimentalSerializationApi
*/
- (STTKotlinNothing * _Nullable)decodeNull __attribute__((swift_name("decodeNull()")));

/**
 * @note annotations
 *   kotlinx.serialization.ExperimentalSerializationApi
*/
- (id _Nullable)decodeNullableSerializableValueDeserializer:(id<STTKotlinx_serialization_coreDeserializationStrategy>)deserializer __attribute__((swift_name("decodeNullableSerializableValue(deserializer:)")));
- (id _Nullable)decodeSerializableValueDeserializer:(id<STTKotlinx_serialization_coreDeserializationStrategy>)deserializer __attribute__((swift_name("decodeSerializableValue(deserializer:)")));
- (int16_t)decodeShort __attribute__((swift_name("decodeShort()")));
- (NSString *)decodeString __attribute__((swift_name("decodeString()")));
@property (readonly) STTKotlinx_serialization_coreSerializersModule *serializersModule __attribute__((swift_name("serializersModule")));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("Kotlinx_datetimeInstant.Companion")))
@interface STTKotlinx_datetimeInstantCompanion : STTBase
+ (instancetype)alloc __attribute__((unavailable));
+ (instancetype)allocWithZone:(struct _NSZone *)zone __attribute__((unavailable));
+ (instancetype)companion __attribute__((swift_name("init()")));
@property (class, readonly, getter=shared) STTKotlinx_datetimeInstantCompanion *shared __attribute__((swift_name("shared")));
- (STTKotlinx_datetimeInstant *)fromEpochMillisecondsEpochMilliseconds:(int64_t)epochMilliseconds __attribute__((swift_name("fromEpochMilliseconds(epochMilliseconds:)")));
- (STTKotlinx_datetimeInstant *)fromEpochSecondsEpochSeconds:(int64_t)epochSeconds nanosecondAdjustment:(int32_t)nanosecondAdjustment __attribute__((swift_name("fromEpochSeconds(epochSeconds:nanosecondAdjustment:)")));
- (STTKotlinx_datetimeInstant *)fromEpochSecondsEpochSeconds:(int64_t)epochSeconds nanosecondAdjustment_:(int64_t)nanosecondAdjustment __attribute__((swift_name("fromEpochSeconds(epochSeconds:nanosecondAdjustment_:)")));
- (STTKotlinx_datetimeInstant *)now __attribute__((swift_name("now()"))) __attribute__((unavailable("Use Clock.System.now() instead")));
- (STTKotlinx_datetimeInstant *)parseInput:(id)input format:(id<STTKotlinx_datetimeDateTimeFormat>)format __attribute__((swift_name("parse(input:format:)")));
- (id<STTKotlinx_serialization_coreKSerializer>)serializer __attribute__((swift_name("serializer()")));
@property (readonly) STTKotlinx_datetimeInstant *DISTANT_FUTURE __attribute__((swift_name("DISTANT_FUTURE")));
@property (readonly) STTKotlinx_datetimeInstant *DISTANT_PAST __attribute__((swift_name("DISTANT_PAST")));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("Kotlinx_datetimeLocalDateTime.Companion")))
@interface STTKotlinx_datetimeLocalDateTimeCompanion : STTBase
+ (instancetype)alloc __attribute__((unavailable));
+ (instancetype)allocWithZone:(struct _NSZone *)zone __attribute__((unavailable));
+ (instancetype)companion __attribute__((swift_name("init()")));
@property (class, readonly, getter=shared) STTKotlinx_datetimeLocalDateTimeCompanion *shared __attribute__((swift_name("shared")));
- (id<STTKotlinx_datetimeDateTimeFormat>)FormatBuilder:(void (^)(id<STTKotlinx_datetimeDateTimeFormatBuilderWithDateTime>))builder __attribute__((swift_name("Format(builder:)")));
- (STTKotlinx_datetimeLocalDateTime *)parseInput:(id)input format:(id<STTKotlinx_datetimeDateTimeFormat>)format __attribute__((swift_name("parse(input:format:)")));
- (id<STTKotlinx_serialization_coreKSerializer>)serializer __attribute__((swift_name("serializer()")));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("Kotlinx_datetimeLocalTime.Companion")))
@interface STTKotlinx_datetimeLocalTimeCompanion : STTBase
+ (instancetype)alloc __attribute__((unavailable));
+ (instancetype)allocWithZone:(struct _NSZone *)zone __attribute__((unavailable));
+ (instancetype)companion __attribute__((swift_name("init()")));
@property (class, readonly, getter=shared) STTKotlinx_datetimeLocalTimeCompanion *shared __attribute__((swift_name("shared")));
- (id<STTKotlinx_datetimeDateTimeFormat>)FormatBuilder:(void (^)(id<STTKotlinx_datetimeDateTimeFormatBuilderWithTime>))builder __attribute__((swift_name("Format(builder:)")));
- (STTKotlinx_datetimeLocalTime *)fromMillisecondOfDayMillisecondOfDay:(int32_t)millisecondOfDay __attribute__((swift_name("fromMillisecondOfDay(millisecondOfDay:)")));
- (STTKotlinx_datetimeLocalTime *)fromNanosecondOfDayNanosecondOfDay:(int64_t)nanosecondOfDay __attribute__((swift_name("fromNanosecondOfDay(nanosecondOfDay:)")));
- (STTKotlinx_datetimeLocalTime *)fromSecondOfDaySecondOfDay:(int32_t)secondOfDay __attribute__((swift_name("fromSecondOfDay(secondOfDay:)")));
- (STTKotlinx_datetimeLocalTime *)parseInput:(id)input format:(id<STTKotlinx_datetimeDateTimeFormat>)format __attribute__((swift_name("parse(input:format:)")));
- (id<STTKotlinx_serialization_coreKSerializer>)serializer __attribute__((swift_name("serializer()")));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("Kotlinx_datetimeTimeZone.Companion")))
@interface STTKotlinx_datetimeTimeZoneCompanion : STTBase
+ (instancetype)alloc __attribute__((unavailable));
+ (instancetype)allocWithZone:(struct _NSZone *)zone __attribute__((unavailable));
+ (instancetype)companion __attribute__((swift_name("init()")));
@property (class, readonly, getter=shared) STTKotlinx_datetimeTimeZoneCompanion *shared __attribute__((swift_name("shared")));
- (STTKotlinx_datetimeTimeZone *)currentSystemDefault __attribute__((swift_name("currentSystemDefault()")));
- (STTKotlinx_datetimeTimeZone *)ofZoneId:(NSString *)zoneId __attribute__((swift_name("of(zoneId:)")));
- (id<STTKotlinx_serialization_coreKSerializer>)serializer __attribute__((swift_name("serializer()")));
@property (readonly) STTKotlinx_datetimeFixedOffsetTimeZone *UTC __attribute__((swift_name("UTC")));
@property (readonly) NSSet<NSString *> *availableZoneIds __attribute__((swift_name("availableZoneIds")));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("Kotlinx_datetimeDateTimeUnit.Companion")))
@interface STTKotlinx_datetimeDateTimeUnitCompanion : STTBase
+ (instancetype)alloc __attribute__((unavailable));
+ (instancetype)allocWithZone:(struct _NSZone *)zone __attribute__((unavailable));
+ (instancetype)companion __attribute__((swift_name("init()")));
@property (class, readonly, getter=shared) STTKotlinx_datetimeDateTimeUnitCompanion *shared __attribute__((swift_name("shared")));
- (id<STTKotlinx_serialization_coreKSerializer>)serializer __attribute__((swift_name("serializer()")));
@property (readonly) STTKotlinx_datetimeDateTimeUnitMonthBased *CENTURY __attribute__((swift_name("CENTURY")));
@property (readonly) STTKotlinx_datetimeDateTimeUnitDayBased *DAY __attribute__((swift_name("DAY")));
@property (readonly) STTKotlinx_datetimeDateTimeUnitTimeBased *HOUR __attribute__((swift_name("HOUR")));
@property (readonly) STTKotlinx_datetimeDateTimeUnitTimeBased *MICROSECOND __attribute__((swift_name("MICROSECOND")));
@property (readonly) STTKotlinx_datetimeDateTimeUnitTimeBased *MILLISECOND __attribute__((swift_name("MILLISECOND")));
@property (readonly) STTKotlinx_datetimeDateTimeUnitTimeBased *MINUTE __attribute__((swift_name("MINUTE")));
@property (readonly) STTKotlinx_datetimeDateTimeUnitMonthBased *MONTH __attribute__((swift_name("MONTH")));
@property (readonly) STTKotlinx_datetimeDateTimeUnitTimeBased *NANOSECOND __attribute__((swift_name("NANOSECOND")));
@property (readonly) STTKotlinx_datetimeDateTimeUnitMonthBased *QUARTER __attribute__((swift_name("QUARTER")));
@property (readonly) STTKotlinx_datetimeDateTimeUnitTimeBased *SECOND __attribute__((swift_name("SECOND")));
@property (readonly) STTKotlinx_datetimeDateTimeUnitDayBased *WEEK __attribute__((swift_name("WEEK")));
@property (readonly) STTKotlinx_datetimeDateTimeUnitMonthBased *YEAR __attribute__((swift_name("YEAR")));
@end

__attribute__((swift_name("Kotlinx_datetimeDateTimeFormat")))
@protocol STTKotlinx_datetimeDateTimeFormat
@required
- (NSString *)formatValue:(id _Nullable)value __attribute__((swift_name("format(value:)")));
- (id<STTKotlinAppendable>)formatToAppendable:(id<STTKotlinAppendable>)appendable value:(id _Nullable)value __attribute__((swift_name("formatTo(appendable:value:)")));
- (id _Nullable)parseInput:(id)input __attribute__((swift_name("parse(input:)")));
- (id _Nullable)parseOrNullInput:(id)input __attribute__((swift_name("parseOrNull(input:)")));
@end

__attribute__((swift_name("Kotlinx_datetimeDateTimeFormatBuilder")))
@protocol STTKotlinx_datetimeDateTimeFormatBuilder
@required
- (void)charsValue:(NSString *)value __attribute__((swift_name("chars(value:)")));
@end

__attribute__((swift_name("Kotlinx_datetimeDateTimeFormatBuilderWithDate")))
@protocol STTKotlinx_datetimeDateTimeFormatBuilderWithDate <STTKotlinx_datetimeDateTimeFormatBuilder>
@required
- (void)dateFormat:(id<STTKotlinx_datetimeDateTimeFormat>)format __attribute__((swift_name("date(format:)")));
- (void)dayOfMonthPadding:(STTKotlinx_datetimePadding *)padding __attribute__((swift_name("dayOfMonth(padding:)")));
- (void)dayOfWeekNames:(STTKotlinx_datetimeDayOfWeekNames *)names __attribute__((swift_name("dayOfWeek(names:)")));
- (void)monthNameNames:(STTKotlinx_datetimeMonthNames *)names __attribute__((swift_name("monthName(names:)")));
- (void)monthNumberPadding:(STTKotlinx_datetimePadding *)padding __attribute__((swift_name("monthNumber(padding:)")));
- (void)yearPadding:(STTKotlinx_datetimePadding *)padding __attribute__((swift_name("year(padding:)")));
- (void)yearTwoDigitsBaseYear:(int32_t)baseYear __attribute__((swift_name("yearTwoDigits(baseYear:)")));
@end

__attribute__((swift_name("Kotlinx_serialization_coreCompositeEncoder")))
@protocol STTKotlinx_serialization_coreCompositeEncoder
@required
- (void)encodeBooleanElementDescriptor:(id<STTKotlinx_serialization_coreSerialDescriptor>)descriptor index:(int32_t)index value:(BOOL)value __attribute__((swift_name("encodeBooleanElement(descriptor:index:value:)")));
- (void)encodeByteElementDescriptor:(id<STTKotlinx_serialization_coreSerialDescriptor>)descriptor index:(int32_t)index value:(int8_t)value __attribute__((swift_name("encodeByteElement(descriptor:index:value:)")));
- (void)encodeCharElementDescriptor:(id<STTKotlinx_serialization_coreSerialDescriptor>)descriptor index:(int32_t)index value:(unichar)value __attribute__((swift_name("encodeCharElement(descriptor:index:value:)")));
- (void)encodeDoubleElementDescriptor:(id<STTKotlinx_serialization_coreSerialDescriptor>)descriptor index:(int32_t)index value:(double)value __attribute__((swift_name("encodeDoubleElement(descriptor:index:value:)")));
- (void)encodeFloatElementDescriptor:(id<STTKotlinx_serialization_coreSerialDescriptor>)descriptor index:(int32_t)index value:(float)value __attribute__((swift_name("encodeFloatElement(descriptor:index:value:)")));
- (id<STTKotlinx_serialization_coreEncoder>)encodeInlineElementDescriptor:(id<STTKotlinx_serialization_coreSerialDescriptor>)descriptor index:(int32_t)index __attribute__((swift_name("encodeInlineElement(descriptor:index:)")));
- (void)encodeIntElementDescriptor:(id<STTKotlinx_serialization_coreSerialDescriptor>)descriptor index:(int32_t)index value:(int32_t)value __attribute__((swift_name("encodeIntElement(descriptor:index:value:)")));
- (void)encodeLongElementDescriptor:(id<STTKotlinx_serialization_coreSerialDescriptor>)descriptor index:(int32_t)index value:(int64_t)value __attribute__((swift_name("encodeLongElement(descriptor:index:value:)")));

/**
 * @note annotations
 *   kotlinx.serialization.ExperimentalSerializationApi
*/
- (void)encodeNullableSerializableElementDescriptor:(id<STTKotlinx_serialization_coreSerialDescriptor>)descriptor index:(int32_t)index serializer:(id<STTKotlinx_serialization_coreSerializationStrategy>)serializer value:(id _Nullable)value __attribute__((swift_name("encodeNullableSerializableElement(descriptor:index:serializer:value:)")));
- (void)encodeSerializableElementDescriptor:(id<STTKotlinx_serialization_coreSerialDescriptor>)descriptor index:(int32_t)index serializer:(id<STTKotlinx_serialization_coreSerializationStrategy>)serializer value:(id _Nullable)value __attribute__((swift_name("encodeSerializableElement(descriptor:index:serializer:value:)")));
- (void)encodeShortElementDescriptor:(id<STTKotlinx_serialization_coreSerialDescriptor>)descriptor index:(int32_t)index value:(int16_t)value __attribute__((swift_name("encodeShortElement(descriptor:index:value:)")));
- (void)encodeStringElementDescriptor:(id<STTKotlinx_serialization_coreSerialDescriptor>)descriptor index:(int32_t)index value:(NSString *)value __attribute__((swift_name("encodeStringElement(descriptor:index:value:)")));
- (void)endStructureDescriptor:(id<STTKotlinx_serialization_coreSerialDescriptor>)descriptor __attribute__((swift_name("endStructure(descriptor:)")));

/**
 * @note annotations
 *   kotlinx.serialization.ExperimentalSerializationApi
*/
- (BOOL)shouldEncodeElementDefaultDescriptor:(id<STTKotlinx_serialization_coreSerialDescriptor>)descriptor index:(int32_t)index __attribute__((swift_name("shouldEncodeElementDefault(descriptor:index:)")));
@property (readonly) STTKotlinx_serialization_coreSerializersModule *serializersModule __attribute__((swift_name("serializersModule")));
@end

__attribute__((swift_name("Kotlinx_serialization_coreSerializersModule")))
@interface STTKotlinx_serialization_coreSerializersModule : STTBase

/**
 * @note annotations
 *   kotlinx.serialization.ExperimentalSerializationApi
*/
- (void)dumpToCollector:(id<STTKotlinx_serialization_coreSerializersModuleCollector>)collector __attribute__((swift_name("dumpTo(collector:)")));

/**
 * @note annotations
 *   kotlinx.serialization.ExperimentalSerializationApi
*/
- (id<STTKotlinx_serialization_coreKSerializer> _Nullable)getContextualKClass:(id<STTKotlinKClass>)kClass typeArgumentsSerializers:(NSArray<id<STTKotlinx_serialization_coreKSerializer>> *)typeArgumentsSerializers __attribute__((swift_name("getContextual(kClass:typeArgumentsSerializers:)")));

/**
 * @note annotations
 *   kotlinx.serialization.ExperimentalSerializationApi
*/
- (id<STTKotlinx_serialization_coreSerializationStrategy> _Nullable)getPolymorphicBaseClass:(id<STTKotlinKClass>)baseClass value:(id)value __attribute__((swift_name("getPolymorphic(baseClass:value:)")));

/**
 * @note annotations
 *   kotlinx.serialization.ExperimentalSerializationApi
*/
- (id<STTKotlinx_serialization_coreDeserializationStrategy> _Nullable)getPolymorphicBaseClass:(id<STTKotlinKClass>)baseClass serializedClassName:(NSString * _Nullable)serializedClassName __attribute__((swift_name("getPolymorphic(baseClass:serializedClassName:)")));
@end

__attribute__((swift_name("KotlinAnnotation")))
@protocol STTKotlinAnnotation
@required
@end


/**
 * @note annotations
 *   kotlinx.serialization.ExperimentalSerializationApi
*/
__attribute__((swift_name("Kotlinx_serialization_coreSerialKind")))
@interface STTKotlinx_serialization_coreSerialKind : STTBase
- (NSUInteger)hash __attribute__((swift_name("hash()")));
- (NSString *)description __attribute__((swift_name("description()")));
@end

__attribute__((swift_name("Kotlinx_serialization_coreCompositeDecoder")))
@protocol STTKotlinx_serialization_coreCompositeDecoder
@required
- (BOOL)decodeBooleanElementDescriptor:(id<STTKotlinx_serialization_coreSerialDescriptor>)descriptor index:(int32_t)index __attribute__((swift_name("decodeBooleanElement(descriptor:index:)")));
- (int8_t)decodeByteElementDescriptor:(id<STTKotlinx_serialization_coreSerialDescriptor>)descriptor index:(int32_t)index __attribute__((swift_name("decodeByteElement(descriptor:index:)")));
- (unichar)decodeCharElementDescriptor:(id<STTKotlinx_serialization_coreSerialDescriptor>)descriptor index:(int32_t)index __attribute__((swift_name("decodeCharElement(descriptor:index:)")));
- (int32_t)decodeCollectionSizeDescriptor:(id<STTKotlinx_serialization_coreSerialDescriptor>)descriptor __attribute__((swift_name("decodeCollectionSize(descriptor:)")));
- (double)decodeDoubleElementDescriptor:(id<STTKotlinx_serialization_coreSerialDescriptor>)descriptor index:(int32_t)index __attribute__((swift_name("decodeDoubleElement(descriptor:index:)")));
- (int32_t)decodeElementIndexDescriptor:(id<STTKotlinx_serialization_coreSerialDescriptor>)descriptor __attribute__((swift_name("decodeElementIndex(descriptor:)")));
- (float)decodeFloatElementDescriptor:(id<STTKotlinx_serialization_coreSerialDescriptor>)descriptor index:(int32_t)index __attribute__((swift_name("decodeFloatElement(descriptor:index:)")));
- (id<STTKotlinx_serialization_coreDecoder>)decodeInlineElementDescriptor:(id<STTKotlinx_serialization_coreSerialDescriptor>)descriptor index:(int32_t)index __attribute__((swift_name("decodeInlineElement(descriptor:index:)")));
- (int32_t)decodeIntElementDescriptor:(id<STTKotlinx_serialization_coreSerialDescriptor>)descriptor index:(int32_t)index __attribute__((swift_name("decodeIntElement(descriptor:index:)")));
- (int64_t)decodeLongElementDescriptor:(id<STTKotlinx_serialization_coreSerialDescriptor>)descriptor index:(int32_t)index __attribute__((swift_name("decodeLongElement(descriptor:index:)")));

/**
 * @note annotations
 *   kotlinx.serialization.ExperimentalSerializationApi
*/
- (id _Nullable)decodeNullableSerializableElementDescriptor:(id<STTKotlinx_serialization_coreSerialDescriptor>)descriptor index:(int32_t)index deserializer:(id<STTKotlinx_serialization_coreDeserializationStrategy>)deserializer previousValue:(id _Nullable)previousValue __attribute__((swift_name("decodeNullableSerializableElement(descriptor:index:deserializer:previousValue:)")));

/**
 * @note annotations
 *   kotlinx.serialization.ExperimentalSerializationApi
*/
- (BOOL)decodeSequentially __attribute__((swift_name("decodeSequentially()")));
- (id _Nullable)decodeSerializableElementDescriptor:(id<STTKotlinx_serialization_coreSerialDescriptor>)descriptor index:(int32_t)index deserializer:(id<STTKotlinx_serialization_coreDeserializationStrategy>)deserializer previousValue:(id _Nullable)previousValue __attribute__((swift_name("decodeSerializableElement(descriptor:index:deserializer:previousValue:)")));
- (int16_t)decodeShortElementDescriptor:(id<STTKotlinx_serialization_coreSerialDescriptor>)descriptor index:(int32_t)index __attribute__((swift_name("decodeShortElement(descriptor:index:)")));
- (NSString *)decodeStringElementDescriptor:(id<STTKotlinx_serialization_coreSerialDescriptor>)descriptor index:(int32_t)index __attribute__((swift_name("decodeStringElement(descriptor:index:)")));
- (void)endStructureDescriptor:(id<STTKotlinx_serialization_coreSerialDescriptor>)descriptor __attribute__((swift_name("endStructure(descriptor:)")));
@property (readonly) STTKotlinx_serialization_coreSerializersModule *serializersModule __attribute__((swift_name("serializersModule")));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("KotlinNothing")))
@interface STTKotlinNothing : STTBase
@end

__attribute__((swift_name("Kotlinx_datetimeDateTimeFormatBuilderWithTime")))
@protocol STTKotlinx_datetimeDateTimeFormatBuilderWithTime <STTKotlinx_datetimeDateTimeFormatBuilder>
@required
- (void)amPmHourPadding:(STTKotlinx_datetimePadding *)padding __attribute__((swift_name("amPmHour(padding:)")));
- (void)amPmMarkerAm:(NSString *)am pm:(NSString *)pm __attribute__((swift_name("amPmMarker(am:pm:)")));
- (void)hourPadding:(STTKotlinx_datetimePadding *)padding __attribute__((swift_name("hour(padding:)")));
- (void)minutePadding:(STTKotlinx_datetimePadding *)padding __attribute__((swift_name("minute(padding:)")));
- (void)secondPadding:(STTKotlinx_datetimePadding *)padding __attribute__((swift_name("second(padding:)")));
- (void)secondFractionFixedLength:(int32_t)fixedLength __attribute__((swift_name("secondFraction(fixedLength:)")));
- (void)secondFractionMinLength:(int32_t)minLength maxLength:(int32_t)maxLength __attribute__((swift_name("secondFraction(minLength:maxLength:)")));
- (void)timeFormat:(id<STTKotlinx_datetimeDateTimeFormat>)format __attribute__((swift_name("time(format:)")));
@end

__attribute__((swift_name("Kotlinx_datetimeDateTimeFormatBuilderWithDateTime")))
@protocol STTKotlinx_datetimeDateTimeFormatBuilderWithDateTime <STTKotlinx_datetimeDateTimeFormatBuilderWithDate, STTKotlinx_datetimeDateTimeFormatBuilderWithTime>
@required
- (void)dateTimeFormat:(id<STTKotlinx_datetimeDateTimeFormat>)format __attribute__((swift_name("dateTime(format:)")));
@end


/**
 * @note annotations
 *   kotlinx.serialization.Serializable(with=NormalClass(value=kotlinx/datetime/serializers/FixedOffsetTimeZoneSerializer))
*/
__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("Kotlinx_datetimeFixedOffsetTimeZone")))
@interface STTKotlinx_datetimeFixedOffsetTimeZone : STTKotlinx_datetimeTimeZone
- (instancetype)initWithOffset:(STTKotlinx_datetimeUtcOffset *)offset __attribute__((swift_name("init(offset:)"))) __attribute__((objc_designated_initializer));
@property (class, readonly, getter=companion) STTKotlinx_datetimeFixedOffsetTimeZoneCompanion *companion __attribute__((swift_name("companion")));
@property (readonly) NSString *id __attribute__((swift_name("id")));
@property (readonly) STTKotlinx_datetimeUtcOffset *offset __attribute__((swift_name("offset")));
@property (readonly) int32_t totalSeconds __attribute__((swift_name("totalSeconds"))) __attribute__((deprecated("Use offset.totalSeconds")));
@end


/**
 * @note annotations
 *   kotlinx.serialization.Serializable(with=NormalClass(value=kotlinx/datetime/serializers/DateBasedDateTimeUnitSerializer))
*/
__attribute__((swift_name("Kotlinx_datetimeDateTimeUnit.DateBased")))
@interface STTKotlinx_datetimeDateTimeUnitDateBased : STTKotlinx_datetimeDateTimeUnit
@property (class, readonly, getter=companion) STTKotlinx_datetimeDateTimeUnitDateBasedCompanion *companion __attribute__((swift_name("companion")));
@end


/**
 * @note annotations
 *   kotlinx.serialization.Serializable(with=NormalClass(value=kotlinx/datetime/serializers/MonthBasedDateTimeUnitSerializer))
*/
__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("Kotlinx_datetimeDateTimeUnit.MonthBased")))
@interface STTKotlinx_datetimeDateTimeUnitMonthBased : STTKotlinx_datetimeDateTimeUnitDateBased
- (instancetype)initWithMonths:(int32_t)months __attribute__((swift_name("init(months:)"))) __attribute__((objc_designated_initializer));
@property (class, readonly, getter=companion) STTKotlinx_datetimeDateTimeUnitMonthBasedCompanion *companion __attribute__((swift_name("companion")));
- (BOOL)isEqual:(id _Nullable)other __attribute__((swift_name("isEqual(_:)")));
- (NSUInteger)hash __attribute__((swift_name("hash()")));
- (STTKotlinx_datetimeDateTimeUnitMonthBased *)timesScalar:(int32_t)scalar __attribute__((swift_name("times(scalar:)")));
- (NSString *)description __attribute__((swift_name("description()")));
@property (readonly) int32_t months __attribute__((swift_name("months")));
@end


/**
 * @note annotations
 *   kotlinx.serialization.Serializable(with=NormalClass(value=kotlinx/datetime/serializers/DayBasedDateTimeUnitSerializer))
*/
__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("Kotlinx_datetimeDateTimeUnit.DayBased")))
@interface STTKotlinx_datetimeDateTimeUnitDayBased : STTKotlinx_datetimeDateTimeUnitDateBased
- (instancetype)initWithDays:(int32_t)days __attribute__((swift_name("init(days:)"))) __attribute__((objc_designated_initializer));
@property (class, readonly, getter=companion) STTKotlinx_datetimeDateTimeUnitDayBasedCompanion *companion __attribute__((swift_name("companion")));
- (BOOL)isEqual:(id _Nullable)other __attribute__((swift_name("isEqual(_:)")));
- (NSUInteger)hash __attribute__((swift_name("hash()")));
- (STTKotlinx_datetimeDateTimeUnitDayBased *)timesScalar:(int32_t)scalar __attribute__((swift_name("times(scalar:)")));
- (NSString *)description __attribute__((swift_name("description()")));
@property (readonly) int32_t days __attribute__((swift_name("days")));
@end


/**
 * @note annotations
 *   kotlinx.serialization.Serializable(with=NormalClass(value=kotlinx/datetime/serializers/TimeBasedDateTimeUnitSerializer))
*/
__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("Kotlinx_datetimeDateTimeUnit.TimeBased")))
@interface STTKotlinx_datetimeDateTimeUnitTimeBased : STTKotlinx_datetimeDateTimeUnit
- (instancetype)initWithNanoseconds:(int64_t)nanoseconds __attribute__((swift_name("init(nanoseconds:)"))) __attribute__((objc_designated_initializer));
@property (class, readonly, getter=companion) STTKotlinx_datetimeDateTimeUnitTimeBasedCompanion *companion __attribute__((swift_name("companion")));
- (BOOL)isEqual:(id _Nullable)other __attribute__((swift_name("isEqual(_:)")));
- (NSUInteger)hash __attribute__((swift_name("hash()")));
- (STTKotlinx_datetimeDateTimeUnitTimeBased *)timesScalar:(int32_t)scalar __attribute__((swift_name("times(scalar:)")));
- (NSString *)description __attribute__((swift_name("description()")));
@property (readonly) int64_t duration __attribute__((swift_name("duration")));
@property (readonly) int64_t nanoseconds __attribute__((swift_name("nanoseconds")));
@end

__attribute__((swift_name("KotlinAppendable")))
@protocol STTKotlinAppendable
@required
- (id<STTKotlinAppendable>)appendValue:(unichar)value __attribute__((swift_name("append(value:)")));
- (id<STTKotlinAppendable>)appendValue_:(id _Nullable)value __attribute__((swift_name("append(value_:)")));
- (id<STTKotlinAppendable>)appendValue:(id _Nullable)value startIndex:(int32_t)startIndex endIndex:(int32_t)endIndex __attribute__((swift_name("append(value:startIndex:endIndex:)")));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("Kotlinx_datetimePadding")))
@interface STTKotlinx_datetimePadding : STTKotlinEnum<STTKotlinx_datetimePadding *>
+ (instancetype)alloc __attribute__((unavailable));
+ (instancetype)allocWithZone:(struct _NSZone *)zone __attribute__((unavailable));
- (instancetype)initWithName:(NSString *)name ordinal:(int32_t)ordinal __attribute__((swift_name("init(name:ordinal:)"))) __attribute__((objc_designated_initializer)) __attribute__((unavailable));
@property (class, readonly) STTKotlinx_datetimePadding *none __attribute__((swift_name("none")));
@property (class, readonly) STTKotlinx_datetimePadding *zero __attribute__((swift_name("zero")));
@property (class, readonly) STTKotlinx_datetimePadding *space __attribute__((swift_name("space")));
+ (STTKotlinArray<STTKotlinx_datetimePadding *> *)values __attribute__((swift_name("values()")));
@property (class, readonly) NSArray<STTKotlinx_datetimePadding *> *entries __attribute__((swift_name("entries")));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("Kotlinx_datetimeDayOfWeekNames")))
@interface STTKotlinx_datetimeDayOfWeekNames : STTBase
- (instancetype)initWithNames:(NSArray<NSString *> *)names __attribute__((swift_name("init(names:)"))) __attribute__((objc_designated_initializer));
- (instancetype)initWithMonday:(NSString *)monday tuesday:(NSString *)tuesday wednesday:(NSString *)wednesday thursday:(NSString *)thursday friday:(NSString *)friday saturday:(NSString *)saturday sunday:(NSString *)sunday __attribute__((swift_name("init(monday:tuesday:wednesday:thursday:friday:saturday:sunday:)"))) __attribute__((objc_designated_initializer));
@property (class, readonly, getter=companion) STTKotlinx_datetimeDayOfWeekNamesCompanion *companion __attribute__((swift_name("companion")));
- (BOOL)isEqual:(id _Nullable)other __attribute__((swift_name("isEqual(_:)")));
- (NSUInteger)hash __attribute__((swift_name("hash()")));
- (NSString *)description __attribute__((swift_name("description()")));
@property (readonly) NSArray<NSString *> *names __attribute__((swift_name("names")));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("Kotlinx_datetimeMonthNames")))
@interface STTKotlinx_datetimeMonthNames : STTBase
- (instancetype)initWithNames:(NSArray<NSString *> *)names __attribute__((swift_name("init(names:)"))) __attribute__((objc_designated_initializer));
- (instancetype)initWithJanuary:(NSString *)january february:(NSString *)february march:(NSString *)march april:(NSString *)april may:(NSString *)may june:(NSString *)june july:(NSString *)july august:(NSString *)august september:(NSString *)september october:(NSString *)october november:(NSString *)november december:(NSString *)december __attribute__((swift_name("init(january:february:march:april:may:june:july:august:september:october:november:december:)"))) __attribute__((objc_designated_initializer));
@property (class, readonly, getter=companion) STTKotlinx_datetimeMonthNamesCompanion *companion __attribute__((swift_name("companion")));
- (BOOL)isEqual:(id _Nullable)other __attribute__((swift_name("isEqual(_:)")));
- (NSUInteger)hash __attribute__((swift_name("hash()")));
- (NSString *)description __attribute__((swift_name("description()")));
@property (readonly) NSArray<NSString *> *names __attribute__((swift_name("names")));
@end


/**
 * @note annotations
 *   kotlinx.serialization.ExperimentalSerializationApi
*/
__attribute__((swift_name("Kotlinx_serialization_coreSerializersModuleCollector")))
@protocol STTKotlinx_serialization_coreSerializersModuleCollector
@required
- (void)contextualKClass:(id<STTKotlinKClass>)kClass provider:(id<STTKotlinx_serialization_coreKSerializer> (^)(NSArray<id<STTKotlinx_serialization_coreKSerializer>> *))provider __attribute__((swift_name("contextual(kClass:provider:)")));
- (void)contextualKClass:(id<STTKotlinKClass>)kClass serializer:(id<STTKotlinx_serialization_coreKSerializer>)serializer __attribute__((swift_name("contextual(kClass:serializer:)")));
- (void)polymorphicBaseClass:(id<STTKotlinKClass>)baseClass actualClass:(id<STTKotlinKClass>)actualClass actualSerializer:(id<STTKotlinx_serialization_coreKSerializer>)actualSerializer __attribute__((swift_name("polymorphic(baseClass:actualClass:actualSerializer:)")));
- (void)polymorphicDefaultBaseClass:(id<STTKotlinKClass>)baseClass defaultDeserializerProvider:(id<STTKotlinx_serialization_coreDeserializationStrategy> _Nullable (^)(NSString * _Nullable))defaultDeserializerProvider __attribute__((swift_name("polymorphicDefault(baseClass:defaultDeserializerProvider:)"))) __attribute__((deprecated("Deprecated in favor of function with more precise name: polymorphicDefaultDeserializer")));
- (void)polymorphicDefaultDeserializerBaseClass:(id<STTKotlinKClass>)baseClass defaultDeserializerProvider:(id<STTKotlinx_serialization_coreDeserializationStrategy> _Nullable (^)(NSString * _Nullable))defaultDeserializerProvider __attribute__((swift_name("polymorphicDefaultDeserializer(baseClass:defaultDeserializerProvider:)")));
- (void)polymorphicDefaultSerializerBaseClass:(id<STTKotlinKClass>)baseClass defaultSerializerProvider:(id<STTKotlinx_serialization_coreSerializationStrategy> _Nullable (^)(id))defaultSerializerProvider __attribute__((swift_name("polymorphicDefaultSerializer(baseClass:defaultSerializerProvider:)")));
@end

__attribute__((swift_name("KotlinKDeclarationContainer")))
@protocol STTKotlinKDeclarationContainer
@required
@end

__attribute__((swift_name("KotlinKAnnotatedElement")))
@protocol STTKotlinKAnnotatedElement
@required
@end


/**
 * @note annotations
 *   kotlin.SinceKotlin(version="1.1")
*/
__attribute__((swift_name("KotlinKClassifier")))
@protocol STTKotlinKClassifier
@required
@end

__attribute__((swift_name("KotlinKClass")))
@protocol STTKotlinKClass <STTKotlinKDeclarationContainer, STTKotlinKAnnotatedElement, STTKotlinKClassifier>
@required

/**
 * @note annotations
 *   kotlin.SinceKotlin(version="1.1")
*/
- (BOOL)isInstanceValue:(id _Nullable)value __attribute__((swift_name("isInstance(value:)")));
@property (readonly) NSString * _Nullable qualifiedName __attribute__((swift_name("qualifiedName")));
@property (readonly) NSString * _Nullable simpleName __attribute__((swift_name("simpleName")));
@end


/**
 * @note annotations
 *   kotlinx.serialization.Serializable(with=NormalClass(value=kotlinx/datetime/serializers/UtcOffsetSerializer))
*/
__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("Kotlinx_datetimeUtcOffset")))
@interface STTKotlinx_datetimeUtcOffset : STTBase
@property (class, readonly, getter=companion) STTKotlinx_datetimeUtcOffsetCompanion *companion __attribute__((swift_name("companion")));
- (BOOL)isEqual:(id _Nullable)other __attribute__((swift_name("isEqual(_:)")));
- (NSUInteger)hash __attribute__((swift_name("hash()")));
- (NSString *)description __attribute__((swift_name("description()")));
@property (readonly) int32_t totalSeconds __attribute__((swift_name("totalSeconds")));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("Kotlinx_datetimeFixedOffsetTimeZone.Companion")))
@interface STTKotlinx_datetimeFixedOffsetTimeZoneCompanion : STTBase
+ (instancetype)alloc __attribute__((unavailable));
+ (instancetype)allocWithZone:(struct _NSZone *)zone __attribute__((unavailable));
+ (instancetype)companion __attribute__((swift_name("init()")));
@property (class, readonly, getter=shared) STTKotlinx_datetimeFixedOffsetTimeZoneCompanion *shared __attribute__((swift_name("shared")));
- (id<STTKotlinx_serialization_coreKSerializer>)serializer __attribute__((swift_name("serializer()")));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("Kotlinx_datetimeDateTimeUnit.DateBasedCompanion")))
@interface STTKotlinx_datetimeDateTimeUnitDateBasedCompanion : STTBase
+ (instancetype)alloc __attribute__((unavailable));
+ (instancetype)allocWithZone:(struct _NSZone *)zone __attribute__((unavailable));
+ (instancetype)companion __attribute__((swift_name("init()")));
@property (class, readonly, getter=shared) STTKotlinx_datetimeDateTimeUnitDateBasedCompanion *shared __attribute__((swift_name("shared")));
- (id<STTKotlinx_serialization_coreKSerializer>)serializer __attribute__((swift_name("serializer()")));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("Kotlinx_datetimeDateTimeUnit.MonthBasedCompanion")))
@interface STTKotlinx_datetimeDateTimeUnitMonthBasedCompanion : STTBase
+ (instancetype)alloc __attribute__((unavailable));
+ (instancetype)allocWithZone:(struct _NSZone *)zone __attribute__((unavailable));
+ (instancetype)companion __attribute__((swift_name("init()")));
@property (class, readonly, getter=shared) STTKotlinx_datetimeDateTimeUnitMonthBasedCompanion *shared __attribute__((swift_name("shared")));
- (id<STTKotlinx_serialization_coreKSerializer>)serializer __attribute__((swift_name("serializer()")));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("Kotlinx_datetimeDateTimeUnit.DayBasedCompanion")))
@interface STTKotlinx_datetimeDateTimeUnitDayBasedCompanion : STTBase
+ (instancetype)alloc __attribute__((unavailable));
+ (instancetype)allocWithZone:(struct _NSZone *)zone __attribute__((unavailable));
+ (instancetype)companion __attribute__((swift_name("init()")));
@property (class, readonly, getter=shared) STTKotlinx_datetimeDateTimeUnitDayBasedCompanion *shared __attribute__((swift_name("shared")));
- (id<STTKotlinx_serialization_coreKSerializer>)serializer __attribute__((swift_name("serializer()")));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("Kotlinx_datetimeDateTimeUnit.TimeBasedCompanion")))
@interface STTKotlinx_datetimeDateTimeUnitTimeBasedCompanion : STTBase
+ (instancetype)alloc __attribute__((unavailable));
+ (instancetype)allocWithZone:(struct _NSZone *)zone __attribute__((unavailable));
+ (instancetype)companion __attribute__((swift_name("init()")));
@property (class, readonly, getter=shared) STTKotlinx_datetimeDateTimeUnitTimeBasedCompanion *shared __attribute__((swift_name("shared")));
- (id<STTKotlinx_serialization_coreKSerializer>)serializer __attribute__((swift_name("serializer()")));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("Kotlinx_datetimeDayOfWeekNames.Companion")))
@interface STTKotlinx_datetimeDayOfWeekNamesCompanion : STTBase
+ (instancetype)alloc __attribute__((unavailable));
+ (instancetype)allocWithZone:(struct _NSZone *)zone __attribute__((unavailable));
+ (instancetype)companion __attribute__((swift_name("init()")));
@property (class, readonly, getter=shared) STTKotlinx_datetimeDayOfWeekNamesCompanion *shared __attribute__((swift_name("shared")));
@property (readonly) STTKotlinx_datetimeDayOfWeekNames *ENGLISH_ABBREVIATED __attribute__((swift_name("ENGLISH_ABBREVIATED")));
@property (readonly) STTKotlinx_datetimeDayOfWeekNames *ENGLISH_FULL __attribute__((swift_name("ENGLISH_FULL")));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("Kotlinx_datetimeMonthNames.Companion")))
@interface STTKotlinx_datetimeMonthNamesCompanion : STTBase
+ (instancetype)alloc __attribute__((unavailable));
+ (instancetype)allocWithZone:(struct _NSZone *)zone __attribute__((unavailable));
+ (instancetype)companion __attribute__((swift_name("init()")));
@property (class, readonly, getter=shared) STTKotlinx_datetimeMonthNamesCompanion *shared __attribute__((swift_name("shared")));
@property (readonly) STTKotlinx_datetimeMonthNames *ENGLISH_ABBREVIATED __attribute__((swift_name("ENGLISH_ABBREVIATED")));
@property (readonly) STTKotlinx_datetimeMonthNames *ENGLISH_FULL __attribute__((swift_name("ENGLISH_FULL")));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("Kotlinx_datetimeUtcOffset.Companion")))
@interface STTKotlinx_datetimeUtcOffsetCompanion : STTBase
+ (instancetype)alloc __attribute__((unavailable));
+ (instancetype)allocWithZone:(struct _NSZone *)zone __attribute__((unavailable));
+ (instancetype)companion __attribute__((swift_name("init()")));
@property (class, readonly, getter=shared) STTKotlinx_datetimeUtcOffsetCompanion *shared __attribute__((swift_name("shared")));
- (id<STTKotlinx_datetimeDateTimeFormat>)FormatBlock:(void (^)(id<STTKotlinx_datetimeDateTimeFormatBuilderWithUtcOffset>))block __attribute__((swift_name("Format(block:)")));
- (STTKotlinx_datetimeUtcOffset *)parseInput:(id)input format:(id<STTKotlinx_datetimeDateTimeFormat>)format __attribute__((swift_name("parse(input:format:)")));
- (id<STTKotlinx_serialization_coreKSerializer>)serializer __attribute__((swift_name("serializer()")));
@property (readonly) STTKotlinx_datetimeUtcOffset *ZERO __attribute__((swift_name("ZERO")));
@end

__attribute__((swift_name("Kotlinx_datetimeDateTimeFormatBuilderWithUtcOffset")))
@protocol STTKotlinx_datetimeDateTimeFormatBuilderWithUtcOffset <STTKotlinx_datetimeDateTimeFormatBuilder>
@required
- (void)offsetFormat:(id<STTKotlinx_datetimeDateTimeFormat>)format __attribute__((swift_name("offset(format:)")));
- (void)offsetHoursPadding:(STTKotlinx_datetimePadding *)padding __attribute__((swift_name("offsetHours(padding:)")));
- (void)offsetMinutesOfHourPadding:(STTKotlinx_datetimePadding *)padding __attribute__((swift_name("offsetMinutesOfHour(padding:)")));
- (void)offsetSecondsOfMinutePadding:(STTKotlinx_datetimePadding *)padding __attribute__((swift_name("offsetSecondsOfMinute(padding:)")));
@end

#pragma pop_macro("_Nullable_result")
#pragma clang diagnostic pop
NS_ASSUME_NONNULL_END
